package tech.kayys.silat.security;

import io.quarkus.security.identity.SecurityIdentity;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.ws.rs.container.ContainerRequestContext;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * ============================================================================
 * SECURITY & COMPLIANCE FRAMEWORK
 * ============================================================================
 * 
 * Comprehensive security with:
 * - Fine-grained RBAC (Role-Based Access Control)
 * - ABAC (Attribute-Based Access Control)
 * - PII detection and redaction
 * - Audit logging for compliance
 * - Data encryption
 * - Secret management
 * - Content safety and guardrails
 * 
 * Compliance: GDPR, HIPAA, SOC 2, ISO 27001
 * 
 * Package: tech.kayys.silat.security
 */

// ==================== ACCESS CONTROL SERVICE ====================

@ApplicationScoped
public class AccessControlService {
    
    private static final Logger LOG = LoggerFactory.getLogger(AccessControlService.class);
    
    @Inject
    RoleRepository roleRepository;
    
    @Inject
    PermissionEvaluator permissionEvaluator;
    
    @Inject
    AuditLogger auditLogger;
    
    @Inject
    SecurityIdentity identity;
    
    /**
     * Check if user has permission for resource
     */
    public Uni<Boolean> hasPermission(
            String userId,
            String tenantId,
            String resource,
            String action) {
        
        LOG.debug("Checking permission: user={}, resource={}, action={}", 
            userId, resource, action);
        
        return roleRepository.getUserRoles(userId, tenantId)
            .flatMap(roles -> {
                // Check each role for permission
                return Uni.join().all(
                    roles.stream()
                        .map(role -> checkRolePermission(role, resource, action))
                        .collect(Collectors.toList())
                ).andFailFast()
                .map(results -> results.stream().anyMatch(Boolean::booleanValue));
            })
            .onItem().invoke(allowed -> {
                // Log access attempt
                auditLogger.logAccessAttempt(
                    userId, tenantId, resource, action, allowed
                );
                
                if (!allowed) {
                    LOG.warn("Access denied: user={}, resource={}, action={}", 
                        userId, resource, action);
                }
            });
    }
    
    /**
     * Check role-based permission
     */
    private Uni<Boolean> checkRolePermission(
            Role role,
            String resource,
            String action) {
        
        // Direct permission check
        if (role.permissions().contains(resource + ":" + action)) {
            return Uni.createFrom().item(true);
        }
        
        // Wildcard permission check
        if (role.permissions().contains(resource + ":*")) {
            return Uni.createFrom().item(true);
        }
        
        if (role.permissions().contains("*:" + action)) {
            return Uni.createFrom().item(true);
        }
        
        return Uni.createFrom().item(false);
    }
    
    /**
     * Evaluate attribute-based policy
     */
    public Uni<Boolean> evaluatePolicy(
            PolicyEvaluationContext context) {
        
        return permissionEvaluator.evaluate(context);
    }
    
    /**
     * Grant permission to user
     */
    public Uni<Void> grantPermission(
            String userId,
            String tenantId,
            String resource,
            String action,
            String grantedBy) {
        
        return roleRepository.addPermission(userId, tenantId, resource, action)
            .invoke(() -> {
                auditLogger.logPermissionGrant(
                    userId, tenantId, resource, action, grantedBy
                );
                LOG.info("Permission granted: user={}, resource={}, action={}", 
                    userId, resource, action);
            });
    }
    
    /**
     * Revoke permission from user
     */
    public Uni<Void> revokePermission(
            String userId,
            String tenantId,
            String resource,
            String action,
            String revokedBy) {
        
        return roleRepository.removePermission(userId, tenantId, resource, action)
            .invoke(() -> {
                auditLogger.logPermissionRevoke(
                    userId, tenantId, resource, action, revokedBy
                );
                LOG.info("Permission revoked: user={}, resource={}, action={}", 
                    userId, resource, action);
            });
    }
}

// ==================== PERMISSION EVALUATOR ====================

@ApplicationScoped
public class PermissionEvaluator {
    
    private static final Logger LOG = LoggerFactory.getLogger(PermissionEvaluator.class);
    
    /**
     * Evaluate attribute-based policy
     */
    public Uni<Boolean> evaluate(PolicyEvaluationContext context) {
        // Example: Allow if user's department matches resource owner's department
        
        Map<String, Object> userAttrs = context.userAttributes();
        Map<String, Object> resourceAttrs = context.resourceAttributes();
        
        // Time-based access
        if (context.policy().contains("time_restriction")) {
            if (!isWithinAllowedTime(context.timestamp())) {
                return Uni.createFrom().item(false);
            }
        }
        
        // IP-based access
        if (context.policy().contains("ip_whitelist")) {
            if (!isAllowedIP(context.sourceIP(), resourceAttrs)) {
                return Uni.createFrom().item(false);
            }
        }
        
        // Attribute matching
        if (context.policy().contains("department_match")) {
            String userDept = (String) userAttrs.get("department");
            String resourceDept = (String) resourceAttrs.get("department");
            return Uni.createFrom().item(userDept != null && userDept.equals(resourceDept));
        }
        
        // Default allow
        return Uni.createFrom().item(true);
    }
    
    private boolean isWithinAllowedTime(Instant timestamp) {
        // Business hours: 9 AM - 5 PM
        int hour = timestamp.atZone(java.time.ZoneId.systemDefault()).getHour();
        return hour >= 9 && hour < 17;
    }
    
    private boolean isAllowedIP(String sourceIP, Map<String, Object> resourceAttrs) {
        @SuppressWarnings("unchecked")
        List<String> whitelist = (List<String>) resourceAttrs.get("ip_whitelist");
        return whitelist != null && whitelist.contains(sourceIP);
    }
}

// ==================== PII DETECTION & REDACTION ====================

@ApplicationScoped
public class PIIDetectionService {
    
    private static final Logger LOG = LoggerFactory.getLogger(PIIDetectionService.class);
    
    // Regex patterns for common PII
    private static final Pattern SSN_PATTERN = 
        Pattern.compile("\\b\\d{3}-\\d{2}-\\d{4}\\b");
    private static final Pattern EMAIL_PATTERN = 
        Pattern.compile("\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b");
    private static final Pattern PHONE_PATTERN = 
        Pattern.compile("\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b");
    private static final Pattern CREDIT_CARD_PATTERN = 
        Pattern.compile("\\b\\d{4}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}\\b");
    private static final Pattern IP_ADDRESS_PATTERN = 
        Pattern.compile("\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b");
    
    @ConfigProperty(name = "silat.security.pii.auto-redact", defaultValue = "true")
    boolean autoRedact;
    
    /**
     * Detect PII in text
     */
    public PIIDetectionResult detectPII(String text) {
        if (text == null || text.isEmpty()) {
            return new PIIDetectionResult(false, List.of(), text);
        }
        
        List<PIIMatch> matches = new ArrayList<>();
        
        // Detect SSN
        findMatches(text, SSN_PATTERN, PIIType.SSN, matches);
        
        // Detect Email
        findMatches(text, EMAIL_PATTERN, PIIType.EMAIL, matches);
        
        // Detect Phone
        findMatches(text, PHONE_PATTERN, PIIType.PHONE, matches);
        
        // Detect Credit Card
        findMatches(text, CREDIT_CARD_PATTERN, PIIType.CREDIT_CARD, matches);
        
        // Detect IP Address
        findMatches(text, IP_ADDRESS_PATTERN, PIIType.IP_ADDRESS, matches);
        
        boolean containsPII = !matches.isEmpty();
        
        if (containsPII) {
            LOG.warn("PII detected in text: {} instances", matches.size());
        }
        
        return new PIIDetectionResult(containsPII, matches, text);
    }
    
    /**
     * Redact PII from text
     */
    public String redactPII(String text) {
        if (text == null || text.isEmpty()) {
            return text;
        }
        
        String redacted = text;
        
        // Redact SSN
        redacted = SSN_PATTERN.matcher(redacted).replaceAll("XXX-XX-XXXX");
        
        // Redact Email (keep domain)
        redacted = EMAIL_PATTERN.matcher(redacted)
            .replaceAll(m -> "****@" + m.group().split("@")[1]);
        
        // Redact Phone
        redacted = PHONE_PATTERN.matcher(redacted).replaceAll("XXX-XXX-XXXX");
        
        // Redact Credit Card
        redacted = CREDIT_CARD_PATTERN.matcher(redacted)
            .replaceAll("XXXX-XXXX-XXXX-XXXX");
        
        // Redact IP Address
        redacted = IP_ADDRESS_PATTERN.matcher(redacted).replaceAll("XXX.XXX.XXX.XXX");
        
        return redacted;
    }
    
    /**
     * Process text with PII handling
     */
    public Uni<String> processText(String text, PIIHandlingPolicy policy) {
        return Uni.createFrom().item(() -> {
            PIIDetectionResult detection = detectPII(text);
            
            if (!detection.containsPII()) {
                return text;
            }
            
            return switch (policy) {
                case BLOCK -> throw new PIIViolationException(
                    "Text contains PII and policy is BLOCK");
                case REDACT -> redactPII(text);
                case WARN -> {
                    LOG.warn("Text contains PII: {}", detection.matches());
                    yield text;
                }
                case ALLOW -> text;
            };
        });
    }
    
    private void findMatches(
            String text,
            Pattern pattern,
            PIIType type,
            List<PIIMatch> matches) {
        
        var matcher = pattern.matcher(text);
        while (matcher.find()) {
            matches.add(new PIIMatch(
                type,
                matcher.group(),
                matcher.start(),
                matcher.end()
            ));
        }
    }
}

// ==================== AUDIT LOGGER ====================

@ApplicationScoped
public class AuditLogger {
    
    private static final Logger LOG = LoggerFactory.getLogger(AuditLogger.class);
    
    @Inject
    AuditEventRepository auditRepository;
    
    /**
     * Log access attempt
     */
    public void logAccessAttempt(
            String userId,
            String tenantId,
            String resource,
            String action,
            boolean allowed) {
        
        AuditEvent event = new AuditEvent(
            UUID.randomUUID().toString(),
            AuditEventType.ACCESS_ATTEMPT,
            userId,
            tenantId,
            resource,
            action,
            allowed ? "ALLOWED" : "DENIED",
            Map.of(),
            Instant.now()
        );
        
        auditRepository.save(event).subscribe().with(
            saved -> LOG.debug("Audit event logged: {}", event.eventId()),
            error -> LOG.error("Failed to log audit event", error)
        );
    }
    
    /**
     * Log permission grant
     */
    public void logPermissionGrant(
            String userId,
            String tenantId,
            String resource,
            String action,
            String grantedBy) {
        
        AuditEvent event = new AuditEvent(
            UUID.randomUUID().toString(),
            AuditEventType.PERMISSION_GRANTED,
            userId,
            tenantId,
            resource,
            action,
            "GRANTED",
            Map.of("grantedBy", grantedBy),
            Instant.now()
        );
        
        auditRepository.save(event).subscribe().with(
            saved -> {},
            error -> LOG.error("Failed to log audit event", error)
        );
    }
    
    /**
     * Log permission revoke
     */
    public void logPermissionRevoke(
            String userId,
            String tenantId,
            String resource,
            String action,
            String revokedBy) {
        
        AuditEvent event = new AuditEvent(
            UUID.randomUUID().toString(),
            AuditEventType.PERMISSION_REVOKED,
            userId,
            tenantId,
            resource,
            action,
            "REVOKED",
            Map.of("revokedBy", revokedBy),
            Instant.now()
        );
        
        auditRepository.save(event).subscribe().with(
            saved -> {},
            error -> LOG.error("Failed to log audit event", error)
        );
    }
    
    /**
     * Log data access
     */
    public void logDataAccess(
            String userId,
            String tenantId,
            String dataType,
            String dataId,
            String operation) {
        
        AuditEvent event = new AuditEvent(
            UUID.randomUUID().toString(),
            AuditEventType.DATA_ACCESS,
            userId,
            tenantId,
            dataType + ":" + dataId,
            operation,
            "ACCESSED",
            Map.of("dataType", dataType, "dataId", dataId),
            Instant.now()
        );
        
        auditRepository.save(event).subscribe().with(
            saved -> {},
            error -> LOG.error("Failed to log audit event", error)
        );
    }
    
    /**
     * Log security event
     */
    public void logSecurityEvent(
            String eventType,
            String userId,
            String tenantId,
            String description,
            Map<String, Object> details) {
        
        AuditEvent event = new AuditEvent(
            UUID.randomUUID().toString(),
            AuditEventType.SECURITY_EVENT,
            userId,
            tenantId,
            eventType,
            "SECURITY",
            description,
            details,
            Instant.now()
        );
        
        auditRepository.save(event).subscribe().with(
            saved -> LOG.warn("Security event: {}", eventType),
            error -> LOG.error("Failed to log security event", error)
        );
    }
    
    /**
     * Query audit trail
     */
    public Uni<List<AuditEvent>> queryAuditTrail(
            String tenantId,
            Instant startTime,
            Instant endTime,
            AuditEventType eventType) {
        
        return auditRepository.query(tenantId, startTime, endTime, eventType);
    }
}

// ==================== CONTENT SAFETY SERVICE ====================

@ApplicationScoped
public class ContentSafetyService {
    
    private static final Logger LOG = LoggerFactory.getLogger(ContentSafetyService.class);
    
    @Inject
    ToxicityDetector toxicityDetector;
    
    @Inject
    BiasDetector biasDetector;
    
    @Inject
    PromptInjectionDetector injectionDetector;
    
    @ConfigProperty(name = "silat.security.content.block-toxic", defaultValue = "true")
    boolean blockToxic;
    
    /**
     * Check content safety
     */
    public Uni<ContentSafetyResult> checkSafety(String text) {
        return Uni.combine().all()
            .unis(
                toxicityDetector.detect(text),
                biasDetector.detect(text),
                injectionDetector.detect(text)
            )
            .asTuple()
            .map(tuple -> {
                ToxicityScore toxicity = tuple.getItem1();
                BiasScore bias = tuple.getItem2();
                boolean isInjection = tuple.getItem3();
                
                boolean isSafe = !toxicity.isToxic() && 
                                !bias.isBiased() && 
                                !isInjection;
                
                List<String> violations = new ArrayList<>();
                if (toxicity.isToxic()) violations.add("TOXICITY");
                if (bias.isBiased()) violations.add("BIAS");
                if (isInjection) violations.add("PROMPT_INJECTION");
                
                if (!isSafe) {
                    LOG.warn("Content safety violation: {}", violations);
                }
                
                return new ContentSafetyResult(
                    isSafe,
                    violations,
                    toxicity,
                    bias
                );
            });
    }
    
    /**
     * Sanitize content
     */
    public Uni<String> sanitize(String text) {
        return checkSafety(text)
            .map(result -> {
                if (result.isSafe()) {
                    return text;
                }
                
                if (blockToxic && result.violations().contains("TOXICITY")) {
                    throw new ContentViolationException(
                        "Content blocked due to toxicity"
                    );
                }
                
                // Apply sanitization rules
                String sanitized = text;
                
                // Remove toxic patterns
                sanitized = toxicityDetector.sanitize(sanitized);
                
                // Remove biased language
                sanitized = biasDetector.sanitize(sanitized);
                
                return sanitized;
            });
    }
}

// ==================== TOXICITY DETECTOR ====================

@ApplicationScoped
public class ToxicityDetector {
    
    private static final Set<String> TOXIC_KEYWORDS = Set.of(
        "offensive", "toxic", "hate", "violent"
        // In production, use ML model or API
    );
    
    public Uni<ToxicityScore> detect(String text) {
        return Uni.createFrom().item(() -> {
            if (text == null) {
                return new ToxicityScore(0.0, false);
            }
            
            String lowerText = text.toLowerCase();
            long toxicCount = TOXIC_KEYWORDS.stream()
                .filter(lowerText::contains)
                .count();
            
            double score = Math.min(1.0, toxicCount * 0.3);
            boolean isToxic = score > 0.5;
            
            return new ToxicityScore(score, isToxic);
        });
    }
    
    public String sanitize(String text) {
        String sanitized = text;
        for (String keyword : TOXIC_KEYWORDS) {
            sanitized = sanitized.replaceAll("(?i)" + keyword, "***");
        }
        return sanitized;
    }
}

// ==================== BIAS DETECTOR ====================

@ApplicationScoped
public class BiasDetector {
    
    private static final Set<String> BIASED_TERMS = Set.of(
        // Gender bias, racial bias, etc.
        // In production, use sophisticated bias detection
    );
    
    public Uni<BiasScore> detect(String text) {
        return Uni.createFrom().item(() -> {
            // Simplified bias detection
            return new BiasScore(0.0, false, List.of());
        });
    }
    
    public String sanitize(String text) {
        return text; // Implement bias sanitization
    }
}

// ==================== PROMPT INJECTION DETECTOR ====================

@ApplicationScoped
public class PromptInjectionDetector {
    
    private static final List<Pattern> INJECTION_PATTERNS = List.of(
        Pattern.compile("(?i)ignore (previous|above) (instructions|prompt)"),
        Pattern.compile("(?i)system:"),
        Pattern.compile("(?i)\\[SYSTEM\\]"),
        Pattern.compile("(?i)forget (everything|all instructions)")
    );
    
    public Uni<Boolean> detect(String text) {
        return Uni.createFrom().item(() -> {
            if (text == null) return false;
            
            return INJECTION_PATTERNS.stream()
                .anyMatch(pattern -> pattern.matcher(text).find());
        });
    }
}

// ==================== SUPPORTING CLASSES ====================

record Role(
    String roleId,
    String roleName,
    Set<String> permissions,
    String tenantId
) {}

record PolicyEvaluationContext(
    String userId,
    String tenantId,
    String resource,
    String action,
    String policy,
    Map<String, Object> userAttributes,
    Map<String, Object> resourceAttributes,
    String sourceIP,
    Instant timestamp
) {}

record PIIDetectionResult(
    boolean containsPII,
    List<PIIMatch> matches,
    String originalText
) {}

record PIIMatch(
    PIIType type,
    String value,
    int startIndex,
    int endIndex
) {}

enum PIIType {
    SSN, EMAIL, PHONE, CREDIT_CARD, IP_ADDRESS, 
    NAME, ADDRESS, DATE_OF_BIRTH
}

enum PIIHandlingPolicy {
    BLOCK,   // Block request if PII detected
    REDACT,  // Automatically redact PII
    WARN,    // Log warning but allow
    ALLOW    // Allow PII (for authorized users)
}

record AuditEvent(
    String eventId,
    AuditEventType eventType,
    String userId,
    String tenantId,
    String resource,
    String action,
    String result,
    Map<String, Object> details,
    Instant timestamp
) {}

enum AuditEventType {
    ACCESS_ATTEMPT,
    PERMISSION_GRANTED,
    PERMISSION_REVOKED,
    DATA_ACCESS,
    DATA_MODIFICATION,
    SECURITY_EVENT,
    COMPLIANCE_EVENT
}

record ContentSafetyResult(
    boolean isSafe,
    List<String> violations,
    ToxicityScore toxicity,
    BiasScore bias
) {}

record ToxicityScore(double score, boolean isToxic) {}

record BiasScore(
    double score,
    boolean isBiased,
    List<String> biasTypes
) {}

class PIIViolationException extends RuntimeException {
    public PIIViolationException(String message) { super(message); }
}

class ContentViolationException extends RuntimeException {
    public ContentViolationException(String message) { super(message); }
}

// ==================== REPOSITORY INTERFACES ====================

interface RoleRepository {
    Uni<List<Role>> getUserRoles(String userId, String tenantId);
    Uni<Void> addPermission(String userId, String tenantId, String resource, String action);
    Uni<Void> removePermission(String userId, String tenantId, String resource, String action);
}

interface AuditEventRepository {
    Uni<AuditEvent> save(AuditEvent event);
    Uni<List<AuditEvent>> query(String tenantId, Instant startTime, Instant endTime, AuditEventType eventType);
}