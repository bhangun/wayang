package tech.kayys.gamelan.mcp.parser;

import io.quarkus.hibernate.reactive.panache.Panache;
import io.smallrye.mutiny.Uni;
import io.swagger.v3.oas.models.*;
import io.swagger.v3.oas.models.media.*;
import io.swagger.v3.oas.models.parameters.Parameter;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.parser.OpenAPIV3Parser;
import io.swagger.v3.parser.core.models.ParseOptions;
import io.swagger.v3.parser.core.models.SwaggerParseResult;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import tech.kayys.gamelan.mcp.domain.*;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * ============================================================================
 * OPENAPI PARSER & TOOL GENERATOR
 * ============================================================================
 * 
 * Transforms OpenAPI specifications into executable MCP tools.
 * 
 * Pipeline:
 * 1. Parse OpenAPI spec (URL, file, or raw)
 * 2. Validate spec structure
 * 3. Extract operations â†’ MCP tools
 * 4. Generate input/output schemas
 * 5. Configure HTTP execution
 * 6. Map authentication
 * 7. Apply guardrails
 * 8. Persist to registry
 */
@ApplicationScoped
public class OpenApiToolGenerator {
    
    private static final Logger LOG = LoggerFactory.getLogger(OpenApiToolGenerator.class);
    
    @Inject
    OpenApiParser parser;
    
    @Inject
    SchemaConverter schemaConverter;
    
    @Inject
    ToolGuardrailGenerator guardrailGenerator;
    
    @Inject
    AuthProfileMapper authMapper;
    
    @Inject
    ToolCapabilityAnalyzer capabilityAnalyzer;
    
    /**
     * Generate MCP tools from OpenAPI source
     */
    public Uni<ToolGenerationResult> generateTools(GenerateToolsRequest request) {
        LOG.info("Generating tools from OpenAPI source: {} (tenant: {})", 
            request.namespace(), request.tenantId());
        
        return Panache.withTransaction(() ->
            // Parse OpenAPI spec
            parser.parse(request)
                .flatMap(parseResult -> {
                    if (!parseResult.isValid()) {
                        return Uni.createFrom().failure(
                            new OpenApiParseException("Invalid OpenAPI spec: " + 
                                parseResult.errors()));
                    }
                    
                    // Create source record
                    return createOpenApiSource(request, parseResult)
                        .flatMap(source ->
                            // Generate tools from operations
                            generateToolsFromSpec(source, parseResult.openApi(), request)
                                .flatMap(tools ->
                                    // Persist tools
                                    persistTools(tools)
                                        .map(persisted -> 
                                            new ToolGenerationResult(
                                                source.getSourceId(),
                                                source.getNamespace(),
                                                persisted.size(),
                                                persisted.stream()
                                                    .map(McpTool::getToolId)
                                                    .collect(Collectors.toList()),
                                                List.of()
                                            )
                                        )
                                )
                        );
                })
        );
    }
    
    /**
     * Create OpenAPI source record
     */
    private Uni<OpenApiSource> createOpenApiSource(
            GenerateToolsRequest request,
            OpenApiParseResult parseResult) {
        
        return Uni.createFrom().item(() -> {
            OpenApiSource source = new OpenApiSource();
            source.setSourceId(UUID.randomUUID());
            source.setTenantId(request.tenantId());
            source.setNamespace(request.namespace());
            source.setDisplayName(parseResult.openApi().getInfo().getTitle());
            source.setSourceType(request.sourceType());
            source.setSourceLocation(request.source());
            source.setSpecContent(request.sourceType() == SourceType.RAW ? 
                request.source() : null);
            source.setSpecVersion(parseResult.openApi().getOpenapi());
            source.setSpecHash(calculateHash(parseResult.rawSpec()));
            source.setDefaultAuthProfileId(request.authProfileId());
            source.setStatus(SourceStatus.ACTIVE);
            source.setCreatedAt(Instant.now());
            source.setUpdatedAt(Instant.now());
            source.setCreatedBy(request.userId());
            
            return source.persist();
        }).flatMap(v -> (Uni<OpenApiSource>) v);
    }
    
    /**
     * Generate tools from OpenAPI operations
     */
    private Uni<List<McpTool>> generateToolsFromSpec(
            OpenApiSource source,
            OpenAPI openApi,
            GenerateToolsRequest request) {
        
        return Uni.createFrom().item(() -> {
            List<McpTool> tools = new ArrayList<>();
            
            // Get base URL
            String baseUrl = extractBaseUrl(openApi);
            
            // Process each path and operation
            if (openApi.getPaths() != null) {
                openApi.getPaths().forEach((path, pathItem) -> {
                    processPathItem(
                        source,
                        openApi,
                        baseUrl,
                        path,
                        pathItem,
                        request,
                        tools
                    );
                });
            }
            
            LOG.info("Generated {} tools from OpenAPI spec", tools.size());
            return tools;
        });
    }
    
    /**
     * Process a single path item (with all HTTP methods)
     */
    private void processPathItem(
            OpenApiSource source,
            OpenAPI openApi,
            String baseUrl,
            String path,
            PathItem pathItem,
            GenerateToolsRequest request,
            List<McpTool> tools) {
        
        // Process each HTTP method
        Map<PathItem.HttpMethod, Operation> operations = pathItem.readOperationsMap();
        
        operations.forEach((httpMethod, operation) -> {
            try {
                McpTool tool = createToolFromOperation(
                    source,
                    openApi,
                    baseUrl,
                    path,
                    httpMethod,
                    operation,
                    request
                );
                tools.add(tool);
            } catch (Exception e) {
                LOG.error("Failed to create tool from operation: {} {}", 
                    httpMethod, path, e);
            }
        });
    }
    
    /**
     * Create MCP tool from OpenAPI operation
     */
    private McpTool createToolFromOperation(
            OpenApiSource source,
            OpenAPI openApi,
            String baseUrl,
            String path,
            PathItem.HttpMethod httpMethod,
            Operation operation,
            GenerateToolsRequest request) {
        
        McpTool tool = new McpTool();
        
        // Identity
        String operationId = operation.getOperationId() != null ? 
            operation.getOperationId() : 
            generateOperationId(httpMethod, path);
        
        tool.setToolId(request.namespace() + "." + operationId);
        tool.setTenantId(request.tenantId());
        tool.setNamespace(request.namespace());
        tool.setName(operationId);
        tool.setOperationId(operationId);
        
        // Description - use from OpenAPI or generate
        String description = extractDescription(operation);
        tool.setDescription(description);
        
        // Capabilities - extract from tags or description
        Set<String> capabilities = extractCapabilities(operation, description);
        tool.setCapabilities(capabilities);
        
        // Tags
        Set<String> tags = operation.getTags() != null ? 
            new HashSet<>(operation.getTags()) : new HashSet<>();
        tool.setTags(tags);
        
        // Capability level - analyze operation safety
        CapabilityLevel capabilityLevel = capabilityAnalyzer.analyze(
            httpMethod, operation, path);
        tool.setCapabilityLevel(capabilityLevel);
        tool.setReadOnly(httpMethod == PathItem.HttpMethod.GET);
        
        // Input schema
        Map<String, Object> inputSchema = generateInputSchema(
            openApi, operation, path);
        tool.setInputSchema(inputSchema);
        
        // Output schema
        Map<String, Object> outputSchema = generateOutputSchema(
            openApi, operation);
        tool.setOutputSchema(outputSchema);
        
        // HTTP execution config
        HttpExecutionConfig execConfig = createExecutionConfig(
            baseUrl, path, httpMethod, operation, openApi);
        tool.setExecutionConfig(execConfig);
        
        // Auth profile
        tool.setAuthProfileId(request.authProfileId());
        
        // Guardrails
        ToolGuardrails guardrails = guardrailGenerator.generate(
            httpMethod, operation, request.guardrailsConfig());
        tool.setGuardrails(guardrails);
        
        // Metadata
        tool.setSource(source);
        tool.setCreatedAt(Instant.now());
        tool.setUpdatedAt(Instant.now());
        tool.setCreatedBy(request.userId());
        tool.setEnabled(true);
        
        // Metrics
        tool.setMetrics(new ToolMetrics());
        
        return tool;
    }
    
    /**
     * Generate input schema from parameters and request body
     */
    private Map<String, Object> generateInputSchema(
            OpenAPI openApi,
            Operation operation,
            String path) {
        
        Map<String, Object> schema = new HashMap<>();
        schema.put("type", "object");
        
        Map<String, Object> properties = new HashMap<>();
        List<String> required = new ArrayList<>();
        
        // Path parameters
        if (operation.getParameters() != null) {
            for (Parameter param : operation.getParameters()) {
                if (param.getIn().equals("path") || 
                    param.getIn().equals("query") || 
                    param.getIn().equals("header")) {
                    
                    Map<String, Object> paramSchema = 
                        schemaConverter.convert(param.getSchema());
                    paramSchema.put("description", param.getDescription());
                    properties.put(param.getName(), paramSchema);
                    
                    if (Boolean.TRUE.equals(param.getRequired())) {
                        required.add(param.getName());
                    }
                }
            }
        }
        
        // Request body
        if (operation.getRequestBody() != null) {
            Content content = operation.getRequestBody().getContent();
            if (content != null) {
                MediaType mediaType = content.get("application/json");
                if (mediaType != null && mediaType.getSchema() != null) {
                    Map<String, Object> bodySchema = 
                        schemaConverter.convert(mediaType.getSchema());
                    
                    // Merge body schema properties
                    if (bodySchema.get("properties") instanceof Map) {
                        @SuppressWarnings("unchecked")
                        Map<String, Object> bodyProps = 
                            (Map<String, Object>) bodySchema.get("properties");
                        properties.putAll(bodyProps);
                        
                        // Add required fields from body
                        if (bodySchema.get("required") instanceof List) {
                            @SuppressWarnings("unchecked")
                            List<String> bodyRequired = 
                                (List<String>) bodySchema.get("required");
                            required.addAll(bodyRequired);
                        }
                    }
                }
            }
        }
        
        schema.put("properties", properties);
        if (!required.isEmpty()) {
            schema.put("required", required);
        }
        
        return schema;
    }
    
    /**
     * Generate output schema from responses
     */
    private Map<String, Object> generateOutputSchema(
            OpenAPI openApi,
            Operation operation) {
        
        if (operation.getResponses() == null) {
            return Map.of("type", "object");
        }
        
        // Use 200/201 response schema
        ApiResponse successResponse = operation.getResponses().get("200");
        if (successResponse == null) {
            successResponse = operation.getResponses().get("201");
        }
        
        if (successResponse != null && successResponse.getContent() != null) {
            MediaType mediaType = successResponse.getContent().get("application/json");
            if (mediaType != null && mediaType.getSchema() != null) {
                return schemaConverter.convert(mediaType.getSchema());
            }
        }
        
        return Map.of("type", "object");
    }
    
    /**
     * Create HTTP execution configuration
     */
    private HttpExecutionConfig createExecutionConfig(
            String baseUrl,
            String path,
            PathItem.HttpMethod httpMethod,
            Operation operation,
            OpenAPI openApi) {
        
        HttpExecutionConfig config = new HttpExecutionConfig();
        
        // HTTP method
        config.setMethod(HttpMethod.valueOf(httpMethod.name()));
        config.setBaseUrl(baseUrl);
        config.setPath(path);
        
        // Parameters
        List<ParameterMapping> parameters = new ArrayList<>();
        if (operation.getParameters() != null) {
            for (Parameter param : operation.getParameters()) {
                ParameterMapping mapping = new ParameterMapping();
                mapping.setName(param.getName());
                mapping.setMappedName(param.getName());
                mapping.setLocation(ParameterLocation.valueOf(
                    param.getIn().toUpperCase()));
                mapping.setRequired(Boolean.TRUE.equals(param.getRequired()));
                mapping.setDescription(param.getDescription());
                parameters.add(mapping);
            }
        }
        config.setParameters(parameters);
        
        // Headers
        Map<String, String> headers = new HashMap<>();
        headers.put("User-Agent", "Gamelan-MCP/1.0");
        config.setHeaders(headers);
        
        // Content type
        if (operation.getRequestBody() != null && 
            operation.getRequestBody().getContent() != null) {
            String contentType = operation.getRequestBody().getContent()
                .keySet().stream().findFirst().orElse("application/json");
            config.setContentType(contentType);
        }
        
        // Retry config
        RetryConfig retryConfig = new RetryConfig();
        config.setRetryConfig(retryConfig);
        
        return config;
    }
    
    /**
     * Extract description from operation (use docs as capabilities)
     */
    private String extractDescription(Operation operation) {
        if (operation.getSummary() != null) {
            return operation.getSummary();
        }
        if (operation.getDescription() != null) {
            return operation.getDescription();
        }
        if (operation.getOperationId() != null) {
            return humanizeOperationId(operation.getOperationId());
        }
        return "No description available";
    }
    
    /**
     * Extract capabilities from operation
     * Use description/summary as capability if available
     */
    private Set<String> extractCapabilities(Operation operation, String description) {
        Set<String> capabilities = new HashSet<>();
        
        // Use summary as primary capability
        if (operation.getSummary() != null) {
            capabilities.add(operation.getSummary().toLowerCase());
        }
        
        // Add tags as capabilities
        if (operation.getTags() != null) {
            capabilities.addAll(operation.getTags().stream()
                .map(String::toLowerCase)
                .collect(Collectors.toSet()));
        }
        
        // If no capabilities found, use operation ID
        if (capabilities.isEmpty() && operation.getOperationId() != null) {
            capabilities.add(humanizeOperationId(operation.getOperationId()));
        }
        
        return capabilities;
    }
    
    /**
     * Extract base URL from OpenAPI servers
     */
    private String extractBaseUrl(OpenAPI openApi) {
        if (openApi.getServers() != null && !openApi.getServers().isEmpty()) {
            return openApi.getServers().get(0).getUrl();
        }
        return "https://api.example.com";  // Placeholder
    }
    
    /**
     * Generate operation ID if not provided
     */
    private String generateOperationId(PathItem.HttpMethod method, String path) {
        String cleaned = path.replaceAll("[^a-zA-Z0-9]", "_");
        return method.name().toLowerCase() + cleaned;
    }
    
    /**
     * Humanize operation ID for display
     */
    private String humanizeOperationId(String operationId) {
        return operationId
            .replaceAll("([a-z])([A-Z])", "$1 $2")
            .replaceAll("_", " ")
            .toLowerCase();
    }
    
    /**
     * Calculate hash of spec for change detection
     */
    private String calculateHash(String content) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(content.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            return UUID.randomUUID().toString();
        }
    }
    
    /**
     * Persist generated tools
     */
    private Uni<List<McpTool>> persistTools(List<McpTool> tools) {
        return Uni.join().all(
            tools.stream()
                .map(tool -> tool.<McpTool>persist())
                .collect(Collectors.toList())
        ).andFailFast();
    }
}

// ==================== OPENAPI PARSER ====================

/**
 * OpenAPI specification parser
 */
@ApplicationScoped
class OpenApiParser {
    
    private static final Logger LOG = LoggerFactory.getLogger(OpenApiParser.class);
    
    @Inject
    io.vertx.mutiny.core.Vertx vertx;
    
    /**
     * Parse OpenAPI from various sources
     */
    public Uni<OpenApiParseResult> parse(GenerateToolsRequest request) {
        return switch (request.sourceType()) {
            case URL -> parseFromUrl(request.source());
            case FILE -> parseFromFile(request.source());
            case RAW -> parseFromString(request.source());
            case GIT -> parseFromGit(request.source());
        };
    }
    
    /**
     * Parse from URL
     */
    private Uni<OpenApiParseResult> parseFromUrl(String url) {
        LOG.info("Parsing OpenAPI from URL: {}", url);
        
        return vertx.createHttpClient()
            .request(io.vertx.core.http.HttpMethod.GET, url)
            .flatMap(request -> request.send()
                .flatMap(response -> {
                    if (response.statusCode() != 200) {
                        return Uni.createFrom().failure(
                            new OpenApiParseException(
                                "Failed to fetch OpenAPI spec: HTTP " + 
                                response.statusCode()));
                    }
                    return response.body();
                }))
            .map(buffer -> buffer.toString())
            .map(this::parseSpec);
    }
    
    /**
     * Parse from file
     */
    private Uni<OpenApiParseResult> parseFromFile(String filePath) {
        return vertx.fileSystem().readFile(filePath)
            .map(buffer -> buffer.toString())
            .map(this::parseSpec);
    }
    
    /**
     * Parse from raw string
     */
    private Uni<OpenApiParseResult> parseFromString(String spec) {
        return Uni.createFrom().item(parseSpec(spec));
    }
    
    /**
     * Parse from Git repository
     */
    private Uni<OpenApiParseResult> parseFromGit(String gitRef) {
        // TODO: Implement Git integration
        return Uni.createFrom().failure(
            new UnsupportedOperationException("Git source not yet implemented"));
    }
    
    /**
     * Parse OpenAPI spec string
     */
    private OpenApiParseResult parseSpec(String spec) {
        ParseOptions options = new ParseOptions();
        options.setResolve(true);
        options.setResolveFully(true);
        
        SwaggerParseResult result = new OpenAPIV3Parser()
            .readContents(spec, null, options);
        
        if (result.getOpenAPI() == null) {
            return new OpenApiParseResult(
                null,
                spec,
                false,
                result.getMessages()
            );
        }
        
        return new OpenApiParseResult(
            result.getOpenAPI(),
            spec,
            result.getMessages() == null || result.getMessages().isEmpty(),
            result.getMessages() != null ? result.getMessages() : List.of()
        );
    }
}

// ==================== SCHEMA CONVERTER ====================

/**
 * Convert OpenAPI schema to JSON Schema
 */
@ApplicationScoped
class SchemaConverter {
    
    /**
     * Convert OpenAPI schema to JSON Schema format
     */
    public Map<String, Object> convert(Schema<?> schema) {
        if (schema == null) {
            return Map.of("type", "object");
        }
        
        Map<String, Object> jsonSchema = new HashMap<>();
        
        // Type
        if (schema.getType() != null) {
            jsonSchema.put("type", schema.getType());
        }
        
        // Format
        if (schema.getFormat() != null) {
            jsonSchema.put("format", schema.getFormat());
        }
        
        // Description
        if (schema.getDescription() != null) {
            jsonSchema.put("description", schema.getDescription());
        }
        
        // Enum
        if (schema.getEnum() != null) {
            jsonSchema.put("enum", schema.getEnum());
        }
        
        // Properties (for object types)
        if (schema.getProperties() != null) {
            Map<String, Object> properties = new HashMap<>();
            schema.getProperties().forEach((name, propSchema) -> {
                properties.put(name, convert((Schema<?>) propSchema));
            });
            jsonSchema.put("properties", properties);
        }
        
        // Required
        if (schema.getRequired() != null) {
            jsonSchema.put("required", schema.getRequired());
        }
        
        // Items (for array types)
        if (schema.getItems() != null) {
            jsonSchema.put("items", convert(schema.getItems()));
        }
        
        // Validation constraints
        if (schema.getMinimum() != null) {
            jsonSchema.put("minimum", schema.getMinimum());
        }
        if (schema.getMaximum() != null) {
            jsonSchema.put("maximum", schema.getMaximum());
        }
        if (schema.getMinLength() != null) {
            jsonSchema.put("minLength", schema.getMinLength());
        }
        if (schema.getMaxLength() != null) {
            jsonSchema.put("maxLength", schema.getMaxLength());
        }
        if (schema.getPattern() != null) {
            jsonSchema.put("pattern", schema.getPattern());
        }
        
        return jsonSchema;
    }
}

// ==================== SUPPORTING CLASSES ====================

record GenerateToolsRequest(
    String tenantId,
    String namespace,
    SourceType sourceType,
    String source,
    String authProfileId,
    String userId,
    Map<String, Object> guardrailsConfig
) {}

record OpenApiParseResult(
    OpenAPI openApi,
    String rawSpec,
    boolean isValid,
    List<String> errors
) {}

record ToolGenerationResult(
    UUID sourceId,
    String namespace,
    int toolsGenerated,
    List<String> toolIds,
    List<String> warnings
) {}

class OpenApiParseException extends RuntimeException {
    public OpenApiParseException(String message) {
        super(message);
    }
}

package tech.kayys.gamelan.mcp.api;

import io.quarkus.security.Authenticated;
import io.smallrye.mutiny.Uni;
import jakarta.inject.Inject;
import jakarta.validation.Valid;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.*;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.tags.Tag;
import org.jboss.resteasy.reactive.RestResponse;
import tech.kayys.gamelan.mcp.domain.*;
import tech.kayys.gamelan.mcp.parser.OpenApiToolGenerator;
import tech.kayys.gamelan.mcp.parser.GenerateToolsRequest;
import tech.kayys.gamelan.mcp.runtime.McpToolExecutor;
import tech.kayys.gamelan.mcp.runtime.ToolExecutionRequest;

import java.util.*;

/**
 * ============================================================================
 * MCP SERVER REST API
 * ============================================================================
 * 
 * RESTful API for MCP tool management and execution.
 * 
 * Endpoints:
 * - POST /api/v1/mcp/tools/openapi - Generate tools from OpenAPI
 * - GET /api/v1/mcp/tools - List tools
 * - GET /api/v1/mcp/tools/{toolId} - Get tool details
 * - POST /api/v1/mcp/tools/{toolId}/execute - Execute tool
 * - POST /api/v1/mcp/auth-profiles - Create auth profile
 */

// ==================== TOOL GENERATION API ====================

@Path("/api/v1/mcp/tools")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Authenticated
@Tag(name = "MCP Tools", description = "MCP tool management")
public class McpToolResource {
    
    @Inject
    OpenApiToolGenerator toolGenerator;
    
    @Inject
    McpToolExecutor toolExecutor;
    
    @Inject
    tech.kayys.gamelan.api.security.TenantContext tenantContext;
    
    /**
     * Generate tools from OpenAPI specification
     */
    @POST
    @Path("/openapi")
    @Operation(summary = "Generate MCP tools from OpenAPI spec")
    public Uni<RestResponse<ToolGenerationResponse>> generateFromOpenApi(
            @Valid OpenApiToolRequest request) {
        
        String tenantId = tenantContext.getCurrentTenantId().value();
        
        GenerateToolsRequest genRequest = new GenerateToolsRequest(
            tenantId,
            request.namespace(),
            request.sourceType(),
            request.source(),
            request.authProfileId(),
            "current-user",  // From security context
            request.guardrailsConfig() != null ? 
                request.guardrailsConfig() : Map.of()
        );
        
        return toolGenerator.generateTools(genRequest)
            .map(result -> RestResponse.ok(
                new ToolGenerationResponse(
                    result.sourceId().toString(),
                    result.namespace(),
                    result.toolsGenerated(),
                    result.toolIds(),
                    result.warnings()
                )
            ))
            .onFailure().recoverWithItem(error ->
                RestResponse.status(
                    RestResponse.Status.BAD_REQUEST,
                    new ToolGenerationResponse(
                        null,
                        request.namespace(),
                        0,
                        List.of(),
                        List.of(error.getMessage())
                    )
                )
            );
    }
    
    /**
     * List tools for tenant
     */
    @GET
    @Operation(summary = "List MCP tools")
    public Uni<List<ToolMetadataResponse>> listTools(
            @QueryParam("namespace") String namespace,
            @QueryParam("capability") String capability,
            @QueryParam("tag") String tag,
            @QueryParam("enabled") Boolean enabled,
            @QueryParam("readOnly") Boolean readOnly) {
        
        String tenantId = tenantContext.getCurrentTenantId().value();
        
        String query = "tenantId = ?1";
        List<Object> params = new ArrayList<>();
        params.add(tenantId);
        
        if (namespace != null) {
            query += " and namespace = ?" + (params.size() + 1);
            params.add(namespace);
        }
        if (enabled != null) {
            query += " and enabled = ?" + (params.size() + 1);
            params.add(enabled);
        }
        if (readOnly != null) {
            query += " and readOnly = ?" + (params.size() + 1);
            params.add(readOnly);
        }
        
        return McpTool.list(query, params.toArray())
            .map(tools -> tools.stream()
                .map(t -> {
                    McpTool tool = (McpTool) t;
                    return new ToolMetadataResponse(
                        tool.getToolId(),
                        tool.getName(),
                        tool.getDescription(),
                        tool.getCapabilities(),
                        tool.getCapabilityLevel().name(),
                        tool.isReadOnly(),
                        tool.getTags()
                    );
                })
                .toList()
            );
    }
    
    /**
     * Get tool details
     */
    @GET
    @Path("/{toolId}")
    @Operation(summary = "Get tool details")
    public Uni<RestResponse<ToolDetailResponse>> getTool(
            @PathParam("toolId") String toolId) {
        
        String tenantId = tenantContext.getCurrentTenantId().value();
        
        return McpTool.<McpTool>find(
            "toolId = ?1 and tenantId = ?2",
            toolId, tenantId
        ).firstResult()
        .map(tool -> {
            if (tool == null) {
                return RestResponse.notFound();
            }
            
            return RestResponse.ok(new ToolDetailResponse(
                tool.getToolId(),
                tool.getName(),
                tool.getDescription(),
                tool.getInputSchema(),
                tool.getOutputSchema(),
                tool.getCapabilities(),
                tool.getCapabilityLevel().name(),
                tool.isEnabled(),
                tool.isReadOnly(),
                tool.getMetrics() != null ? 
                    tool.getMetrics().getTotalInvocations() : 0L
            ));
        });
    }
    
    /**
     * Execute tool
     */
    @POST
    @Path("/{toolId}/execute")
    @Operation(summary = "Execute MCP tool")
    public Uni<RestResponse<ToolExecutionResponse>> executeTool(
            @PathParam("toolId") String toolId,
            @Valid ToolExecuteRequest request) {
        
        String tenantId = tenantContext.getCurrentTenantId().value();
        
        ToolExecutionRequest execRequest = new ToolExecutionRequest(
            toolId,
            tenantId,
            request.arguments(),
            request.context() != null ? request.context() : Map.of(),
            "current-user",
            null,  // workflow run ID
            null   // agent ID
        );
        
        return toolExecutor.execute(execRequest)
            .map(result -> {
                if (result.status() == InvocationStatus.SUCCESS) {
                    return RestResponse.ok(new ToolExecutionResponse(
                        "success",
                        result.output(),
                        null,
                        result.executionTimeMs()
                    ));
                } else {
                    return RestResponse.status(
                        RestResponse.Status.BAD_REQUEST,
                        new ToolExecutionResponse(
                            "failure",
                            Map.of(),
                            result.errorMessage(),
                            result.executionTimeMs()
                        )
                    );
                }
            });
    }
    
    /**
     * Update tool configuration
     */
    @PUT
    @Path("/{toolId}")
    @Operation(summary = "Update tool configuration")
    public Uni<RestResponse<Void>> updateTool(
            @PathParam("toolId") String toolId,
            @Valid ToolUpdateRequest request) {
        
        String tenantId = tenantContext.getCurrentTenantId().value();
        
        return McpTool.<McpTool>find(
            "toolId = ?1 and tenantId = ?2",
            toolId, tenantId
        ).firstResult()
        .flatMap(tool -> {
            if (tool == null) {
                return Uni.createFrom().item(RestResponse.notFound());
            }
            
            if (request.enabled() != null) {
                tool.setEnabled(request.enabled());
            }
            if (request.description() != null) {
                tool.setDescription(request.description());
            }
            if (request.tags() != null) {
                tool.setTags(request.tags());
            }
            
            return tool.persistAndFlush()
                .map(v -> RestResponse.ok());
        });
    }
    
    /**
     * Delete tool
     */
    @DELETE
    @Path("/{toolId}")
    @Operation(summary = "Delete tool")
    public Uni<RestResponse<Void>> deleteTool(
            @PathParam("toolId") String toolId) {
        
        String tenantId = tenantContext.getCurrentTenantId().value();
        
        return McpTool.delete(
            "toolId = ?1 and tenantId = ?2",
            toolId, tenantId
        ).map(deleted -> deleted > 0 ? 
            RestResponse.ok() : 
            RestResponse.notFound()
        );
    }
}

// ==================== AUTH PROFILE API ====================

@Path("/api/v1/mcp/auth-profiles")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
@Authenticated
@Tag(name = "MCP Auth Profiles", description = "Authentication profile management")
public class AuthProfileResource {
    
    @Inject
    tech.kayys.gamelan.api.security.TenantContext tenantContext;
    
    @Inject
    tech.kayys.gamelan.mcp.security.VaultSecretManager vaultManager;
    
    /**
     * Create auth profile
     */
    @POST
    @Operation(summary = "Create authentication profile")
    public Uni<RestResponse<AuthProfileResponse>> createAuthProfile(
            @Valid CreateAuthProfileRequest request) {
        
        String tenantId = tenantContext.getCurrentTenantId().value();
        
        return io.quarkus.hibernate.reactive.panache.Panache.withTransaction(() -> {
            AuthProfile profile = new AuthProfile();
            profile.setProfileId(UUID.randomUUID().toString());
            profile.setTenantId(tenantId);
            profile.setProfileName(request.profileName());
            profile.setAuthType(AuthType.valueOf(request.authType()));
            profile.setDescription(request.description());
            
            // Configure auth
            AuthConfig config = new AuthConfig();
            config.setLocation(AuthLocation.valueOf(request.location()));
            config.setParamName(request.paramName());
            config.setScheme(request.scheme());
            profile.setConfig(config);
            
            // Store secret in Vault
            String vaultPath = "gamelan/mcp/" + tenantId + "/" + profile.getProfileId();
            
            return vaultManager.storeSecret(vaultPath, request.secretValue())
                .flatMap(v -> {
                    profile.setVaultPath(vaultPath);
                    profile.setSecretKey("auth_secret");
                    profile.setEnabled(true);
                    profile.setCreatedAt(java.time.Instant.now());
                    profile.setUpdatedAt(java.time.Instant.now());
                    
                    return profile.persist();
                })
                .map(p -> RestResponse.status(
                    RestResponse.Status.CREATED,
                    new AuthProfileResponse(
                        profile.getProfileId(),
                        profile.getProfileName(),
                        profile.getAuthType().name(),
                        profile.isEnabled()
                    )
                ));
        });
    }
    
    /**
     * List auth profiles
     */
    @GET
    @Operation(summary = "List authentication profiles")
    public Uni<List<AuthProfileResponse>> listAuthProfiles() {
        String tenantId = tenantContext.getCurrentTenantId().value();
        
        return AuthProfile.list("tenantId = ?1 and enabled = true", tenantId)
            .map(profiles -> profiles.stream()
                .map(p -> {
                    AuthProfile profile = (AuthProfile) p;
                    return new AuthProfileResponse(
                        profile.getProfileId(),
                        profile.getProfileName(),
                        profile.getAuthType().name(),
                        profile.isEnabled()
                    );
                })
                .toList()
            );
    }
}

// ==================== REQUEST/RESPONSE MODELS ====================

record OpenApiToolRequest(
    String namespace,
    SourceType sourceType,
    String source,
    String authProfileId,
    Map<String, Object> guardrailsConfig
) {}

record ToolGenerationResponse(
    String sourceId,
    String namespace,
    int toolsGenerated,
    List<String> toolIds,
    List<String> warnings
) {}

record ToolMetadataResponse(
    String toolId,
    String name,
    String description,
    Set<String> capabilities,
    String capabilityLevel,
    boolean readOnly,
    Set<String> tags
) {}

record ToolDetailResponse(
    String toolId,
    String name,
    String description,
    Map<String, Object> inputSchema,
    Map<String, Object> outputSchema,
    Set<String> capabilities,
    String capabilityLevel,
    boolean enabled,
    boolean readOnly,
    long totalInvocations
) {}

record ToolExecuteRequest(
    Map<String, Object> arguments,
    Map<String, Object> context
) {}

record ToolExecutionResponse(
    String status,
    Map<String, Object> output,
    String error,
    long executionTimeMs
) {}

record ToolUpdateRequest(
    Boolean enabled,
    String description,
    Set<String> tags
) {}

record CreateAuthProfileRequest(
    String profileName,
    String authType,
    String location,
    String paramName,
    String scheme,
    String secretValue,
    String description
) {}

record AuthProfileResponse(
    String profileId,
    String profileName,
    String authType,
    boolean enabled
) {}

// ==================== SECURITY COMPONENTS ====================

package tech.kayys.gamelan.mcp.security;

import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

/**
 * Auth injector - Injects authentication into HTTP requests
 */
@ApplicationScoped
public class AuthInjector {
    
    private static final Logger LOG = LoggerFactory.getLogger(AuthInjector.class);
    
    @jakarta.inject.Inject
    VaultSecretManager vaultManager;
    
    public Uni<tech.kayys.gamelan.mcp.runtime.HttpRequestContext> injectAuth(
            tech.kayys.gamelan.mcp.runtime.HttpRequestContext request,
            String authProfileId) {
        
        if (authProfileId == null) {
            return Uni.createFrom().item(request);
        }
        
        return tech.kayys.gamelan.mcp.domain.AuthProfile.<tech.kayys.gamelan.mcp.domain.AuthProfile>findById(authProfileId)
            .flatMap(profile -> {
                if (profile == null || !profile.isEnabled()) {
                    return Uni.createFrom().item(request);
                }
                
                // Retrieve secret from Vault
                return vaultManager.getSecret(profile.getVaultPath())
                    .map(secret -> {
                        Map<String, String> headers = new HashMap<>(request.headers());
                        
                        // Inject based on auth type and location
                        switch (profile.getConfig().getLocation()) {
                            case HEADER -> {
                                String headerValue = buildAuthHeader(
                                    profile.getConfig().getScheme(),
                                    secret
                                );
                                headers.put(
                                    profile.getConfig().getParamName(),
                                    headerValue
                                );
                            }
                            case QUERY -> {
                                // Add to query params (less secure)
                                Map<String, String> queryParams = 
                                    new HashMap<>(request.queryParams());
                                queryParams.put(
                                    profile.getConfig().getParamName(),
                                    secret
                                );
                                return new tech.kayys.gamelan.mcp.runtime.HttpRequestContext(
                                    request.method(),
                                    request.url(),
                                    queryParams,
                                    headers,
                                    request.body(),
                                    request.contentType()
                                );
                            }
                        }
                        
                        return new tech.kayys.gamelan.mcp.runtime.HttpRequestContext(
                            request.method(),
                            request.url(),
                            request.queryParams(),
                            headers,
                            request.body(),
                            request.contentType()
                        );
                    });
            });
    }
    
    private String buildAuthHeader(String scheme, String secret) {
        if (scheme != null && !scheme.isEmpty()) {
            return scheme + " " + secret;
        }
        return secret;
    }
}

/**
 * Vault secret manager for secure credential storage
 */
@ApplicationScoped
public class VaultSecretManager {
    
    private static final Logger LOG = LoggerFactory.getLogger(VaultSecretManager.class);
    
    // In production, integrate with HashiCorp Vault, AWS Secrets Manager, etc.
    private final Map<String, String> inMemoryVault = new java.util.concurrent.ConcurrentHashMap<>();
    
    public Uni<Void> storeSecret(String path, String secret) {
        LOG.info("Storing secret at path: {}", path);
        inMemoryVault.put(path, secret);
        return Uni.createFrom().voidItem();
    }
    
    public Uni<String> getSecret(String path) {
        String secret = inMemoryVault.get(path);
        if (secret == null) {
            return Uni.createFrom().failure(
                new RuntimeException("Secret not found: " + path));
        }
        return Uni.createFrom().item(secret);
    }
    
    public Uni<Void> deleteSecret(String path) {
        inMemoryVault.remove(path);
        return Uni.createFrom().voidItem();
    }
}

/**
 * Rate limiter
 */
@ApplicationScoped
public class RateLimiter {
    
    private static final Logger LOG = LoggerFactory.getLogger(RateLimiter.class);
    
    private final Map<String, RateLimitBucket> buckets = 
        new java.util.concurrent.ConcurrentHashMap<>();
    
    public void checkLimit(
            String tenantId,
            String toolId,
            tech.kayys.gamelan.mcp.domain.ToolGuardrails guardrails) {
        
        String key = tenantId + ":" + toolId;
        RateLimitBucket bucket = buckets.computeIfAbsent(
            key,
            k -> new RateLimitBucket(
                guardrails.getRateLimitPerMinute(),
                guardrails.getRateLimitPerHour()
            )
        );
        
        if (!bucket.tryAcquire()) {
            throw new tech.kayys.gamelan.mcp.runtime.RateLimitExceededException(
                "Rate limit exceeded for tool: " + toolId);
        }
    }
    
    private static class RateLimitBucket {
        private final int perMinute;
        private final int perHour;
        private int minuteCount = 0;
        private int hourCount = 0;
        private long lastMinuteReset = System.currentTimeMillis();
        private long lastHourReset = System.currentTimeMillis();
        
        RateLimitBucket(int perMinute, int perHour) {
            this.perMinute = perMinute;
            this.perHour = perHour;
        }
        
        synchronized boolean tryAcquire() {
            long now = System.currentTimeMillis();
            
            // Reset counters if needed
            if (now - lastMinuteReset > 60000) {
                minuteCount = 0;
                lastMinuteReset = now;
            }
            if (now - lastHourReset > 3600000) {
                hourCount = 0;
                lastHourReset = now;
            }
            
            // Check limits
            if (minuteCount >= perMinute || hourCount >= perHour) {
                return false;
            }
            
            minuteCount++;
            hourCount++;
            return true;
        }
    }
}

/**
 * Network security filter
 */
@ApplicationScoped
public class NetworkSecurityFilter {
    
    private static final Logger LOG = LoggerFactory.getLogger(NetworkSecurityFilter.class);
    
    public Uni<Void> validateRequest(
            tech.kayys.gamelan.mcp.runtime.HttpRequestContext request,
            tech.kayys.gamelan.mcp.domain.ToolGuardrails guardrails) {
        
        return Uni.createFrom().item(() -> {
            // Validate against allowed domains
            if (guardrails.getAllowedDomains() != null && 
                !guardrails.getAllowedDomains().isEmpty()) {
                
                String domain = extractDomain(request.url());
                boolean allowed = guardrails.getAllowedDomains().stream()
                    .anyMatch(allowedDomain -> 
                        domain.endsWith(allowedDomain));
                
                if (!allowed) {
                    throw new SecurityException(
                        "Domain not allowed: " + domain);
                }
            }
            
            return null;
        });
    }
    
    private String extractDomain(String url) {
        try {
            java.net.URI uri = new java.net.URI(url);
            return uri.getHost();
        } catch (Exception e) {
            return "";
        }
    }
}

/**
 * PII redactor
 */
@ApplicationScoped
public class PiiRedactor {
    
    public Map<String, Object> redact(
            Map<String, Object> data,
            Set<String> piiPatterns) {
        
        if (piiPatterns == null || piiPatterns.isEmpty()) {
            return data;
        }
        
        Map<String, Object> redacted = new HashMap<>();
        
        data.forEach((key, value) -> {
            if (value instanceof String) {
                String str = (String) value;
                for (String pattern : piiPatterns) {
                    str = str.replaceAll(pattern, "[REDACTED]");
                }
                redacted.put(key, str);
            } else {
                redacted.put(key, value);
            }
        });
        
        return redacted;
    }
}

// ==================== SUPPORTING SERVICES ====================

package tech.kayys.gamelan.mcp.service;

import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import tech.kayys.gamelan.mcp.domain.*;
import tech.kayys.gamelan.mcp.runtime.*;

/**
 * Tool invocation recorder for audit
 */
@ApplicationScoped
public class ToolInvocationRecorder {
    
    public Uni<Void> record(
            ToolExecutionRequest request,
            ToolExecutionResult result,
            java.time.Instant startTime) {
        
        return io.quarkus.hibernate.reactive.panache.Panache.withTransaction(() -> {
            ToolInvocation invocation = new ToolInvocation();
            invocation.setInvocationId(UUID.randomUUID());
            invocation.setTenantId(request.tenantId());
            invocation.setToolId(request.toolId());
            invocation.setWorkflowRunId(request.workflowRunId());
            invocation.setAgentId(request.agentId());
            invocation.setUserId(request.userId());
            invocation.setArguments(request.arguments());
            invocation.setResult(result.output());
            invocation.setStatus(result.status());
            invocation.setErrorMessage(result.errorMessage());
            invocation.setExecutionTimeMs(result.executionTimeMs());
            invocation.setInvokedAt(startTime);
            invocation.setCompletedAt(java.time.Instant.now());
            
            return invocation.persist().replaceWithVoid();
        });
    }
}

/**
 * Tool metrics collector
 */
@ApplicationScoped
public class ToolMetricsCollector {
    
    public Uni<Void> collect(String toolId, ToolExecutionResult result) {
        // Update tool metrics asynchronously
        return Uni.createFrom().voidItem();
    }
}

/**
 * Tool capability analyzer
 */
@ApplicationScoped
public class ToolCapabilityAnalyzer {
    
    public tech.kayys.gamelan.mcp.domain.CapabilityLevel analyze(
            io.swagger.v3.oas.models.PathItem.HttpMethod method,
            io.swagger.v3.oas.models.Operation operation,
            String path) {
        
        // Analyze based on HTTP method
        return switch (method) {
            case GET, HEAD, OPTIONS -> tech.kayys.gamelan.mcp.domain.CapabilityLevel.READ_ONLY;
            case POST, PUT, PATCH -> {
                // Check for administrative keywords
                String fullPath = (path + " " + 
                    (operation.getSummary() != null ? operation.getSummary() : ""))
                    .toLowerCase();
                
                if (fullPath.contains("admin") || 
                    fullPath.contains("delete") ||
                    fullPath.contains("remove")) {
                    yield tech.kayys.gamelan.mcp.domain.CapabilityLevel.ADMINISTRATIVE;
                }
                yield tech.kayys.gamelan.mcp.domain.CapabilityLevel.WRITE;
            }
            case DELETE -> tech.kayys.gamelan.mcp.domain.CapabilityLevel.CRITICAL;
        };
    }
}

/**
 * Tool guardrail generator
 */
@ApplicationScoped
public class ToolGuardrailGenerator {
    
    public tech.kayys.gamelan.mcp.domain.ToolGuardrails generate(
            io.swagger.v3.oas.models.PathItem.HttpMethod method,
            io.swagger.v3.oas.models.Operation operation,
            Map<String, Object> config) {
        
        tech.kayys.gamelan.mcp.domain.ToolGuardrails guardrails = 
            new tech.kayys.gamelan.mcp.domain.ToolGuardrails();
        
        // Set defaults
        guardrails.setValidateInputSchema(true);
        guardrails.setValidateOutputSchema(true);
        guardrails.setSanitizeInput(true);
        guardrails.setAllowRedirects(false);
        guardrails.setLogRequests(true);
        
        // Apply config overrides
        if (config != null) {
            if (config.containsKey("rateLimitPerMinute")) {
                guardrails.setRateLimitPerMinute(
                    (Integer) config.get("rateLimitPerMinute"));
            }
            if (config.containsKey("maxExecutionTimeMs")) {
                guardrails.setMaxExecutionTimeMs(
                    (Integer) config.get("maxExecutionTimeMs"));
            }
        }
        
        return guardrails;
    }
}

package tech.kayys.gamelan.mcp.runtime;


// ==================== SCHEMA VALIDATOR ====================

/**
 * JSON Schema validator
 */
@ApplicationScoped
class SchemaValidator {
    
    private static final Logger LOG = LoggerFactory.getLogger(SchemaValidator.class);
    
    /**
     * Validate data against JSON schema
     */
    public void validate(Map<String, Object> schema, Map<String, Object> data) {
        if (schema == null || schema.isEmpty()) {
            return;
        }
        
        try {
            JSONObject schemaJson = new JSONObject(schema);
            Schema jsonSchema = SchemaLoader.load(schemaJson);
            
            JSONObject dataJson = new JSONObject(data);
            jsonSchema.validate(dataJson);
        } catch (ValidationException e) {
            LOG.error("Schema validation failed: {}", e.getMessage());
            throw new ToolValidationException(
                "Input validation failed: " + e.getMessage(), e);
        }
    }
}

// ==================== TOOL REGISTRY ====================

/**
 * Tool registry for resolving tools
 */
@ApplicationScoped
class ToolRegistry {
    
    /**
     * Resolve tool by ID and tenant
     */
    public Uni<McpTool> resolveTool(String toolId, String tenantId) {
        return McpTool.find(
            "toolId = ?1 and tenantId = ?2 and enabled = true",
            toolId, tenantId
        ).firstResult()
        .onItem().ifNull().failWith(() ->
            new ToolNotFoundException("Tool not found: " + toolId)
        );
    }
    
    /**
     * List tools for tenant with filters
     */
    public Uni<List<ToolMetadata>> listTools(ToolQuery query) {
        // Implementation for tool discovery
        return Uni.createFrom().item(List.of());
    }
}

// ==================== SUPPORTING CLASSES ====================

record ToolExecutionRequest(
    String toolId,
    String tenantId,
    Map<String, Object> arguments,
    Map<String, Object> context,
    String userId,
    String workflowRunId,
    String agentId
) {}

record ValidatedToolRequest(
    McpTool tool,
    Map<String, Object> arguments,
    Map<String, Object> context
) {}



// Exceptions
class ToolNotFoundException extends RuntimeException {
    public ToolNotFoundException(String message) {
        super(message);
    }
}

class ToolDisabledException extends RuntimeException {
    public ToolDisabledException(String message) {
        super(message);
    }
}

class ToolValidationException extends RuntimeException {
    public ToolValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}

class InputTooLargeException extends RuntimeException {
    public InputTooLargeException(String message) {
        super(message);
    }
}

class ResponseTooLargeException extends RuntimeException {
    public ResponseTooLargeException(String message) {
        super(message);
    }
}

class RateLimitExceededException extends RuntimeException {
    public RateLimitExceededException(String message) {
        super(message);
    }
}

class AuthenticationException extends RuntimeException {
    public AuthenticationException(String message) {
        super(message);
    }
}

package tech.kayys.gamelan.mcp.parser;

import io.quarkus.hibernate.reactive.panache.Panache;
import io.smallrye.mutiny.Uni;
import io.swagger.v3.oas.models.*;
import io.swagger.v3.oas.models.media.*;
import io.swagger.v3.oas.models.parameters.Parameter;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.parser.OpenAPIV3Parser;
import io.swagger.v3.parser.core.models.ParseOptions;
import io.swagger.v3.parser.core.models.SwaggerParseResult;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import tech.kayys.gamelan.mcp.domain.*;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * ============================================================================
 * OPENAPI PARSER & TOOL GENERATOR
 * ============================================================================
 * 
 * Transforms OpenAPI specifications into executable MCP tools.
 * 
 * Pipeline:
 * 1. Parse OpenAPI spec (URL, file, or raw)
 * 2. Validate spec structure
 * 3. Extract operations â†’ MCP tools
 * 4. Generate input/output schemas
 * 5. Configure HTTP execution
 * 6. Map authentication
 * 7. Apply guardrails
 * 8. Persist to registry
 */
@ApplicationScoped
public class OpenApiToolGenerator {
    
    private static final Logger LOG = LoggerFactory.getLogger(OpenApiToolGenerator.class);
    
    @Inject
    OpenApiParser parser;
    
    @Inject
    SchemaConverter schemaConverter;
    
    @Inject
    ToolGuardrailGenerator guardrailGenerator;
    
    @Inject
    AuthProfileMapper authMapper;
    
    @Inject
    ToolCapabilityAnalyzer capabilityAnalyzer;
    
    /**
     * Generate MCP tools from OpenAPI source
     */
    public Uni<ToolGenerationResult> generateTools(GenerateToolsRequest request) {
        LOG.info("Generating tools from OpenAPI source: {} (tenant: {})", 
            request.namespace(), request.tenantId());
        
        return Panache.withTransaction(() ->
            // Parse OpenAPI spec
            parser.parse(request)
                .flatMap(parseResult -> {
                    if (!parseResult.isValid()) {
                        return Uni.createFrom().failure(
                            new OpenApiParseException("Invalid OpenAPI spec: " + 
                                parseResult.errors()));
                    }
                    
                    // Create source record
                    return createOpenApiSource(request, parseResult)
                        .flatMap(source ->
                            // Generate tools from operations
                            generateToolsFromSpec(source, parseResult.openApi(), request)
                                .flatMap(tools ->
                                    // Persist tools
                                    persistTools(tools)
                                        .map(persisted -> 
                                            new ToolGenerationResult(
                                                source.getSourceId(),
                                                source.getNamespace(),
                                                persisted.size(),
                                                persisted.stream()
                                                    .map(McpTool::getToolId)
                                                    .collect(Collectors.toList()),
                                                List.of()
                                            )
                                        )
                                )
                        );
                })
        );
    }
    
    /**
     * Create OpenAPI source record
     */
    private Uni<OpenApiSource> createOpenApiSource(
            GenerateToolsRequest request,
            OpenApiParseResult parseResult) {
        
        return Uni.createFrom().item(() -> {
            OpenApiSource source = new OpenApiSource();
            source.setSourceId(UUID.randomUUID());
            source.setTenantId(request.tenantId());
            source.setNamespace(request.namespace());
            source.setDisplayName(parseResult.openApi().getInfo().getTitle());
            source.setSourceType(request.sourceType());
            source.setSourceLocation(request.source());
            source.setSpecContent(request.sourceType() == SourceType.RAW ? 
                request.source() : null);
            source.setSpecVersion(parseResult.openApi().getOpenapi());
            source.setSpecHash(calculateHash(parseResult.rawSpec()));
            source.setDefaultAuthProfileId(request.authProfileId());
            source.setStatus(SourceStatus.ACTIVE);
            source.setCreatedAt(Instant.now());
            source.setUpdatedAt(Instant.now());
            source.setCreatedBy(request.userId());
            
            return source.persist();
        }).flatMap(v -> (Uni<OpenApiSource>) v);
    }
    
    /**
     * Generate tools from OpenAPI operations
     */
    private Uni<List<McpTool>> generateToolsFromSpec(
            OpenApiSource source,
            OpenAPI openApi,
            GenerateToolsRequest request) {
        
        return Uni.createFrom().item(() -> {
            List<McpTool> tools = new ArrayList<>();
            
            // Get base URL
            String baseUrl = extractBaseUrl(openApi);
            
            // Process each path and operation
            if (openApi.getPaths() != null) {
                openApi.getPaths().forEach((path, pathItem) -> {
                    processPathItem(
                        source,
                        openApi,
                        baseUrl,
                        path,
                        pathItem,
                        request,
                        tools
                    );
                });
            }
            
            LOG.info("Generated {} tools from OpenAPI spec", tools.size());
            return tools;
        });
    }
    
    /**
     * Process a single path item (with all HTTP methods)
     */
    private void processPathItem(
            OpenApiSource source,
            OpenAPI openApi,
            String baseUrl,
            String path,
            PathItem pathItem,
            GenerateToolsRequest request,
            List<McpTool> tools) {
        
        // Process each HTTP method
        Map<PathItem.HttpMethod, Operation> operations = pathItem.readOperationsMap();
        
        operations.forEach((httpMethod, operation) -> {
            try {
                McpTool tool = createToolFromOperation(
                    source,
                    openApi,
                    baseUrl,
                    path,
                    httpMethod,
                    operation,
                    request
                );
                tools.add(tool);
            } catch (Exception e) {
                LOG.error("Failed to create tool from operation: {} {}", 
                    httpMethod, path, e);
            }
        });
    }
    
    /**
     * Create MCP tool from OpenAPI operation
     */
    private McpTool createToolFromOperation(
            OpenApiSource source,
            OpenAPI openApi,
            String baseUrl,
            String path,
            PathItem.HttpMethod httpMethod,
            Operation operation,
            GenerateToolsRequest request) {
        
        McpTool tool = new McpTool();
        
        // Identity
        String operationId = operation.getOperationId() != null ? 
            operation.getOperationId() : 
            generateOperationId(httpMethod, path);
        
        tool.setToolId(request.namespace() + "." + operationId);
        tool.setTenantId(request.tenantId());
        tool.setNamespace(request.namespace());
        tool.setName(operationId);
        tool.setOperationId(operationId);
        
        // Description - use from OpenAPI or generate
        String description = extractDescription(operation);
        tool.setDescription(description);
        
        // Capabilities - extract from tags or description
        Set<String> capabilities = extractCapabilities(operation, description);
        tool.setCapabilities(capabilities);
        
        // Tags
        Set<String> tags = operation.getTags() != null ? 
            new HashSet<>(operation.getTags()) : new HashSet<>();
        tool.setTags(tags);
        
        // Capability level - analyze operation safety
        CapabilityLevel capabilityLevel = capabilityAnalyzer.analyze(
            httpMethod, operation, path);
        tool.setCapabilityLevel(capabilityLevel);
        tool.setReadOnly(httpMethod == PathItem.HttpMethod.GET);
        
        // Input schema
        Map<String, Object> inputSchema = generateInputSchema(
            openApi, operation, path);
        tool.setInputSchema(inputSchema);
        
        // Output schema
        Map<String, Object> outputSchema = generateOutputSchema(
            openApi, operation);
        tool.setOutputSchema(outputSchema);
        
        // HTTP execution config
        HttpExecutionConfig execConfig = createExecutionConfig(
            baseUrl, path, httpMethod, operation, openApi);
        tool.setExecutionConfig(execConfig);
        
        // Auth profile
        tool.setAuthProfileId(request.authProfileId());
        
        // Guardrails
        ToolGuardrails guardrails = guardrailGenerator.generate(
            httpMethod, operation, request.guardrailsConfig());
        tool.setGuardrails(guardrails);
        
        // Metadata
        tool.setSource(source);
        tool.setCreatedAt(Instant.now());
        tool.setUpdatedAt(Instant.now());
        tool.setCreatedBy(request.userId());
        tool.setEnabled(true);
        
        // Metrics
        tool.setMetrics(new ToolMetrics());
        
        return tool;
    }
    
    /**
     * Generate input schema from parameters and request body
     */
    private Map<String, Object> generateInputSchema(
            OpenAPI openApi,
            Operation operation,
            String path) {
        
        Map<String, Object> schema = new HashMap<>();
        schema.put("type", "object");
        
        Map<String, Object> properties = new HashMap<>();
        List<String> required = new ArrayList<>();
        
        // Path parameters
        if (operation.getParameters() != null) {
            for (Parameter param : operation.getParameters()) {
                if (param.getIn().equals("path") || 
                    param.getIn().equals("query") || 
                    param.getIn().equals("header")) {
                    
                    Map<String, Object> paramSchema = 
                        schemaConverter.convert(param.getSchema());
                    paramSchema.put("description", param.getDescription());
                    properties.put(param.getName(), paramSchema);
                    
                    if (Boolean.TRUE.equals(param.getRequired())) {
                        required.add(param.getName());
                    }
                }
            }
        }
        
        // Request body
        if (operation.getRequestBody() != null) {
            Content content = operation.getRequestBody().getContent();
            if (content != null) {
                MediaType mediaType = content.get("application/json");
                if (mediaType != null && mediaType.getSchema() != null) {
                    Map<String, Object> bodySchema = 
                        schemaConverter.convert(mediaType.getSchema());
                    
                    // Merge body schema properties
                    if (bodySchema.get("properties") instanceof Map) {
                        @SuppressWarnings("unchecked")
                        Map<String, Object> bodyProps = 
                            (Map<String, Object>) bodySchema.get("properties");
                        properties.putAll(bodyProps);
                        
                        // Add required fields from body
                        if (bodySchema.get("required") instanceof List) {
                            @SuppressWarnings("unchecked")
                            List<String> bodyRequired = 
                                (List<String>) bodySchema.get("required");
                            required.addAll(bodyRequired);
                        }
                    }
                }
            }
        }
        
        schema.put("properties", properties);
        if (!required.isEmpty()) {
            schema.put("required", required);
        }
        
        return schema;
    }
    
    /**
     * Generate output schema from responses
     */
    private Map<String, Object> generateOutputSchema(
            OpenAPI openApi,
            Operation operation) {
        
        if (operation.getResponses() == null) {
            return Map.of("type", "object");
        }
        
        // Use 200/201 response schema
        ApiResponse successResponse = operation.getResponses().get("200");
        if (successResponse == null) {
            successResponse = operation.getResponses().get("201");
        }
        
        if (successResponse != null && successResponse.getContent() != null) {
            MediaType mediaType = successResponse.getContent().get("application/json");
            if (mediaType != null && mediaType.getSchema() != null) {
                return schemaConverter.convert(mediaType.getSchema());
            }
        }
        
        return Map.of("type", "object");
    }
    
    /**
     * Create HTTP execution configuration
     */
    private HttpExecutionConfig createExecutionConfig(
            String baseUrl,
            String path,
            PathItem.HttpMethod httpMethod,
            Operation operation,
            OpenAPI openApi) {
        
        HttpExecutionConfig config = new HttpExecutionConfig();
        
        // HTTP method
        config.setMethod(HttpMethod.valueOf(httpMethod.name()));
        config.setBaseUrl(baseUrl);
        config.setPath(path);
        
        // Parameters
        List<ParameterMapping> parameters = new ArrayList<>();
        if (operation.getParameters() != null) {
            for (Parameter param : operation.getParameters()) {
                ParameterMapping mapping = new ParameterMapping();
                mapping.setName(param.getName());
                mapping.setMappedName(param.getName());
                mapping.setLocation(ParameterLocation.valueOf(
                    param.getIn().toUpperCase()));
                mapping.setRequired(Boolean.TRUE.equals(param.getRequired()));
                mapping.setDescription(param.getDescription());
                parameters.add(mapping);
            }
        }
        config.setParameters(parameters);
        
        // Headers
        Map<String, String> headers = new HashMap<>();
        headers.put("User-Agent", "Gamelan-MCP/1.0");
        config.setHeaders(headers);
        
        // Content type
        if (operation.getRequestBody() != null && 
            operation.getRequestBody().getContent() != null) {
            String contentType = operation.getRequestBody().getContent()
                .keySet().stream().findFirst().orElse("application/json");
            config.setContentType(contentType);
        }
        
        // Retry config
        RetryConfig retryConfig = new RetryConfig();
        config.setRetryConfig(retryConfig);
        
        return config;
    }
    
    /**
     * Extract description from operation (use docs as capabilities)
     */
    private String extractDescription(Operation operation) {
        if (operation.getSummary() != null) {
            return operation.getSummary();
        }
        if (operation.getDescription() != null) {
            return operation.getDescription();
        }
        if (operation.getOperationId() != null) {
            return humanizeOperationId(operation.getOperationId());
        }
        return "No description available";
    }
    
    /**
     * Extract capabilities from operation
     * Use description/summary as capability if available
     */
    private Set<String> extractCapabilities(Operation operation, String description) {
        Set<String> capabilities = new HashSet<>();
        
        // Use summary as primary capability
        if (operation.getSummary() != null) {
            capabilities.add(operation.getSummary().toLowerCase());
        }
        
        // Add tags as capabilities
        if (operation.getTags() != null) {
            capabilities.addAll(operation.getTags().stream()
                .map(String::toLowerCase)
                .collect(Collectors.toSet()));
        }
        
        // If no capabilities found, use operation ID
        if (capabilities.isEmpty() && operation.getOperationId() != null) {
            capabilities.add(humanizeOperationId(operation.getOperationId()));
        }
        
        return capabilities;
    }
    
    /**
     * Extract base URL from OpenAPI servers
     */
    private String extractBaseUrl(OpenAPI openApi) {
        if (openApi.getServers() != null && !openApi.getServers().isEmpty()) {
            return openApi.getServers().get(0).getUrl();
        }
        return "https://api.example.com";  // Placeholder
    }
    
    /**
     * Generate operation ID if not provided
     */
    private String generateOperationId(PathItem.HttpMethod method, String path) {
        String cleaned = path.replaceAll("[^a-zA-Z0-9]", "_");
        return method.name().toLowerCase() + cleaned;
    }
    
    /**
     * Humanize operation ID for display
     */
    private String humanizeOperationId(String operationId) {
        return operationId
            .replaceAll("([a-z])([A-Z])", "$1 $2")
            .replaceAll("_", " ")
            .toLowerCase();
    }
    
    /**
     * Calculate hash of spec for change detection
     */
    private String calculateHash(String content) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(content.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            return UUID.randomUUID().toString();
        }
    }
    
    /**
     * Persist generated tools
     */
    private Uni<List<McpTool>> persistTools(List<McpTool> tools) {
        return Uni.join().all(
            tools.stream()
                .map(tool -> tool.<McpTool>persist())
                .collect(Collectors.toList())
        ).andFailFast();
    }
}

// ==================== OPENAPI PARSER ====================

/**
 * OpenAPI specification parser
 */
@ApplicationScoped
class OpenApiParser {
    
    private static final Logger LOG = LoggerFactory.getLogger(OpenApiParser.class);
    
    @Inject
    io.vertx.mutiny.core.Vertx vertx;
    
    /**
     * Parse OpenAPI from various sources
     */
    public Uni<OpenApiParseResult> parse(GenerateToolsRequest request) {
        return switch (request.sourceType()) {
            case URL -> parseFromUrl(request.source());
            case FILE -> parseFromFile(request.source());
            case RAW -> parseFromString(request.source());
            case GIT -> parseFromGit(request.source());
        };
    }
    
    /**
     * Parse from URL
     */
    private Uni<OpenApiParseResult> parseFromUrl(String url) {
        LOG.info("Parsing OpenAPI from URL: {}", url);
        
        return vertx.createHttpClient()
            .request(io.vertx.core.http.HttpMethod.GET, url)
            .flatMap(request -> request.send()
                .flatMap(response -> {
                    if (response.statusCode() != 200) {
                        return Uni.createFrom().failure(
                            new OpenApiParseException(
                                "Failed to fetch OpenAPI spec: HTTP " + 
                                response.statusCode()));
                    }
                    return response.body();
                }))
            .map(buffer -> buffer.toString())
            .map(this::parseSpec);
    }
    
    /**
     * Parse from file
     */
    private Uni<OpenApiParseResult> parseFromFile(String filePath) {
        return vertx.fileSystem().readFile(filePath)
            .map(buffer -> buffer.toString())
            .map(this::parseSpec);
    }
    
    /**
     * Parse from raw string
     */
    private Uni<OpenApiParseResult> parseFromString(String spec) {
        return Uni.createFrom().item(parseSpec(spec));
    }
    
    /**
     * Parse from Git repository
     */
    private Uni<OpenApiParseResult> parseFromGit(String gitRef) {
        // TODO: Implement Git integration
        return Uni.createFrom().failure(
            new UnsupportedOperationException("Git source not yet implemented"));
    }
    
    /**
     * Parse OpenAPI spec string
     */
    private OpenApiParseResult parseSpec(String spec) {
        ParseOptions options = new ParseOptions();
        options.setResolve(true);
        options.setResolveFully(true);
        
        SwaggerParseResult result = new OpenAPIV3Parser()
            .readContents(spec, null, options);
        
        if (result.getOpenAPI() == null) {
            return new OpenApiParseResult(
                null,
                spec,
                false,
                result.getMessages()
            );
        }
        
        return new OpenApiParseResult(
            result.getOpenAPI(),
            spec,
            result.getMessages() == null || result.getMessages().isEmpty(),
            result.getMessages() != null ? result.getMessages() : List.of()
        );
    }
}

// ==================== SCHEMA CONVERTER ====================

/**
 * Convert OpenAPI schema to JSON Schema
 */
@ApplicationScoped
class SchemaConverter {
    
    /**
     * Convert OpenAPI schema to JSON Schema format
     */
    public Map<String, Object> convert(Schema<?> schema) {
        if (schema == null) {
            return Map.of("type", "object");
        }
        
        Map<String, Object> jsonSchema = new HashMap<>();
        
        // Type
        if (schema.getType() != null) {
            jsonSchema.put("type", schema.getType());
        }
        
        // Format
        if (schema.getFormat() != null) {
            jsonSchema.put("format", schema.getFormat());
        }
        
        // Description
        if (schema.getDescription() != null) {
            jsonSchema.put("description", schema.getDescription());
        }
        
        // Enum
        if (schema.getEnum() != null) {
            jsonSchema.put("enum", schema.getEnum());
        }
        
        // Properties (for object types)
        if (schema.getProperties() != null) {
            Map<String, Object> properties = new HashMap<>();
            schema.getProperties().forEach((name, propSchema) -> {
                properties.put(name, convert((Schema<?>) propSchema));
            });
            jsonSchema.put("properties", properties);
        }
        
        // Required
        if (schema.getRequired() != null) {
            jsonSchema.put("required", schema.getRequired());
        }
        
        // Items (for array types)
        if (schema.getItems() != null) {
            jsonSchema.put("items", convert(schema.getItems()));
        }
        
        // Validation constraints
        if (schema.getMinimum() != null) {
            jsonSchema.put("minimum", schema.getMinimum());
        }
        if (schema.getMaximum() != null) {
            jsonSchema.put("maximum", schema.getMaximum());
        }
        if (schema.getMinLength() != null) {
            jsonSchema.put("minLength", schema.getMinLength());
        }
        if (schema.getMaxLength() != null) {
            jsonSchema.put("maxLength", schema.getMaxLength());
        }
        if (schema.getPattern() != null) {
            jsonSchema.put("pattern", schema.getPattern());
        }
        
        return jsonSchema;
    }
}

// ==================== SUPPORTING CLASSES ====================

record GenerateToolsRequest(
    String tenantId,
    String namespace,
    SourceType sourceType,
    String source,
    String authProfileId,
    String userId,
    Map<String, Object> guardrailsConfig
) {}

record OpenApiParseResult(
    OpenAPI openApi,
    String rawSpec,
    boolean isValid,
    List<String> errors
) {}

record ToolGenerationResult(
    UUID sourceId,
    String namespace,
    int toolsGenerated,
    List<String> toolIds,
    List<String> warnings
) {}

class OpenApiParseException extends RuntimeException {
    public OpenApiParseException(String message) {
        super(message);
    }
}

package tech.kayys.gamelan.mcp.domain;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import java.time.Instant;
import java.util.*;

/**
 * ============================================================================
 * GAMELAN MCP (Model Context Protocol) SERVER - DOMAIN MODEL
 * ============================================================================
 * 
 * Production-grade OpenAPI â†’ MCP Tool transformation engine.
 * 
 * Key Features:
 * - Multi-tenant tool registry
 * - Dynamic tool generation from OpenAPI specs
 * - Runtime tool execution with safety guardrails
 * - Auth profile management
 * - Schema validation
 * - Rate limiting & observability
 * 
 * Package: tech.kayys.gamelan.mcp
 */

// ==================== MCP TOOL AGGREGATE ROOT ====================

/**
 * MCP Tool - Represents an executable tool derived from OpenAPI
 * 
 * Each OpenAPI operation becomes one MCP Tool.
 * Tools are tenant-scoped and version-controlled.
 */
@Entity
@Table(name = "mcp_tools", indexes = {
    @Index(name = "idx_mcp_tools_tenant", columnList = "tenant_id"),
    @Index(name = "idx_mcp_tools_namespace", columnList = "namespace"),
    @Index(name = "idx_mcp_tools_enabled", columnList = "enabled"),
    @Index(name = "idx_mcp_tools_composite", columnList = "tenant_id,namespace,name")
})
public class McpTool {
    
    @Id
    @Column(name = "tool_id")
    private String toolId;  // Format: {namespace}.{operationId}
    
    @NotNull
    @Column(name = "tenant_id")
    private String tenantId;
    
    @NotNull
    @Column(name = "namespace")
    private String namespace;  // e.g., "payment-api", "crm-api"
    
    @NotNull
    @Column(name = "name")
    private String name;  // e.g., "createPayment"
    
    @Column(name = "version")
    private String version = "1.0.0";
    
    @Column(name = "description", length = 1000)
    private String description;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "tool_type")
    private ToolType toolType = ToolType.HTTP;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "capability_level")
    private CapabilityLevel capabilityLevel;
    
    // JSON Schema for input validation
    @Column(name = "input_schema", columnDefinition = "jsonb")
    private Map<String, Object> inputSchema;
    
    // JSON Schema for output validation
    @Column(name = "output_schema", columnDefinition = "jsonb")
    private Map<String, Object> outputSchema;
    
    // HTTP execution configuration
    @Embedded
    private HttpExecutionConfig executionConfig;
    
    // Authentication reference
    @Column(name = "auth_profile_id")
    private String authProfileId;
    
    // Safety & guardrails
    @Embedded
    private ToolGuardrails guardrails;
    
    // Operational metadata
    @Column(name = "enabled")
    private boolean enabled = true;
    
    @Column(name = "read_only")
    private boolean readOnly = false;
    
    @Column(name = "requires_approval")
    private boolean requiresApproval = false;
    
    // Categorization & discovery
    @ElementCollection
    @CollectionTable(name = "mcp_tool_tags")
    private Set<String> tags = new HashSet<>();
    
    @ElementCollection
    @CollectionTable(name = "mcp_tool_capabilities")
    private Set<String> capabilities = new HashSet<>();
    
    // Temporal tracking
    @Column(name = "created_at")
    private Instant createdAt;
    
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private String createdBy;
    
    // OpenAPI source reference
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "openapi_source_id")
    private OpenApiSource source;
    
    @Column(name = "operation_id")
    private String operationId;  // Original OpenAPI operationId
    
    // Metrics & usage
    @Embedded
    private ToolMetrics metrics;
    
    // Versioning
    @Version
    @Column(name = "version_number")
    private Long versionNumber;
}

// ==================== HTTP EXECUTION CONFIG ====================

/**
 * HTTP execution configuration embedded in MCP Tool
 */
@Embeddable
class HttpExecutionConfig {
    
    @Enumerated(EnumType.STRING)
    @Column(name = "http_method")
    private HttpMethod method;
    
    @Column(name = "base_url")
    private String baseUrl;
    
    @Column(name = "path")
    private String path;
    
    // Template parameters (path, query, header)
    @Column(name = "parameters", columnDefinition = "jsonb")
    private List<ParameterMapping> parameters;
    
    // Static headers
    @Column(name = "headers", columnDefinition = "jsonb")
    private Map<String, String> headers;
    
    @Column(name = "content_type")
    private String contentType = "application/json";
    
    @Column(name = "accept")
    private String accept = "application/json";
    
    // Timeout configuration
    @Column(name = "timeout_ms")
    private Integer timeoutMs = 30000;
    
    @Column(name = "retry_config", columnDefinition = "jsonb")
    private RetryConfig retryConfig;
}



/**
 * Parameter mapping from MCP arguments to HTTP request
 */
class ParameterMapping {
    private String name;
    private ParameterLocation location;
    private String mappedName;  // Name in OpenAPI spec
    private boolean required;
    private Object defaultValue;
    private String description;
}

enum ParameterLocation {
    PATH,
    QUERY,
    HEADER,
    COOKIE,
    BODY
}

/**
 * Retry configuration
 */
class RetryConfig {
    private int maxAttempts = 3;
    private long initialDelayMs = 1000;
    private double backoffMultiplier = 2.0;
    private long maxDelayMs = 30000;
    private Set<Integer> retryableStatusCodes = Set.of(408, 429, 500, 502, 503, 504);
}

// ==================== TOOL GUARDRAILS ====================

/**
 * Safety and security guardrails for tool execution
 */
@Embeddable
class ToolGuardrails {
    
    // Input validation
    @Column(name = "max_input_size_bytes")
    private Integer maxInputSizeBytes = 1_048_576;  // 1MB
    
    @Column(name = "validate_input_schema")
    private boolean validateInputSchema = true;
    
    @Column(name = "sanitize_input")
    private boolean sanitizeInput = true;
    
    // Output validation
    @Column(name = "max_response_size_bytes")
    private Integer maxResponseSizeBytes = 10_485_760;  // 10MB
    
    @Column(name = "validate_output_schema")
    private boolean validateOutputSchema = true;
    
    // Network security
    @ElementCollection
    @CollectionTable(name = "mcp_tool_allowed_domains")
    private Set<String> allowedDomains = new HashSet<>();
    
    @Column(name = "allow_redirects")
    private boolean allowRedirects = false;
    
    // Rate limiting
    @Column(name = "rate_limit_per_minute")
    private Integer rateLimitPerMinute = 60;
    
    @Column(name = "rate_limit_per_hour")
    private Integer rateLimitPerHour = 1000;
    
    @Column(name = "rate_limit_per_day")
    private Integer rateLimitPerDay = 10000;
    
    // Execution limits
    @Column(name = "max_execution_time_ms")
    private Integer maxExecutionTimeMs = 60000;
    
    @Column(name = "max_retries")
    private Integer maxRetries = 3;
    
    // PII & data protection
    @Column(name = "redact_pii")
    private boolean redactPii = false;
    
    @ElementCollection
    @CollectionTable(name = "mcp_tool_pii_patterns")
    private Set<String> piiPatterns = new HashSet<>();
    
    // Audit & compliance
    @Column(name = "log_requests")
    private boolean logRequests = true;
    
    @Column(name = "log_responses")
    private boolean logResponses = false;  // May contain sensitive data
    
    @Column(name = "require_audit_trail")
    private boolean requireAuditTrail = false;
}

// ==================== TOOL TYPES & CAPABILITIES ====================

enum ToolType {
    HTTP,           // REST API call
    GRPC,           // gRPC service
    GRAPHQL,        // GraphQL query/mutation
    DATABASE,       // Database query
    WEBHOOK,        // Async webhook callback
    FUNCTION        // Custom function
}

enum CapabilityLevel {
    READ_ONLY,      // Safe for autonomous agents
    WRITE,          // Modifies state
    CRITICAL,       // High-impact operations
    ADMINISTRATIVE  // Requires human approval
}

// ==================== TOOL METRICS ====================

/**
 * Tool usage metrics
 */
@Embeddable
class ToolMetrics {
    
    @Column(name = "total_invocations")
    private Long totalInvocations = 0L;
    
    @Column(name = "successful_invocations")
    private Long successfulInvocations = 0L;
    
    @Column(name = "failed_invocations")
    private Long failedInvocations = 0L;
    
    @Column(name = "avg_execution_time_ms")
    private Long avgExecutionTimeMs = 0L;
    
    @Column(name = "last_invoked_at")
    private Instant lastInvokedAt;
    
    @Column(name = "last_success_at")
    private Instant lastSuccessAt;
    
    @Column(name = "last_failure_at")
    private Instant lastFailureAt;
}

// ==================== OPENAPI SOURCE ====================

/**
 * OpenAPI source document
 * Tracks the original OpenAPI spec from which tools were generated
 */
@Entity
@Table(name = "mcp_openapi_sources")
public class OpenApiSource {
    
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "source_id")
    private UUID sourceId;
    
    @NotNull
    @Column(name = "tenant_id")
    private String tenantId;
    
    @NotNull
    @Column(name = "namespace")
    private String namespace;
    
    @Column(name = "display_name")
    private String displayName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "source_type")
    private SourceType sourceType;
    
    @Column(name = "source_location", length = 2000)
    private String sourceLocation;  // URL, file path, or "inline"
    
    // Full OpenAPI spec stored for reference
    @Column(name = "spec_content", columnDefinition = "text")
    private String specContent;
    
    @Column(name = "spec_version")
    private String specVersion;  // 2.0, 3.0.0, 3.1.0
    
    @Column(name = "spec_hash")
    private String specHash;  // For change detection
    
    // Auth configuration
    @Column(name = "default_auth_profile_id")
    private String defaultAuthProfileId;
    
    // Status
    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private SourceStatus status = SourceStatus.ACTIVE;
    
    @Column(name = "enabled")
    private boolean enabled = true;
    
    // Generation metadata
    @Column(name = "tools_generated")
    private Integer toolsGenerated = 0;
    
    @Column(name = "last_sync_at")
    private Instant lastSyncAt;
    
    @Column(name = "sync_schedule")
    private String syncSchedule;  // Cron expression for auto-refresh
    
    // Timestamps
    @Column(name = "created_at")
    private Instant createdAt;
    
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private String createdBy;
    
    // Relationships
    @OneToMany(mappedBy = "source", cascade = CascadeType.ALL)
    private List<McpTool> tools = new ArrayList<>();
}

enum SourceType {
    URL,        // HTTP(S) URL to OpenAPI spec
    FILE,       // Uploaded file
    RAW,        // Raw spec string
    GIT         // Git repository reference
}

enum SourceStatus {
    ACTIVE,
    PARSING,
    FAILED,
    DEPRECATED,
    ARCHIVED
}

// ==================== AUTH PROFILE ====================

/**
 * Authentication profile for API access
 * Secrets are stored in Vault, only references kept here
 */
@Entity
@Table(name = "mcp_auth_profiles")
public class AuthProfile {
    
    @Id
    @Column(name = "profile_id")
    private String profileId;
    
    @NotNull
    @Column(name = "tenant_id")
    private String tenantId;
    
    @NotNull
    @Column(name = "profile_name")
    private String profileName;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "auth_type")
    private AuthType authType;
    
    @Column(name = "description")
    private String description;
    
    // Auth configuration (non-sensitive)
    @Embedded
    private AuthConfig config;
    
    // Vault reference for secrets
    @Column(name = "vault_path")
    private String vaultPath;
    
    @Column(name = "secret_key")
    private String secretKey;
    
    // Status
    @Column(name = "enabled")
    private boolean enabled = true;
    
    @Column(name = "expires_at")
    private Instant expiresAt;
    
    // Timestamps
    @Column(name = "created_at")
    private Instant createdAt;
    
    @Column(name = "updated_at")
    private Instant updatedAt;
}

enum AuthType {
    NONE,
    API_KEY,
    BEARER_TOKEN,
    BASIC_AUTH,
    OAUTH2,
    OAUTH2_CLIENT_CREDENTIALS,
    OAUTH2_PASSWORD,
    JWT,
    MTLS,
    CUSTOM
}

/**
 * Auth configuration (non-sensitive parameters)
 */
@Embeddable
class AuthConfig {
    
    @Enumerated(EnumType.STRING)
    @Column(name = "location")
    private AuthLocation location;
    
    @Column(name = "param_name")
    private String paramName;  // Header name, query param name, etc.
    
    @Column(name = "scheme")
    private String scheme;  // "Bearer", "Basic", etc.
    
    // OAuth2 specific
    @Column(name = "token_url")
    private String tokenUrl;
    
    @Column(name = "scopes")
    private String scopes;
    
    @Column(name = "client_id")
    private String clientId;
    
    // Token refresh
    @Column(name = "auto_refresh")
    private boolean autoRefresh = true;
    
    @Column(name = "token_cache_key")
    private String tokenCacheKey;
}

enum AuthLocation {
    HEADER,
    QUERY,
    COOKIE,
    BODY
}

// ==================== TOOL INVOCATION ====================



// ==================== TOOL REGISTRY QUERY ====================

/**
 * Tool discovery and filtering criteria
 */
class ToolQuery {
    private String tenantId;
    private String namespace;
    private Set<String> tags;
    private Set<String> capabilities;
    private CapabilityLevel maxCapabilityLevel;
    private Boolean enabled;
    private Boolean readOnly;
    private String searchTerm;
    private int page = 0;
    private int size = 50;
}

// ==================== VALUE OBJECTS ====================

/**
 * Tool metadata for agent discovery
 */
record ToolMetadata(
    String toolId,
    String name,
    String description,
    Map<String, Object> inputSchema,
    Set<String> capabilities,
    CapabilityLevel capabilityLevel,
    boolean readOnly
) {}