// src/main/java/com/example/generator/plugin/PluginConfiguration.java
package com.example.generator.plugin;

import io.smallrye.config.ConfigMapping;
import io.smallrye.config.WithDefault;

import java.util.List;
import java.util.Map;

@ConfigMapping(prefix = "mcp.generator.plugins")
public interface PluginConfiguration {
    
    @WithDefault("true")
    boolean enabled();
    
    @WithDefault("builtin")
    List<String> enabledPlugins();
    
    @WithDefault("30")
    int executionTimeoutSeconds();
    
    @WithDefault("true")
    boolean allowCustomPlugins();
    
    Map<String, Map<String, String>> pluginConfigs();
}

// src/main/java/com/example/generator/plugin/PluginAwareGeneratorService.java
package com.example.generator.plugin;

import com.example.generator.*;
import io.quarkus.logging.Log;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import jakarta.inject.Inject;
import io.quarkus.runtime.StartupEvent;

import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@ApplicationScoped
public class PluginAwareGeneratorService {
    
    @Inject
    PluginManager pluginManager;
    
    @Inject
    PluginConfiguration pluginConfig;
    
    @Inject
    McpServerGeneratorService generatorService;
    
    void onStart(@Observes StartupEvent ev) {
        if (pluginConfig.enabled()) {
            pluginManager.initializePlugins();
            Log.info("Plugin system is enabled and initialized");
        } else {
            Log.info("Plugin system is disabled");
        }
    }
    
    public Uni<byte[]> generateMcpServerWithPlugins(InputStream inputFile, String filename, 
                                                   String packageName, String serverName, 
                                                   String baseUrl, boolean includeAuth,
                                                   McpGeneratorResource.SpecificationType specType, 
                                                   String collectionName, Map<String, Object> pluginOptions) {
        return Uni.createFrom().item(() -> {
            if (!pluginConfig.enabled()) {
                // Fallback to original service
                return generatorService.generateMcpServer(inputFile, filename, packageName, 
                    serverName, baseUrl, includeAuth, specType, collectionName).await().indefinitely();
            }
            
            try {
                PluginExecutionContext context = pluginManager.createExecutionContext();
                context.setConfiguration(pluginOptions != null ? pluginOptions : new HashMap<>());
                
                // Step 1: Process specification using plugins
                ApiSpecification apiSpec = processSpecificationWithPlugins(inputFile, filename, 
                    specType, context);
                
                // Step 2: Validate with plugins
                validateWithPlugins(apiSpec, context);
                
                // Step 3: Generate model with plugins
                McpServerModel serverModel = generateModelWithPlugins(apiSpec, packageName, 
                    serverName, baseUrl, includeAuth, context);
                
                // Step 4: Generate source files with plugins
                Map<String, String> sourceFiles = generateSourceFilesWithPlugins(serverModel, context);
                
                // Step 5: Create ZIP archive
                return createZipArchive(sourceFiles);
                
            } catch (Exception e) {
                Log.error("Plugin-aware generation failed, falling back to standard generation", e);
                // Fallback to original service
                return generatorService.generateMcpServer(inputFile, filename, packageName, 
                    serverName, baseUrl, includeAuth, specType, collectionName).await().indefinitely();
            }
        });
    }
    
    private ApiSpecification processSpecificationWithPlugins(InputStream inputFile, String filename,
                                                           McpGeneratorResource.SpecificationType specType,
                                                           PluginExecutionContext context) throws Exception {
        
        // Try to find a plugin that can process this specification
        Optional<SpecificationProcessor> processor = pluginManager.getSpecificationProcessor(specType.name().toLowerCase());
        
        if (processor.isPresent()) {
            Log.debug("Using plugin processor for spec type: {}", specType);
            return processor.get().processSpecification(inputFile, filename, context);
        } else {
            Log.debug("No plugin processor found for spec type: {}, using built-in", specType);
            // Fallback to built-in processing
            throw new UnsupportedOperationException("Built-in fallback not implemented in this example");
        }
    }
    
    private void validateWithPlugins(ApiSpecification apiSpec, PluginExecutionContext context) throws Exception {
        List<ValidationPlugin> validators = pluginManager.getValidators("api-spec");
        
        for (ValidationPlugin validator : validators) {
            try {
                ValidationResult result = validator.validate(apiSpec, context);
                if (!result.isValid()) {
                    List<String> errors = result.getErrors().stream()
                        .map(ValidationResult.ValidationIssue::getMessage)
                        .toList();
                    throw new RuntimeException("Validation failed: " + String.join(", ", errors));
                }
                
                // Log warnings
                result.getWarnings().forEach(warning -> 
                    Log.warn("Validation warning: {}", warning.getMessage()));
                    
            } catch (Exception e) {
                Log.warn("Validation plugin {} failed: {}", validator.getValidationType(), e.getMessage());
            }
        }
    }
    
    private McpServerModel generateModelWithPlugins(ApiSpecification apiSpec, String packageName,
                                                  String serverName, String baseUrl, boolean includeAuth,
                                                  PluginExecutionContext context) throws Exception {
        
        // Execute pre-processing plugins
        List<GeneratorPlugin> plugins = pluginManager.getAvailablePlugins();
        for (GeneratorPlugin plugin : plugins) {
            if (plugin.supports("model-generation")) {
                context.setAttribute("apiSpec", apiSpec);
                context.setAttribute("packageName", packageName);
                context.setAttribute("serverName", serverName);
                context.setAttribute("baseUrl", baseUrl);
                context.setAttribute("includeAuth", includeAuth);
                
                PluginResult result = plugin.execute(context);
                if (result.isSuccess()) {
                    Log.debug("Plugin {} executed successfully for model generation", plugin.getId());
                    // Update context with plugin results
                    result.getData().forEach(context::setAttribute);
                }
            }
        }
        
        // Create model with potentially modified data
        return createServerModel(apiSpec, 
            context.getAttribute("packageName", String.class),
            context.getAttribute("serverName", String.class),
            context.getAttribute("baseUrl", String.class),
            context.getAttribute("includeAuth", Boolean.class));
    }
    
    private Map<String, String> generateSourceFilesWithPlugins(McpServerModel serverModel,
                                                             PluginExecutionContext context) throws Exception {
        Map<String, String> sourceFiles = new HashMap<>();
        
        // Get available template processors
        List<TemplateProcessor> processors = pluginManager.getTemplateProcessors("qute");
        
        if (processors.isEmpty()) {
            throw new RuntimeException("No template processors available");
        }
        
        TemplateProcessor processor = processors.get(0); // Use first available
        
        // Process each template
        Map<String, Object> templateData = createTemplateData(serverModel);
        
        // Main server class
        String mainTemplate = loadTemplate("mcp-server-main.java");
        String mainClassContent = processor.processTemplate(mainTemplate, templateData, context);
        sourceFiles.put("src/main/java/" + serverModel.getPackagePath() + "/" + 
            serverModel.getServerClass() + ".java", mainClassContent);
        
        // Tool classes
        for (McpToolModel tool : serverModel.getTools()) {
            String toolTemplate = loadTemplate("mcp-tool.java");
            Map<String, Object> toolData = new HashMap<>(templateData);
            toolData.put("tool", tool);
            
            String toolClassContent = processor.processTemplate(toolTemplate, toolData, context);
            sourceFiles.put("src/main/java/" + serverModel.getPackagePath() + "/tools/" + 
                tool.getClassName() + ".java", toolClassContent);
        }
        
        // Configuration files
        String pomTemplate = loadTemplate("generated-pom.xml");
        String pomContent = processor.processTemplate(pomTemplate, templateData, context);
        sourceFiles.put("pom.xml", pomContent);
        
        return sourceFiles;
    }
    
    private Map<String, Object> createTemplateData(McpServerModel serverModel) {
        Map<String, Object> data = new HashMap<>();
        data.put("model", serverModel);
        data.put("timestamp", System.currentTimeMillis());
        data.put("generatorVersion", "1.0.0-plugin-enabled");
        return data;
    }
    
    private String loadTemplate(String templateName) {
        // This would load from resources - simplified for example
        return "Template content for " + templateName;
    }
    
    private McpServerModel createServerModel(ApiSpecification apiSpec, String packageName,
                                           String serverName, String baseUrl, boolean includeAuth) {
        // Convert ApiSpecification to McpServerModel
        // This is a simplified version - full implementation would mirror the original service
        McpServerModel model = new McpServerModel();
        model.setPackageName(packageName);
        model.setServerName(serverName);
        model.setServerClass(serverName);
        model.setTitle(apiSpec.getTitle());
        model.setDescription(apiSpec.getDescription());
        model.setVersion(apiSpec.getVersion());
        model.setBaseUrl(baseUrl);
        model.setIncludeAuth(includeAuth);
        
        // Convert operations to tools
        List<McpToolModel> tools = apiSpec.getOperations().stream()
            .map(this::convertToMcpTool)
            .toList();
        model.setTools(tools);
        
        return model;
    }
    
    private McpToolModel convertToMcpTool(ApiOperation operation) {
        McpToolModel tool = new McpToolModel();
        tool.setName(operation.getOperationId() != null ? operation.getOperationId() : 
            generateToolName(operation.getPath(), operation.getMethod()));
        tool.setDescription(operation.getDescription());
        tool.setPath(operation.getPath());
        tool.setMethod(operation.getMethod());
        tool.setOperationId(operation.getOperationId());
        tool.setSummary(operation.getSummary());
        
        // Convert parameters
        List<McpParameterModel> parameters = operation.getParameters().stream()
            .map(this::convertToMcpParameter)
            .toList();
        tool.setParameters(parameters);
        
        tool.setResponseTypes(operation.getResponseTypes());
        tool.setSecurityRequirements(operation.getSecurityRequirements());
        
        return tool;
    }
    
    private McpParameterModel convertToMcpParameter(ApiParameter apiParam) {
        McpParameterModel param = new McpParameterModel();
        param.setName(apiParam.getName());
        param.setDescription(apiParam.getDescription());
        param.setType(apiParam.getType());
        param.setRequired(apiParam.isRequired());
        param.setIn(apiParam.getIn());
        param.setExample(apiParam.getExample());
        param.setDefaultValue(apiParam.getDefaultValue());
        return param;
    }
    
    private String generateToolName(String path, String method) {
        String cleanPath = path.replaceAll("[^a-zA-Z0-9_]", "_")
            .replaceAll("_+", "_")
            .replaceAll("^_|_$", "");
        return method.toLowerCase() + "_" + cleanPath;
    }
    
    private byte[] createZipArchive(Map<String, String> files) throws Exception {
        java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
        try (java.util.zip.ZipOutputStream zos = new java.util.zip.ZipOutputStream(baos)) {
            for (Map.Entry<String, String> entry : files.entrySet()) {
                java.util.zip.ZipEntry zipEntry = new java.util.zip.ZipEntry(entry.getKey());
                zos.putNextEntry(zipEntry);
                zos.write(entry.getValue().getBytes(java.nio.charset.StandardCharsets.UTF_8));
                zos.closeEntry();
            }
        }
        return baos.toByteArray();
    }
    
    public List<PluginInfo> getAvailablePlugins() {
        return pluginManager.getAvailablePlugins().stream()
            .map(plugin -> new PluginInfo(
                plugin.getId(),
                plugin.getName(),
                plugin.getVersion(),
                plugin.getDescription(),
                plugin.getConfiguration()
            ))
            .toList();
    }
    
    public static class PluginInfo {
        public final String id;
        public final String name;
        public final String version;
        public final String description;
        public final Map<String, Object> configuration;
        
        public PluginInfo(String id, String name, String version, String description, 
                         Map<String, Object> configuration) {
            this.id = id;
            this.name = name;
            this.version = version;
            this.description = description;
            this.configuration = configuration;
        }
    }
}

// src/main/java/com/example/generator/plugin/builtin/InsomniaSpecProcessor.java
package com.example.generator.plugin.builtin;

import com.example.generator.*;
import com.example.generator.plugin.*;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.enterprise.context.ApplicationScoped;

import java.io.InputStream;
import java.util.*;

@ApplicationScoped
public class InsomniaSpecProcessor implements SpecificationProcessor {
    
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    @Override
    public String getSpecificationType() {
        return "insomnia";
    }
    
    @Override
    public void initialize() throws PluginException {
        // Initialization logic
    }
    
    @Override
    public boolean canProcess(String content, String filename) {
        try {
            JsonNode root = objectMapper.readTree(content);
            
            // Check for Insomnia-specific fields
            if (root.has("_type") && root.get("_type").asText().equals("export")) {
                return true;
            }
            
            if (root.has("resources") && root.has("__export_format")) {
                return true;
            }
            
            // Check filename
            if (filename != null && filename.toLowerCase().contains("insomnia")) {
                return true;
            }
            
            return false;
            
        } catch (Exception e) {
            return false;
        }
    }
    
    @Override
    public ApiSpecification processSpecification(InputStream content, String filename, 
                                               PluginExecutionContext context) throws PluginException {
        try {
            String contentStr = new String(content.readAllBytes());
            JsonNode root = objectMapper.readTree(contentStr);
            
            context.log("INFO", "Processing Insomnia export file: %s", filename);
            
            ApiSpecification apiSpec = new ApiSpecification();
            
            // Extract workspace info
            JsonNode workspace = findWorkspace(root);
            if (workspace != null) {
                apiSpec.setTitle(workspace.has("name") ? workspace.get("name").asText() : "Insomnia API");
                apiSpec.setDescription(workspace.has("description") ? workspace.get("description").asText() : "");
            } else {
                apiSpec.setTitle("Insomnia API");
                apiSpec.setDescription("Imported from Insomnia");
            }
            apiSpec.setVersion("1.0.0");
            
            // Extract base URL from environment
            String baseUrl = extractBaseUrl(root);
            apiSpec.setBaseUrl(baseUrl != null ? baseUrl : "http://localhost:8080");
            
            // Process requests
            List<ApiOperation> operations = processRequests(root, context);
            apiSpec.setOperations(operations);
            
            context.log("INFO", "Processed %d operations from Insomnia export", operations.size());
            
            return apiSpec;
            
        } catch (Exception e) {
            throw new PluginException("insomnia-processor", "process", 
                "Failed to process Insomnia specification", e);
        }
    }
    
    @Override
    public ValidationResult validateSpecification(InputStream content, String filename,
                                                PluginExecutionContext context) throws PluginException {
        try {
            String contentStr = new String(content.readAllBytes());
            JsonNode root = objectMapper.readTree(contentStr);
            
            ValidationResult result = new ValidationResult(true);
            
            if (!canProcess(contentStr, filename)) {
                return result.addError("Not a valid Insomnia export file");
            }
            
            // Check for resources
            if (!root.has("resources")) {
                result.addWarning("No resources found in Insomnia export");
            } else {
                JsonNode resources = root.get("resources");
                if (!resources.isArray() || resources.size() == 0) {
                    result.addWarning("Resources array is empty");
                }
            }
            
            return result;
            
        } catch (Exception e) {
            throw new PluginException("insomnia-processor", "validate", 
                "Failed to validate Insomnia specification", e);
        }
    }
    
    private JsonNode findWorkspace(JsonNode root) {
        if (root.has("resources") && root.get("resources").isArray()) {
            for (JsonNode resource : root.get("resources")) {
                if (resource.has("_type") && resource.get("_type").asText().equals("workspace")) {
                    return resource;
                }
            }
        }
        return null;
    }
    
    private String extractBaseUrl(JsonNode root) {
        if (root.has("resources") && root.get("resources").isArray()) {
            for (JsonNode resource : root.get("resources")) {
                if (resource.has("_type") && resource.get("_type").asText().equals("environment")) {
                    if (resource.has("data") && resource.get("data").has("base_url")) {
                        return resource.get("data").get("base_url").asText();
                    }
                }
            }
        }
        return null;
    }
    
    private List<ApiOperation> processRequests(JsonNode root, PluginExecutionContext context) {
        List<ApiOperation> operations = new ArrayList<>();
        
        if (root.has("resources") && root.get("resources").isArray()) {
            for (JsonNode resource : root.get("resources")) {
                if (resource.has("_type") && resource.get("_type").asText().equals("request")) {
                    try {
                        ApiOperation operation = processRequest(resource);
                        if (operation != null) {
                            operations.add(operation);
                        }
                    } catch (Exception e) {
                        context.log("WARN", "Failed to process request: %s", e.getMessage());
                    }
                }
            }
        }
        
        return operations;
    }
    
    private ApiOperation processRequest(JsonNode request) {
        ApiOperation operation = new ApiOperation();
        
        // Basic info
        String name = request.has("name") ? request.get("name").asText() : "unnamed_request";
        operation.setOperationId(sanitizeOperationId(name));
        operation.setSummary(name);
        operation.setDescription(request.has("description") ? request.get("description").asText() : "");
        
        // Method
        String method = request.has("method") ? request.get("method").asText() : "GET";
        operation.setMethod(method.toUpperCase());
        
        // URL and path
        String url = request.has("url") ? request.get("url").asText() : "/";
        operation.setPath(extractPath(url));
        
        // Parameters
        List<ApiParameter> parameters = new ArrayList<>();
        
        // URL parameters
        if (request.has("parameters")) {
            processUrlParameters(request.get("parameters"), parameters);
        }
        
        // Headers
        if (request.has("headers")) {
            processHeaders(request.get("headers"), parameters);
        }
        
        // Body
        if (request.has("body")) {
            processBody(request.get("body"), parameters);
        }
        
        operation.setParameters(parameters);
        
        // Default responses
        Map<String, String> responseTypes = new HashMap<>();
        responseTypes.put("200", "Success");
        responseTypes.put("400", "Bad Request");
        responseTypes.put("500", "Internal Server Error");
        operation.setResponseTypes(responseTypes);
        
        return operation;
    }
    
    private String sanitizeOperationId(String name) {
        return name.replaceAll("[^a-zA-Z0-9_]", "_")
                  .replaceAll("_+", "_")
                  .replaceAll("^_|_$", "");
    }
    
    private String extractPath(String url) {
        try {
            java.net.URL parsedUrl = new java.net.URL(url);
            String path = parsedUrl.getPath();
            return path.isEmpty() ? "/" : path;
        } catch (Exception e) {
            // If URL parsing fails, try to extract path manually
            int pathStart = url.indexOf('/', 8); // Skip protocol://
            if (pathStart != -1) {
                int queryStart = url.indexOf('?', pathStart);
                return queryStart != -1 ? url.substring(pathStart, queryStart) : url.substring(pathStart);
            }
            return "/";
        }
    }
    
    private void processUrlParameters(JsonNode parameters, List<ApiParameter> paramList) {
        if (parameters.isArray()) {
            for (JsonNode param : parameters) {
                if (param.has("name") && param.has("value")) {
                    ApiParameter apiParam = new ApiParameter();
                    apiParam.setName(param.get("name").asText());
                    apiParam.setIn("query");
                    apiParam.setRequired(false);
                    apiParam.setType("string");
                    apiParam.setDescription("Query parameter");
                    apiParam.setExample(param.get("value").asText());
                    paramList.add(apiParam);
                }
            }
        }
    }
    
    private void processHeaders(JsonNode headers, List<ApiParameter> paramList) {
        if (headers.isArray()) {
            for (JsonNode header : headers) {
                if (header.has("name") && header.has("value")) {
                    String name = header.get("name").asText();
                    
                    // Skip common headers
                    if (isStandardHeader(name)) {
                        continue;
                    }
                    
                    ApiParameter apiParam = new ApiParameter();
                    apiParam.setName(name);
                    apiParam.setIn("header");
                    apiParam.setRequired(false);
                    apiParam.setType("string");
                    apiParam.setDescription("Header parameter");
                    apiParam.setExample(header.get("value").asText());
                    paramList.add(apiParam);
                }
            }
        }
    }
    
    private void processBody(JsonNode body, List<ApiParameter> paramList) {
        if (body.has("mimeType")) {
            String mimeType = body.get("mimeType").asText();
            
            if ("application/json".equals(mimeType) && body.has("text")) {
                ApiParameter bodyParam = new ApiParameter();
                bodyParam.setName("requestBody");
                bodyParam.setIn("body");
                bodyParam.setRequired(true);
                bodyParam.setType("object");
                bodyParam.setDescription("Request body");
                bodyParam.setExample(body.get("text").asText());
                paramList.add(bodyParam);
            }
        }
    }
    
    private boolean isStandardHeader(String headerName) {
        String lower = headerName.toLowerCase();
        return lower.equals("content-type") || 
               lower.equals("content-length") ||
               lower.equals("host") ||
               lower.equals("user-agent") ||
               lower.equals("accept") ||
               lower.equals("accept-encoding") ||
               lower.equals("connection");
    }
}

// src/main/java/com/example/generator/plugin/builtin/CustomValidationPlugin.java
package com.example.generator.plugin.builtin;

import com.example.generator.McpServerModel;
import com.example.generator.plugin.*;
import jakarta.enterprise.context.ApplicationScoped;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;

@ApplicationScoped
public class CustomValidationPlugin implements ValidationPlugin {
    
    private static final Pattern PACKAGE_NAME_PATTERN = Pattern.compile("^[a-z][a-z0-9_]*(\\.[a-z0-9_]+)*$");
    private static final Pattern CLASS_NAME_PATTERN = Pattern.compile("^[A-Z][a-zA-Z0-9_]*$");
    
    @Override
    public String getValidationType() {
        return "mcp-server-model";
    }
    
    @Override
    public void initialize() throws PluginException {
        // Initialization logic
    }
    
    @Override
    public boolean supports(String validationType) {
        return "mcp-server-model".equalsIgnoreCase(validationType) || 
               "server-model".equalsIgnoreCase(validationType);
    }
    
    @Override
    public ValidationResult validate(Object target, PluginExecutionContext context) throws PluginException {
        if (!(target instanceof McpServerModel)) {
            return new ValidationResult(false).addError("Target is not a McpServerModel");
        }
        
        McpServerModel model = (McpServerModel) target;
        ValidationResult result = new ValidationResult(true);
        
        // Validate package name
        if (model.getPackageName() == null || !PACKAGE_NAME_PATTERN.matcher(model.getPackageName()).matches()) {
            result.addError("Invalid package name format: " + model.getPackageName());
        }
        
        // Validate server name
        if (model.getServerName() == null || !CLASS_NAME_PATTERN.matcher(model.getServerName()).matches()) {
            result.addError("Invalid server name format: " + model.getServerName());
        }
        
        // Validate tools
        if (model.getTools() == null || model.getTools().isEmpty()) {
            result.addWarning("No tools defined in the server model");
        } else {
            // Check for duplicate tool names
            List<String> toolNames = model.getTools().stream()
                .map(tool -> tool.getName())
                .toList();
            
            Set<String> uniqueNames = new HashSet<>(toolNames);
            if (uniqueNames.size() != toolNames.size()) {
                result.addError("Duplicate tool names detected");
            }
        }
        
        // Validate base URL
        if (model.getBaseUrl() != null) {
            try {
                new java.net.URL(model.getBaseUrl());
            } catch (Exception e) {
                result.addWarning("Base URL may not be valid: " + model.getBaseUrl());
            }
        }
        
        return result;
    }
    
    @Override
    public List<ValidationRule> getValidationRules() {
        return Arrays.asList(
            new ValidationRule("package-name-valid", "Package name must be valid Java package name", 
                ValidationRule.ValidationSeverity.ERROR, this::validatePackageName),
            new ValidationRule("server-name-valid", "Server name must be valid Java class name", 
                ValidationRule.ValidationSeverity.ERROR, this::validateServerName),
            new ValidationRule("tools-present", "At least one tool should be defined", 
                ValidationRule.ValidationSeverity.WARNING, this::validateToolsPresent),
            new ValidationRule("base-url-valid", "Base URL should be a valid URL", 
                ValidationRule.ValidationSeverity.WARNING, this::validateBaseUrl)
        );
    }
    
    private ValidationResult validatePackageName(Object target, PluginExecutionContext context) {
        McpServerModel model = (McpServerModel) target;
        boolean isValid = model.getPackageName() != null && 
                         PACKAGE_NAME_PATTERN.matcher(model.getPackageName()).matches();
        ValidationResult result = new ValidationResult(isValid);
        if (!isValid) {
            result.addError("Invalid package name: " + model.getPackageName());
        }
        return result;
    }
    
    private ValidationResult validateServerName(Object target, PluginExecutionContext context) {
        McpServerModel model = (McpServerModel) target;
        boolean isValid = model.getServerName() != null && 
                         CLASS_NAME_PATTERN.matcher(model.getServerName()).matches();
        ValidationResult result = new ValidationResult(isValid);
        if (!isValid) {
            result.addError("Invalid server name: " + model.getServerName());
        }
        return result;
    }
    
    private ValidationResult validateToolsPresent(Object target, PluginExecutionContext context) {
        McpServerModel model = (McpServerModel) target;
        ValidationResult result = new ValidationResult(true);
        if (model.getTools() == null || model.getTools().isEmpty()) {
            result.addWarning("No tools defined in server model");
        }
        return result;
    }
    
    private ValidationResult validateBaseUrl(Object target, PluginExecutionContext context) {
        McpServerModel model = (McpServerModel) target;
        ValidationResult result = new ValidationResult(true);
        if (model.getBaseUrl() != null) {
            try {
                new java.net.URL(model.getBaseUrl());
            } catch (Exception e) {
                result.addWarning("Base URL may not be valid: " + model.getBaseUrl());
            }
        }
        return result;
    }
}