// ============================================================================
// DESIGNER SERVICE - WEBSOCKET CLIENT & ERROR HANDLING
// ============================================================================

package io.kayys.wayang.designer.client;

import io.kayys.wayang.workflow.domain.*;
import io.quarkus.websockets.next.WebSocketClient;
import io.quarkus.websockets.next.OnTextMessage;
import io.quarkus.websockets.next.OnOpen;
import io.quarkus.websockets.next.OnClose;
import io.quarkus.websockets.next.OnError;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.jboss.logging.Logger;

import java.net.URI;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

/**
 * WebSocket Client for Workflow Collaboration
 * Connects Designer Service to Workflow Service WebSocket
 */
@ApplicationScoped
public class DesignerWebSocketClient {
    
    private static final Logger LOG = Logger.getLogger(DesignerWebSocketClient.class);
    
    // Active connections: workflowId -> WebSocketConnection
    private final Map<String, CollaborationConnection> activeConnections = 
            new ConcurrentHashMap<>();
    
    @Inject
    WebSocketConnectionFactory connectionFactory;
    
    /**
     * Connect to workflow collaboration WebSocket
     */
    public Uni<Void> connect(String workflowId, String userId, String tenantId,
                              CollaborationHandler handler) {
        
        LOG.infof("Designer: Connecting to collaboration WS for workflow %s", workflowId);
        
        return Uni.createFrom().item(() -> {
            String wsUrl = buildWebSocketUrl(workflowId);
            
            CollaborationConnection connection = connectionFactory.create(
                wsUrl, userId, tenantId, handler);
            
            activeConnections.put(workflowId, connection);
            
            return connection;
        })
        .flatMap(CollaborationConnection::connect)
        .invoke(v -> LOG.infof("Designer: Connected to WS for workflow %s", workflowId));
    }
    
    /**
     * Disconnect from workflow
     */
    public Uni<Void> disconnect(String workflowId) {
        LOG.infof("Designer: Disconnecting from workflow %s", workflowId);
        
        CollaborationConnection connection = activeConnections.remove(workflowId);
        if (connection != null) {
            return connection.close();
        }
        return Uni.createFrom().voidItem();
    }
    
    /**
     * Send cursor position
     */
    public Uni<Void> sendCursorPosition(String workflowId, double x, double y) {
        return sendMessage(workflowId, MessageType.CURSOR_MOVE, 
            Map.of("x", x, "y", y));
    }
    
    /**
     * Send node move
     */
    public Uni<Void> sendNodeMove(String workflowId, String nodeId, PointDTO position) {
        return sendMessage(workflowId, MessageType.NODE_MOVE,
            Map.of("nodeId", nodeId, "position", position));
    }
    
    /**
     * Send node lock request
     */
    public Uni<Void> sendNodeLock(String workflowId, String nodeId) {
        return sendMessage(workflowId, MessageType.NODE_LOCK, nodeId);
    }
    
    /**
     * Send node unlock request
     */
    public Uni<Void> sendNodeUnlock(String workflowId, String nodeId) {
        return sendMessage(workflowId, MessageType.NODE_UNLOCK, nodeId);
    }
    
    /**
     * Send node update
     */
    public Uni<Void> sendNodeUpdate(String workflowId, String nodeId, 
                                     Map<String, Object> changes) {
        return sendMessage(workflowId, MessageType.NODE_UPDATE,
            Map.of("nodeId", nodeId, "changes", changes));
    }
    
    /**
     * Send connection add
     */
    public Uni<Void> sendConnectionAdd(String workflowId, ConnectionPayload connection) {
        return sendMessage(workflowId, MessageType.CONNECTION_ADD, connection);
    }
    
    /**
     * Send generic message
     */
    private Uni<Void> sendMessage(String workflowId, MessageType type, Object payload) {
        CollaborationConnection connection = activeConnections.get(workflowId);
        if (connection == null) {
            return Uni.createFrom().failure(
                new IllegalStateException("Not connected to workflow: " + workflowId));
        }
        
        CollaborationMessage message = new CollaborationMessage();
        message.setType(type);
        message.setPayload(payload instanceof Map ? 
            (Map<String, Object>) payload : 
            Map.of("data", payload));
        
        return connection.send(message);
    }
    
    /**
     * Build WebSocket URL
     */
    private String buildWebSocketUrl(String workflowId) {
        String baseUrl = System.getenv()
            .getOrDefault("WORKFLOW_SERVICE_WS_URL", "ws://localhost:8081");
        return String.format("%s/ws/workflows/%s", baseUrl, workflowId);
    }
}

/**
 * CollaborationConnection - Represents an active WebSocket connection
 */
@WebSocketClient(path = "/ws/workflows/{workflowId}")
public class CollaborationConnection {
    
    private static final Logger LOG = Logger.getLogger(CollaborationConnection.class);
    
    private final String workflowId;
    private final String userId;
    private final String tenantId;
    private final CollaborationHandler handler;
    
    private WebSocketConnection connection;
    private boolean connected = false;
    
    public CollaborationConnection(String workflowId, String userId, 
                                    String tenantId, CollaborationHandler handler) {
        this.workflowId = workflowId;
        this.userId = userId;
        this.tenantId = tenantId;
        this.handler = handler;
    }
    
    @OnOpen
    public void onOpen(WebSocketConnection connection) {
        this.connection = connection;
        this.connected = true;
        LOG.infof("WS connected: workflow=%s, user=%s", workflowId, userId);
        handler.onConnected(workflowId);
    }
    
    @OnTextMessage
    public void onMessage(String message) {
        LOG.debugf("WS message received: workflow=%s", workflowId);
        
        try {
            CollaborationEvent event = JsonUtils.fromJson(message, 
                CollaborationEvent.class);
            
            // Route event to handler
            switch (event.getType()) {
                case USER_JOINED -> handler.onUserJoined(event);
                case USER_LEFT -> handler.onUserLeft(event);
                case CURSOR_MOVED -> handler.onCursorMoved(event);
                case NODE_MOVED -> handler.onNodeMoved(event);
                case NODE_LOCKED -> handler.onNodeLocked(event);
                case NODE_UNLOCKED -> handler.onNodeUnlocked(event);
                case NODE_UPDATED -> handler.onNodeUpdated(event);
                case CONNECTION_ADDED -> handler.onConnectionAdded(event);
                case CONNECTION_DELETED -> handler.onConnectionDeleted(event);
                case SELECTION_CHANGED -> handler.onSelectionChanged(event);
                case LOCK_FAILED -> handler.onLockFailed(event);
                case ERROR -> handler.onError(event);
                default -> LOG.warnf("Unknown event type: %s", event.getType());
            }
        } catch (Exception e) {
            LOG.errorf(e, "Failed to process WS message: %s", message);
            handler.onError(buildErrorEvent(e));
        }
    }
    
    @OnClose
    public void onClose() {
        this.connected = false;
        LOG.infof("WS disconnected: workflow=%s", workflowId);
        handler.onDisconnected(workflowId);
    }
    
    @OnError
    public void onError(Throwable error) {
        LOG.errorf(error, "WS error: workflow=%s", workflowId);
        handler.onError(buildErrorEvent(error));
    }
    
    /**
     * Connect to WebSocket
     */
    public Uni<Void> connect() {
        // Connection is handled by @OnOpen
        return Uni.createFrom().voidItem();
    }
    
    /**
     * Send message
     */
    public Uni<Void> send(CollaborationMessage message) {
        if (!connected || connection == null) {
            return Uni.createFrom().failure(
                new IllegalStateException("Not connected"));
        }
        
        String json = JsonUtils.toJson(message);
        connection.sendText(json);
        return Uni.createFrom().voidItem();
    }
    
    /**
     * Close connection
     */
    public Uni<Void> close() {
        if (connection != null) {
            connection.close();
        }
        return Uni.createFrom().voidItem();
    }
    
    private CollaborationEvent buildErrorEvent(Throwable error) {
        return CollaborationEvent.builder()
            .type(EventType.ERROR)
            .userId(userId)
            .workflowId(workflowId)
            .payload(Map.of("error", error.getMessage()))
            .build();
    }
}

/**
 * CollaborationHandler - Callback interface for handling WebSocket events
 */
public interface CollaborationHandler {
    
    void onConnected(String workflowId);
    void onDisconnected(String workflowId);
    
    void onUserJoined(CollaborationEvent event);
    void onUserLeft(CollaborationEvent event);
    
    void onCursorMoved(CollaborationEvent event);
    void onNodeMoved(CollaborationEvent event);
    void onNodeLocked(CollaborationEvent event);
    void onNodeUnlocked(CollaborationEvent event);
    void onLockFailed(CollaborationEvent event);
    
    void onNodeUpdated(CollaborationEvent event);
    void onConnectionAdded(CollaborationEvent event);
    void onConnectionDeleted(CollaborationEvent event);
    
    void onSelectionChanged(CollaborationEvent event);
    void onError(CollaborationEvent event);
    
    /**
     * Default implementation (no-op)
     */
    static CollaborationHandler noop() {
        return new CollaborationHandler() {
            @Override public void onConnected(String workflowId) {}
            @Override public void onDisconnected(String workflowId) {}
            @Override public void onUserJoined(CollaborationEvent event) {}
            @Override public void onUserLeft(CollaborationEvent event) {}
            @Override public void onCursorMoved(CollaborationEvent event) {}
            @Override public void onNodeMoved(CollaborationEvent event) {}
            @Override public void onNodeLocked(CollaborationEvent event) {}
            @Override public void onNodeUnlocked(CollaborationEvent event) {}
            @Override public void onLockFailed(CollaborationEvent event) {}
            @Override public void onNodeUpdated(CollaborationEvent event) {}
            @Override public void onConnectionAdded(CollaborationEvent event) {}
            @Override public void onConnectionDeleted(CollaborationEvent event) {}
            @Override public void onSelectionChanged(CollaborationEvent event) {}
            @Override public void onError(CollaborationEvent event) {}
        };
    }
}

// ============================================================================
// ERROR HANDLING INFRASTRUCTURE
// ============================================================================

package io.kayys.wayang.common.error;

import io.kayys.wayang.common.audit.AuditService;
import io.kayys.wayang.common.audit.AuditEvent;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.jboss.logging.Logger;

import java.util.Map;

/**
 * ErrorHandlerService - Centralized error handling with audit
 */
@ApplicationScoped
public class ErrorHandlerService {
    
    private static final Logger LOG = Logger.getLogger(ErrorHandlerService.class);
    
    @Inject
    AuditService auditService;
    
    /**
     * Handle create error
     */
    public <T, I> Uni<T> handleCreateError(Throwable error, I input, 
                                            String tenantId, String userId) {
        
        LOG.errorf(error, "Create operation failed");
        
        // Audit error
        auditService.log(AuditEvent.builder()
            .type("CREATE_FAILED")
            .entityType(input.getClass().getSimpleName())
            .userId(userId)
            .tenantId(tenantId)
            .metadata(Map.of(
                "error", error.getClass().getSimpleName(),
                "message", error.getMessage()
            ))
            .build());
        
        // Transform to appropriate exception
        return Uni.createFrom().failure(transformException(error));
    }
    
    /**
     * Handle update error
     */
    public <T, I> Uni<T> handleUpdateError(Throwable error, String id, I input,
                                            String tenantId, String userId) {
        
        LOG.errorf(error, "Update operation failed: id=%s", id);
        
        // Audit error
        auditService.log(AuditEvent.builder()
            .type("UPDATE_FAILED")
            .entityId(id)
            .userId(userId)
            .tenantId(tenantId)
            .metadata(Map.of(
                "error", error.getClass().getSimpleName(),
                "message", error.getMessage()
            ))
            .build());
        
        return Uni.createFrom().failure(transformException(error));
    }
    
    /**
     * Handle delete error
     */
    public void handleDeleteError(Throwable error, String id, String tenantId) {
        LOG.errorf(error, "Delete operation failed: id=%s", id);
        
        // Audit error
        auditService.log(AuditEvent.builder()
            .type("DELETE_FAILED")
            .entityId(id)
            .tenantId(tenantId)
            .metadata(Map.of(
                "error", error.getClass().getSimpleName(),
                "message", error.getMessage()
            ))
            .build());
    }
    
    /**
     * Handle query error
     */
    public <T> Uni<T> handleQueryError(Throwable error, String id, String tenantId) {
        LOG.errorf(error, "Query operation failed: id=%s", id);
        
        // Audit error
        auditService.log(AuditEvent.builder()
            .type("QUERY_FAILED")
            .entityId(id)
            .tenantId(tenantId)
            .metadata(Map.of(
                "error", error.getClass().getSimpleName(),
                "message", error.getMessage()
            ))
            .build());
        
        return Uni.createFrom().failure(transformException(error));
    }
    
    /**
     * Handle list error
     */
    public <T, F> Uni<T> handleListError(Throwable error, String tenantId, F filter) {
        LOG.errorf(error, "List operation failed");
        return Uni.createFrom().failure(transformException(error));
    }
    
    /**
     * Handle compare error
     */
    public <T> Uni<T> handleCompareError(Throwable error, String baseId, 
                                          String targetId, String tenantId) {
        LOG.errorf(error, "Compare operation failed: base=%s, target=%s", 
            baseId, targetId);
        return Uni.createFrom().failure(transformException(error));
    }
    
    /**
     * Handle node operations error
     */
    public <T, I> Uni<T> handleNodeAddError(Throwable error, String workflowId,
                                             I input, String tenantId, String userId) {
        LOG.errorf(error, "Node add failed: workflow=%s", workflowId);
        
        auditService.log(AuditEvent.builder()
            .type("NODE_ADD_FAILED")
            .entityId(workflowId)
            .userId(userId)
            .tenantId(tenantId)
            .metadata(Map.of("error", error.getMessage()))
            .build());
        
        return Uni.createFrom().failure(transformException(error));
    }
    
    /**
     * Handle lock error
     */
    public <T> Uni<T> handleLockError(Throwable error, String workflowId,
                                       String nodeId, String userId, String tenantId) {
        LOG.errorf(error, "Lock failed: workflow=%s, node=%s", workflowId, nodeId);
        
        auditService.log(AuditEvent.builder()
            .type("LOCK_FAILED")
            .entityId(workflowId)
            .userId(userId)
            .tenantId(tenantId)
            .metadata(Map.of("nodeId", nodeId, "error", error.getMessage()))
            .build());
        
        return Uni.createFrom().failure(transformException(error));
    }
    
    /**
     * Handle unlock error
     */
    public void handleUnlockError(Throwable error, String workflowId,
                                   String nodeId, String userId, String tenantId) {
        LOG.errorf(error, "Unlock failed: workflow=%s, node=%s", workflowId, nodeId);
        
        auditService.log(AuditEvent.builder()
            .type("UNLOCK_FAILED")
            .entityId(workflowId)
            .userId(userId)
            .tenantId(tenantId)
            .metadata(Map.of("nodeId", nodeId, "error", error.getMessage()))
            .build());
    }
    
    /**
     * Transform exception to appropriate type
     */
    private Throwable transformException(Throwable error) {
        // Already a domain exception
        if (error instanceof DomainException) {
            return error;
        }
        
        // Database errors
        if (error.getMessage().contains("constraint")) {
            return new ValidationException("Constraint violation: " + error.getMessage());
        }
        
        // Wrap as internal error
        return new InternalException("Internal error: " + error.getMessage(), error);
    }
}

// ============================================================================
// CUSTOM EXCEPTIONS
// ============================================================================

/**
 * Base domain exception
 */
public abstract class DomainException extends RuntimeException {
    
    private final String code;
    
    public DomainException(String code, String message) {
        super(message);
        this.code = code;
    }
    
    public DomainException(String code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }
    
    public String getCode() {
        return code;
    }
}

/**
 * Workflow not found
 */
public class WorkflowNotFoundException extends DomainException {
    public WorkflowNotFoundException(String message) {
        super("WORKFLOW_NOT_FOUND", message);
    }
}

/**
 * Workflow locked
 */
public class WorkflowLockedException extends DomainException {
    public WorkflowLockedException(String message) {
        super("WORKFLOW_LOCKED", message);
    }
}

/**
 * Workflow deletion exception
 */
public class WorkflowDeletionException extends DomainException {
    public WorkflowDeletionException(String message) {
        super("WORKFLOW_DELETION_ERROR", message);
    }
}

/**
 * Node not found
 */
public class NodeNotFoundException extends DomainException {
    public NodeNotFoundException(String message) {
        super("NODE_NOT_FOUND", message);
    }
}

/**
 * Node locked
 */
public class NodeLockedException extends DomainException {
    public NodeLockedException(String message) {
        super("NODE_LOCKED", message);
    }
}

/**
 * Validation exception
 */
public class ValidationException extends DomainException {
    public ValidationException(String message) {
        super("VALIDATION_ERROR", message);
    }
}

/**
 * Internal exception
 */
public class InternalException extends DomainException {
    public InternalException(String message, Throwable cause) {
        super("INTERNAL_ERROR", message, cause);
    }
}


// ============================================================================
// WORKFLOW SERVICE - SERVICE LAYER IMPLEMENTATION
// ============================================================================

package io.kayys.wayang.workflow.service;

import io.kayys.wayang.workflow.domain.*;
import io.kayys.wayang.workflow.entity.WorkflowEntity;
import io.kayys.wayang.workflow.repository.WorkflowRepository;
import io.kayys.wayang.common.audit.AuditService;
import io.kayys.wayang.common.audit.AuditEvent;
import io.kayys.wayang.common.error.*;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.transaction.Transactional;
import org.jboss.logging.Logger;

import java.time.Instant;
import java.util.*;

/**
 * WorkflowCommandService - Handles write operations with audit
 */
@ApplicationScoped
public class WorkflowCommandService {
    
    private static final Logger LOG = Logger.getLogger(WorkflowCommandService.class);
    
    @Inject
    WorkflowRepository repository;
    
    @Inject
    WorkflowValidator validator;
    
    @Inject
    AuditService auditService;
    
    @Inject
    WorkflowMapper mapper;
    
    @Inject
    ErrorHandlerService errorHandler;
    
    /**
     * Create new workflow with validation and audit
     */
    @Transactional
    public Uni<WorkflowDTO> create(CreateWorkflowInput input, String tenantId, String userId) {
        LOG.infof("Creating workflow: name=%s, tenant=%s, user=%s", 
            input.getName(), tenantId, userId);
        
        return Uni.createFrom().item(() -> {
            // Validate input
            validator.validateCreate(input);
            
            // Create entity
            WorkflowEntity entity = new WorkflowEntity();
            entity.setId(UUID.randomUUID());
            entity.setVersion("1.0.0");
            entity.setName(input.getName());
            entity.setDescription(input.getDescription());
            entity.setStatus(WorkflowStatus.DRAFT);
            entity.setTenantId(tenantId);
            entity.setCreatedBy(userId);
            entity.setCreatedAt(Instant.now());
            entity.setUpdatedAt(Instant.now());
            
            // Set components
            entity.setLogic(mapper.toLogicEntity(input.getLogic()));
            entity.setUi(mapper.toUIEntity(input.getUi()));
            entity.setRuntime(mapper.toRuntimeEntity(input.getRuntime()));
            entity.setTags(input.getTags());
            entity.setMetadata(input.getMetadata());
            
            return entity;
        })
        .flatMap(entity -> repository.persist(entity))
        .invoke(entity -> {
            // Audit trail
            auditService.log(AuditEvent.builder()
                .type("WORKFLOW_CREATED")
                .entityType("Workflow")
                .entityId(entity.getId().toString())
                .userId(userId)
                .tenantId(tenantId)
                .metadata(Map.of(
                    "name", entity.getName(),
                    "version", entity.getVersion()
                ))
                .build());
        })
        .map(mapper::toDTO)
        .onFailure().recoverWithUni(throwable -> {
            LOG.errorf(throwable, "Failed to create workflow: %s", input.getName());
            return errorHandler.handleCreateError(throwable, input, tenantId, userId);
        });
    }
    
    /**
     * Update workflow with optimistic locking and audit
     */
    @Transactional
    public Uni<WorkflowDTO> update(String id, UpdateWorkflowInput input, 
                                     String tenantId, String userId) {
        
        LOG.infof("Updating workflow: id=%s, tenant=%s, user=%s", id, tenantId, userId);
        
        return repository.findByIdAndTenant(UUID.fromString(id), tenantId)
            .onItem().ifNull().failWith(() -> 
                new WorkflowNotFoundException("Workflow not found: " + id))
            .invoke(entity -> {
                // Validate update
                validator.validateUpdate(entity, input);
                
                // Check if locked by another user
                if (entity.isLocked() && !entity.getLockedBy().equals(userId)) {
                    throw new WorkflowLockedException(
                        "Workflow locked by: " + entity.getLockedBy());
                }
            })
            .invoke(entity -> {
                // Apply updates
                if (input.getName() != null) {
                    entity.setName(input.getName());
                }
                if (input.getDescription() != null) {
                    entity.setDescription(input.getDescription());
                }
                if (input.getLogic() != null) {
                    entity.setLogic(mapper.toLogicEntity(input.getLogic()));
                }
                if (input.getUi() != null) {
                    entity.setUi(mapper.toUIEntity(input.getUi()));
                }
                if (input.getRuntime() != null) {
                    entity.setRuntime(mapper.toRuntimeEntity(input.getRuntime()));
                }
                if (input.getTags() != null) {
                    entity.setTags(input.getTags());
                }
                
                entity.setUpdatedAt(Instant.now());
                entity.setLastModifiedBy(userId);
                entity.setStatus(WorkflowStatus.DRAFT); // Reset to draft on update
            })
            .flatMap(entity -> repository.persist(entity))
            .invoke(entity -> {
                // Audit trail
                auditService.log(AuditEvent.builder()
                    .type("WORKFLOW_UPDATED")
                    .entityType("Workflow")
                    .entityId(entity.getId().toString())
                    .userId(userId)
                    .tenantId(tenantId)
                    .changes(mapper.buildChangeSet(entity, input))
                    .build());
            })
            .map(mapper::toDTO)
            .onFailure().recoverWithUni(throwable -> {
                LOG.errorf(throwable, "Failed to update workflow: %s", id);
                return errorHandler.handleUpdateError(throwable, id, input, tenantId, userId);
            });
    }
    
    /**
     * Delete workflow with cascade and audit
     */
    @Transactional
    public Uni<Boolean> delete(String id, String tenantId) {
        LOG.infof("Deleting workflow: id=%s, tenant=%s", id, tenantId);
        
        return repository.findByIdAndTenant(UUID.fromString(id), tenantId)
            .onItem().ifNull().failWith(() -> 
                new WorkflowNotFoundException("Workflow not found: " + id))
            .invoke(entity -> {
                // Validate deletion
                if (entity.getStatus() == WorkflowStatus.PUBLISHED) {
                    throw new WorkflowDeletionException(
                        "Cannot delete published workflow. Archive it first.");
                }
            })
            .flatMap(entity -> repository.delete(entity)
                .map(v -> true))
            .invoke(deleted -> {
                // Audit trail
                auditService.log(AuditEvent.builder()
                    .type("WORKFLOW_DELETED")
                    .entityType("Workflow")
                    .entityId(id)
                    .tenantId(tenantId)
                    .build());
            })
            .onFailure().recoverWithItem(throwable -> {
                LOG.errorf(throwable, "Failed to delete workflow: %s", id);
                errorHandler.handleDeleteError(throwable, id, tenantId);
                return false;
            });
    }
    
    /**
     * Add node to workflow with validation
     */
    @Transactional
    public Uni<NodeDTO> addNode(String workflowId, NodeInput input, 
                                 String tenantId, String userId) {
        
        LOG.infof("Adding node to workflow: workflow=%s, type=%s", 
            workflowId, input.getType());
        
        return repository.findByIdAndTenant(UUID.fromString(workflowId), tenantId)
            .onItem().ifNull().failWith(() -> 
                new WorkflowNotFoundException("Workflow not found: " + workflowId))
            .invoke(entity -> {
                // Validate node
                validator.validateNode(entity, input);
                
                // Create node
                NodeEntity node = new NodeEntity();
                node.setId(UUID.randomUUID().toString());
                node.setType(input.getType());
                node.setName(input.getName());
                node.setProperties(input.getProperties());
                node.setMetadata(input.getMetadata());
                node.setCreatedAt(Instant.now());
                
                // Add to logic
                if (entity.getLogic() == null) {
                    entity.setLogic(new LogicEntity());
                }
                entity.getLogic().getNodes().add(node);
                entity.setUpdatedAt(Instant.now());
                entity.setStatus(WorkflowStatus.DRAFT);
            })
            .flatMap(entity -> repository.persist(entity))
            .map(entity -> {
                // Find the added node
                NodeEntity node = entity.getLogic().getNodes().stream()
                    .filter(n -> n.getType().equals(input.getType()) && 
                                 n.getName().equals(input.getName()))
                    .findFirst()
                    .orElseThrow();
                return mapper.toNodeDTO(node);
            })
            .invoke(node -> {
                // Audit trail
                auditService.log(AuditEvent.builder()
                    .type("NODE_ADDED")
                    .entityType("Workflow")
                    .entityId(workflowId)
                    .userId(userId)
                    .tenantId(tenantId)
                    .metadata(Map.of(
                        "nodeId", node.getId(),
                        "nodeType", node.getType(),
                        "nodeName", node.getName()
                    ))
                    .build());
            })
            .onFailure().recoverWithUni(throwable -> {
                LOG.errorf(throwable, "Failed to add node: %s", input.getName());
                return errorHandler.handleNodeAddError(
                    throwable, workflowId, input, tenantId, userId);
            });
    }
    
    /**
     * Lock node for editing
     */
    @Transactional
    public Uni<NodeLockDTO> lockNode(String workflowId, String nodeId, 
                                      String userId, String tenantId) {
        
        LOG.infof("Locking node: workflow=%s, node=%s, user=%s", 
            workflowId, nodeId, userId);
        
        return repository.findByIdAndTenant(UUID.fromString(workflowId), tenantId)
            .onItem().ifNull().failWith(() -> 
                new WorkflowNotFoundException("Workflow not found: " + workflowId))
            .invoke(entity -> {
                // Find node
                NodeEntity node = findNode(entity, nodeId);
                
                // Check if already locked
                if (node.isLocked() && !node.getLockedBy().equals(userId)) {
                    throw new NodeLockedException(
                        "Node locked by: " + node.getLockedBy());
                }
                
                // Lock node
                node.setLocked(true);
                node.setLockedBy(userId);
                node.setLockedAt(Instant.now());
            })
            .flatMap(entity -> repository.persist(entity))
            .map(entity -> {
                NodeEntity node = findNode(entity, nodeId);
                NodeLockDTO lock = new NodeLockDTO();
                lock.setNodeId(nodeId);
                lock.setUserId(userId);
                lock.setLockedAt(node.getLockedAt());
                lock.setExpiresAt(node.getLockedAt().plusSeconds(300)); // 5 min
                return lock;
            })
            .invoke(lock -> {
                // Audit trail
                auditService.log(AuditEvent.builder()
                    .type("NODE_LOCKED")
                    .entityType("Workflow")
                    .entityId(workflowId)
                    .userId(userId)
                    .tenantId(tenantId)
                    .metadata(Map.of("nodeId", nodeId))
                    .build());
            })
            .onFailure().recoverWithUni(throwable -> {
                LOG.errorf(throwable, "Failed to lock node: %s", nodeId);
                return errorHandler.handleLockError(
                    throwable, workflowId, nodeId, userId, tenantId);
            });
    }
    
    /**
     * Unlock node
     */
    @Transactional
    public Uni<Boolean> unlockNode(String workflowId, String nodeId, 
                                    String userId, String tenantId) {
        
        LOG.infof("Unlocking node: workflow=%s, node=%s, user=%s", 
            workflowId, nodeId, userId);
        
        return repository.findByIdAndTenant(UUID.fromString(workflowId), tenantId)
            .onItem().ifNull().failWith(() -> 
                new WorkflowNotFoundException("Workflow not found: " + workflowId))
            .invoke(entity -> {
                // Find node
                NodeEntity node = findNode(entity, nodeId);
                
                // Check ownership
                if (node.isLocked() && !node.getLockedBy().equals(userId)) {
                    throw new NodeLockedException(
                        "Node locked by different user: " + node.getLockedBy());
                }
                
                // Unlock node
                node.setLocked(false);
                node.setLockedBy(null);
                node.setLockedAt(null);
            })
            .flatMap(entity -> repository.persist(entity))
            .map(entity -> true)
            .invoke(success -> {
                // Audit trail
                auditService.log(AuditEvent.builder()
                    .type("NODE_UNLOCKED")
                    .entityType("Workflow")
                    .entityId(workflowId)
                    .userId(userId)
                    .tenantId(tenantId)
                    .metadata(Map.of("nodeId", nodeId))
                    .build());
            })
            .onFailure().recoverWithItem(throwable -> {
                LOG.errorf(throwable, "Failed to unlock node: %s", nodeId);
                errorHandler.handleUnlockError(
                    throwable, workflowId, nodeId, userId, tenantId);
                return false;
            });
    }
    
    /**
     * Helper: Find node in workflow
     */
    private NodeEntity findNode(WorkflowEntity workflow, String nodeId) {
        return workflow.getLogic().getNodes().stream()
            .filter(n -> n.getId().equals(nodeId))
            .findFirst()
            .orElseThrow(() -> new NodeNotFoundException("Node not found: " + nodeId));
    }
}

/**
 * WorkflowQueryService - Handles read operations
 */
@ApplicationScoped
public class WorkflowQueryService {
    
    private static final Logger LOG = Logger.getLogger(WorkflowQueryService.class);
    
    @Inject
    WorkflowRepository repository;
    
    @Inject
    WorkflowMapper mapper;
    
    @Inject
    ErrorHandlerService errorHandler;
    
    /**
     * Find workflow by ID
     */
    public Uni<WorkflowDTO> findById(String id, String tenantId) {
        LOG.debugf("Finding workflow: id=%s, tenant=%s", id, tenantId);
        
        return repository.findByIdAndTenant(UUID.fromString(id), tenantId)
            .onItem().ifNull().failWith(() -> 
                new WorkflowNotFoundException("Workflow not found: " + id))
            .map(mapper::toDTO)
            .onFailure().recoverWithUni(throwable -> {
                LOG.errorf(throwable, "Failed to find workflow: %s", id);
                return errorHandler.handleQueryError(throwable, id, tenantId);
            });
    }
    
    /**
     * Find all workflows with filtering and pagination
     */
    public Uni<WorkflowConnection> findAll(String tenantId, 
                                           WorkflowFilterInput filter,
                                           PageInput page) {
        
        LOG.debugf("Finding workflows: tenant=%s, filter=%s", tenantId, filter);
        
        return repository.findAllByTenant(tenantId, filter, page)
            .map(result -> {
                WorkflowConnection connection = new WorkflowConnection();
                connection.setNodes(result.getContent().stream()
                    .map(mapper::toDTO)
                    .toList());
                connection.setTotalCount(result.getTotalCount());
                connection.setPageInfo(buildPageInfo(result, page));
                return connection;
            })
            .onFailure().recoverWithUni(throwable -> {
                LOG.errorf(throwable, "Failed to find workflows");
                return errorHandler.handleListError(throwable, tenantId, filter);
            });
    }
    
    /**
     * Compare two workflows
     */
    public Uni<WorkflowDiffDTO> compareWorkflows(String baseId, String targetId, 
                                                   String tenantId) {
        
        LOG.infof("Comparing workflows: base=%s, target=%s", baseId, targetId);
        
        return Uni.combine().all()
            .unis(
                repository.findByIdAndTenant(UUID.fromString(baseId), tenantId),
                repository.findByIdAndTenant(UUID.fromString(targetId), tenantId)
            )
            .asTuple()
            .onItem().ifNull().failWith(() -> 
                new WorkflowNotFoundException("One or both workflows not found"))
            .map(tuple -> {
                WorkflowEntity base = tuple.getItem1();
                WorkflowEntity target = tuple.getItem2();
                
                // Perform diff
                return performDiff(base, target);
            })
            .onFailure().recoverWithUni(throwable -> {
                LOG.errorf(throwable, "Failed to compare workflows");
                return errorHandler.handleCompareError(
                    throwable, baseId, targetId, tenantId);
            });
    }
    
    private WorkflowDiffDTO performDiff(WorkflowEntity base, WorkflowEntity target) {
        // Implementation delegated to DiffService
        // This is a simplified version
        WorkflowDiffDTO diff = new WorkflowDiffDTO();
        diff.setBaseId(base.getId().toString());
        diff.setTargetId(target.getId().toString());
        diff.setBaseVersion(base.getVersion());
        diff.setTargetVersion(target.getVersion());
        // ... diff logic
        return diff;
    }
    
    private PageInfo buildPageInfo(PageResult<?> result, PageInput page) {
        PageInfo info = new PageInfo();
        info.setHasNextPage(result.hasNextPage());
        info.setHasPreviousPage(result.hasPreviousPage());
        return info;
    }
}

/**
 * CollaborationService - Handles real-time collaboration
 */
@ApplicationScoped
public class CollaborationService {
    
    private static final Logger LOG = Logger.getLogger(CollaborationService.class);
    
    @Inject
    WorkflowCommandService commandService;
    
    @Inject
    AuditService auditService;
    
    /**
     * User joined workflow
     */
    public Uni<CollaborationEvent> userJoined(String workflowId, String userId, 
                                               String tenantId) {
        
        LOG.infof("User joined: workflow=%s, user=%s", workflowId, userId);
        
        return Uni.createFrom().item(() -> {
            // Audit
            auditService.log(AuditEvent.builder()
                .type("USER_JOINED")
                .entityType("Workflow")
                .entityId(workflowId)
                .userId(userId)
                .tenantId(tenantId)
                .build());
            
            // Build event
            return CollaborationEvent.builder()
                .type(EventType.USER_JOINED)
                .userId(userId)
                .workflowId(workflowId)
                .payload(Map.of("userId", userId))
                .build();
        });
    }
    
    /**
     * User left workflow
     */
    public Uni<CollaborationEvent> userLeft(String workflowId, String userId, 
                                             String tenantId) {
        
        LOG.infof("User left: workflow=%s, user=%s", workflowId, userId);
        
        // Release all locks held by user
        return releaseLocks(workflowId, userId, tenantId)
            .map(v -> {
                // Audit
                auditService.log(AuditEvent.builder()
                    .type("USER_LEFT")
                    .entityType("Workflow")
                    .entityId(workflowId)
                    .userId(userId)
                    .tenantId(tenantId)
                    .build());
                
                // Build event
                return CollaborationEvent.builder()
                    .type(EventType.USER_LEFT)
                    .userId(userId)
                    .workflowId(workflowId)
                    .payload(Map.of("userId", userId))
                    .build();
            });
    }
    
    /**
     * Move node
     */
    public Uni<CollaborationEvent> moveNode(String workflowId, String nodeId,
                                             PointDTO position, String userId,
                                             String tenantId) {
        
        LOG.debugf("Moving node: workflow=%s, node=%s, pos=(%f,%f)", 
            workflowId, nodeId, position.getX(), position.getY());
        
        // Update position in database (async)
        return Uni.createFrom().item(() -> {
            // Build event immediately for low latency
            NodeMovePayload payload = new NodeMovePayload();
            payload.setNodeId(nodeId);
            payload.setPosition(position);
            
            return CollaborationEvent.builder()
                .type(EventType.NODE_MOVED)
                .userId(userId)
                .workflowId(workflowId)
                .payload(payload)
                .build();
        });
    }
    
    /**
     * Lock node for collaboration
     */
    public Uni<CollaborationEvent> lockNode(String workflowId, String nodeId,
                                             String userId, String tenantId) {
        
        return commandService.lockNode(workflowId, nodeId, userId, tenantId)
            .map(lock -> CollaborationEvent.builder()
                .type(EventType.NODE_LOCKED)
                .userId(userId)
                .workflowId(workflowId)
                .payload(lock)
                .build());
    }
    
    /**
     * Unlock node
     */
    public Uni<CollaborationEvent> unlockNode(String workflowId, String nodeId,
                                               String userId, String tenantId) {
        
        return commandService.unlockNode(workflowId, nodeId, userId, tenantId)
            .map(success -> CollaborationEvent.builder()
                .type(EventType.NODE_UNLOCKED)
                .userId(userId)
                .workflowId(workflowId)
                .payload(Map.of("nodeId", nodeId))
                .build());
    }
    
    /**
     * Release all locks held by user
     */
    private Uni<Void> releaseLocks(String workflowId, String userId, String tenantId) {
        // Implementation: find all locked nodes and unlock them
        return Uni.createFrom().voidItem();
    }
}

// Continued in next artifact...

// ============================================================================
// WORKFLOW SERVICE - INPUT/OUTPUT DTOs & COLLABORATION MODELS
// ============================================================================

package io.kayys.wayang.workflow.domain;

import com.fasterxml.jackson.annotation.JsonInclude;
import io.quarkus.runtime.annotations.RegisterForReflection;
import jakarta.validation.constraints.*;

import java.time.Instant;
import java.util.*;

// ----------------------------------------------------------------------------
// INPUT DTOs (for GraphQL Mutations & REST)
// ----------------------------------------------------------------------------

/**
 * CreateWorkflowInput - Input for creating new workflow
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CreateWorkflowInput {
    
    @NotBlank
    @Size(min = 3, max = 255)
    private String name;
    
    @Size(max = 2000)
    private String description;
    
    private LogicDefinitionDTO logic;
    private UIDefinitionDTO ui;
    private RuntimeConfigDTO runtime;
    
    private Set<String> tags = new HashSet<>();
    private Map<String, Object> metadata = new HashMap<>();
    
    // Getters and setters...
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public LogicDefinitionDTO getLogic() { return logic; }
    public void setLogic(LogicDefinitionDTO logic) { this.logic = logic; }
    
    public UIDefinitionDTO getUi() { return ui; }
    public void setUi(UIDefinitionDTO ui) { this.ui = ui; }
    
    public RuntimeConfigDTO getRuntime() { return runtime; }
    public void setRuntime(RuntimeConfigDTO runtime) { this.runtime = runtime; }
    
    public Set<String> getTags() { return tags; }
    public void setTags(Set<String> tags) { this.tags = tags; }
    
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
}

/**
 * UpdateWorkflowInput - Input for updating workflow
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class UpdateWorkflowInput {
    
    private String name;
    private String description;
    private LogicDefinitionDTO logic;
    private UIDefinitionDTO ui;
    private RuntimeConfigDTO runtime;
    private Set<String> tags;
    private Map<String, Object> metadata;
    
    // Getters and setters similar to CreateWorkflowInput...
}

/**
 * NodeInput - Input for node operations
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NodeInput {
    
    @NotBlank
    private String type;
    
    @NotBlank
    private String name;
    
    private Map<String, Object> properties = new HashMap<>();
    private PointDTO position;
    private Map<String, Object> metadata = new HashMap<>();
    
    // Getters and setters...
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Map<String, Object> getProperties() { return properties; }
    public void setProperties(Map<String, Object> properties) { 
        this.properties = properties; 
    }
    
    public PointDTO getPosition() { return position; }
    public void setPosition(PointDTO position) { this.position = position; }
    
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
}

/**
 * ConnectionInput - Input for connection operations
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ConnectionInput {
    
    @NotBlank
    private String from;
    
    @NotBlank
    private String to;
    
    @NotBlank
    private String fromPort;
    
    @NotBlank
    private String toPort;
    
    private String condition;
    
    // Getters and setters...
    public String getFrom() { return from; }
    public void setFrom(String from) { this.from = from; }
    
    public String getTo() { return to; }
    public void setTo(String to) { this.to = to; }
    
    public String getFromPort() { return fromPort; }
    public void setFromPort(String fromPort) { this.fromPort = fromPort; }
    
    public String getToPort() { return toPort; }
    public void setToPort(String toPort) { this.toPort = toPort; }
    
    public String getCondition() { return condition; }
    public void setCondition(String condition) { this.condition = condition; }
}

/**
 * WorkflowFilterInput - Filter for listing workflows
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class WorkflowFilterInput {
    
    private String search; // Search in name/description
    private WorkflowStatus status;
    private Set<String> tags;
    private String createdBy;
    private Instant createdAfter;
    private Instant createdBefore;
    
    // Getters and setters...
    public String getSearch() { return search; }
    public void setSearch(String search) { this.search = search; }
    
    public WorkflowStatus getStatus() { return status; }
    public void setStatus(WorkflowStatus status) { this.status = status; }
    
    public Set<String> getTags() { return tags; }
    public void setTags(Set<String> tags) { this.tags = tags; }
    
    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
}

/**
 * PageInput - Pagination input
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class PageInput {
    
    @Min(1)
    private int page = 1;
    
    @Min(1)
    @Max(100)
    private int size = 20;
    
    private String sortBy = "createdAt";
    private String sortDir = "DESC";
    
    // Getters and setters...
    public int getPage() { return page; }
    public void setPage(int page) { this.page = page; }
    
    public int getSize() { return size; }
    public void setSize(int size) { this.size = size; }
    
    public String getSortBy() { return sortBy; }
    public void setSortBy(String sortBy) { this.sortBy = sortBy; }
    
    public String getSortDir() { return sortDir; }
    public void setSortDir(String sortDir) { this.sortDir = sortDir; }
}

/**
 * WorkflowConnection - Paginated result
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class WorkflowConnection {
    
    private List<WorkflowDTO> nodes = new ArrayList<>();
    private PageInfo pageInfo;
    private int totalCount;
    
    // Getters and setters...
    public List<WorkflowDTO> getNodes() { return nodes; }
    public void setNodes(List<WorkflowDTO> nodes) { this.nodes = nodes; }
    
    public PageInfo getPageInfo() { return pageInfo; }
    public void setPageInfo(PageInfo pageInfo) { this.pageInfo = pageInfo; }
    
    public int getTotalCount() { return totalCount; }
    public void setTotalCount(int totalCount) { this.totalCount = totalCount; }
}

/**
 * PageInfo - Pagination metadata
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class PageInfo {
    
    private boolean hasNextPage;
    private boolean hasPreviousPage;
    private String startCursor;
    private String endCursor;
    
    // Getters and setters...
    public boolean isHasNextPage() { return hasNextPage; }
    public void setHasNextPage(boolean hasNextPage) { this.hasNextPage = hasNextPage; }
    
    public boolean isHasPreviousPage() { return hasPreviousPage; }
    public void setHasPreviousPage(boolean hasPreviousPage) { 
        this.hasPreviousPage = hasPreviousPage; 
    }
    
    public String getStartCursor() { return startCursor; }
    public void setStartCursor(String startCursor) { this.startCursor = startCursor; }
    
    public String getEndCursor() { return endCursor; }
    public void setEndCursor(String endCursor) { this.endCursor = endCursor; }
}

// ----------------------------------------------------------------------------
// EXECUTION DTOs
// ----------------------------------------------------------------------------

/**
 * ExecutionRequest - Request to execute workflow
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ExecutionRequest {
    
    private Map<String, Object> inputs = new HashMap<>();
    private Map<String, Object> context = new HashMap<>();
    private boolean async = true;
    private String callbackUrl;
    
    // Getters and setters...
    public Map<String, Object> getInputs() { return inputs; }
    public void setInputs(Map<String, Object> inputs) { this.inputs = inputs; }
    
    public Map<String, Object> getContext() { return context; }
    public void setContext(Map<String, Object> context) { this.context = context; }
    
    public boolean isAsync() { return async; }
    public void setAsync(boolean async) { this.async = async; }
    
    public String getCallbackUrl() { return callbackUrl; }
    public void setCallbackUrl(String callbackUrl) { this.callbackUrl = callbackUrl; }
}

/**
 * ExecutionResponse - Response from execution request
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ExecutionResponse {
    
    @NotBlank
    private String id; // Execution ID
    
    @NotBlank
    private String workflowId;
    
    @NotNull
    private ExecutionStatusEnum status;
    
    private Instant startedAt;
    private Map<String, Object> outputs;
    private String message;
    
    // Getters and setters...
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getWorkflowId() { return workflowId; }
    public void setWorkflowId(String workflowId) { this.workflowId = workflowId; }
    
    public ExecutionStatusEnum getStatus() { return status; }
    public void setStatus(ExecutionStatusEnum status) { this.status = status; }
    
    public Instant getStartedAt() { return startedAt; }
    public void setStartedAt(Instant startedAt) { this.startedAt = startedAt; }
    
    public Map<String, Object> getOutputs() { return outputs; }
    public void setOutputs(Map<String, Object> outputs) { this.outputs = outputs; }
}

/**
 * ExecutionStatus - Detailed execution status
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ExecutionStatus {
    
    private String id;
    private String workflowId;
    private ExecutionStatusEnum status;
    private Instant startedAt;
    private Instant completedAt;
    private Duration duration;
    
    private Map<String, NodeExecutionStatus> nodeStatuses = new HashMap<>();
    private Map<String, Object> outputs;
    private ExecutionError error;
    private ExecutionMetrics metrics;
    
    // Getters and setters...
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public ExecutionStatusEnum getStatus() { return status; }
    public void setStatus(ExecutionStatusEnum status) { this.status = status; }
    
    public Map<String, NodeExecutionStatus> getNodeStatuses() { return nodeStatuses; }
    public void setNodeStatuses(Map<String, NodeExecutionStatus> nodeStatuses) { 
        this.nodeStatuses = nodeStatuses; 
    }
}

/**
 * NodeExecutionStatus - Status of individual node execution
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NodeExecutionStatus {
    
    private String nodeId;
    private ExecutionStatusEnum status;
    private Instant startedAt;
    private Instant completedAt;
    private int attempts;
    private ExecutionError error;
    
    // Getters and setters...
    public String getNodeId() { return nodeId; }
    public void setNodeId(String nodeId) { this.nodeId = nodeId; }
    
    public ExecutionStatusEnum getStatus() { return status; }
    public void setStatus(ExecutionStatusEnum status) { this.status = status; }
    
    public int getAttempts() { return attempts; }
    public void setAttempts(int attempts) { this.attempts = attempts; }
    
    public ExecutionError getError() { return error; }
    public void setError(ExecutionError error) { this.error = error; }
}

/**
 * ExecutionError - Error information
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ExecutionError {
    
    private String code;
    private String message;
    private String nodeId;
    private Map<String, Object> details = new HashMap<>();
    
    // Getters and setters...
    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public String getNodeId() { return nodeId; }
    public void setNodeId(String nodeId) { this.nodeId = nodeId; }
}

/**
 * ExecutionMetrics - Execution metrics
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ExecutionMetrics {
    
    private long durationMs;
    private int nodesExecuted;
    private int nodesFailed;
    private long tokensUsed;
    private double costUsd;
    
    // Getters and setters...
    public long getDurationMs() { return durationMs; }
    public void setDurationMs(long durationMs) { this.durationMs = durationMs; }
    
    public int getNodesExecuted() { return nodesExecuted; }
    public void setNodesExecuted(int nodesExecuted) { 
        this.nodesExecuted = nodesExecuted; 
    }
    
    public long getTokensUsed() { return tokensUsed; }
    public void setTokensUsed(long tokensUsed) { this.tokensUsed = tokensUsed; }
    
    public double getCostUsd() { return costUsd; }
    public void setCostUsd(double costUsd) { this.costUsd = costUsd; }
}

// ----------------------------------------------------------------------------
// COLLABORATION DTOs (WebSocket)
// ----------------------------------------------------------------------------

/**
 * CollaborationMessage - Message sent by client
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CollaborationMessage {
    
    @NotNull
    private MessageType type;
    
    @NotNull
    private Map<String, Object> payload = new HashMap<>();
    
    private String messageId;
    private Instant timestamp;
    
    // Getters and setters...
    public MessageType getType() { return type; }
    public void setType(MessageType type) { this.type = type; }
    
    public Map<String, Object> getPayload() { return payload; }
    public void setPayload(Map<String, Object> payload) { this.payload = payload; }
    
    @SuppressWarnings("unchecked")
    public <T> T getPayload(Class<T> clazz) {
        return JsonUtils.convertValue(payload, clazz);
    }
    
    public String getMessageId() { return messageId; }
    public void setMessageId(String messageId) { this.messageId = messageId; }
}

/**
 * CollaborationEvent - Event sent to clients
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CollaborationEvent {
    
    @NotNull
    private EventType type;
    
    @NotBlank
    private String userId;
    
    @NotBlank
    private String workflowId;
    
    @NotNull
    private Object payload;
    
    private Instant timestamp = Instant.now();
    
    // Builder pattern
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private final CollaborationEvent event = new CollaborationEvent();
        
        public Builder type(EventType type) {
            event.type = type;
            return this;
        }
        
        public Builder userId(String userId) {
            event.userId = userId;
            return this;
        }
        
        public Builder workflowId(String workflowId) {
            event.workflowId = workflowId;
            return this;
        }
        
        public Builder payload(Object payload) {
            event.payload = payload;
            return this;
        }
        
        public CollaborationEvent build() {
            return event;
        }
    }
    
    // Getters and setters...
    public EventType getType() { return type; }
    public void setType(EventType type) { this.type = type; }
    
    public String getUserId() { return userId; }
    public void setUserId(String userId) { this.userId = userId; }
    
    public String getWorkflowId() { return workflowId; }
    public void setWorkflowId(String workflowId) { this.workflowId = workflowId; }
    
    public Object getPayload() { return payload; }
    public void setPayload(Object payload) { this.payload = payload; }
    
    public Instant getTimestamp() { return timestamp; }
    public void setTimestamp(Instant timestamp) { this.timestamp = timestamp; }
}

/**
 * CursorPosition - User cursor position
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CursorPosition {
    
    private String userId;
    private double x;
    private double y;
    private long timestamp;
    
    // Getters and setters...
    public String getUserId() { return userId; }
    public void setUserId(String userId) { this.userId = userId; }
    
    public double getX() { return x; }
    public void setX(double x) { this.x = x; }
    
    public double getY() { return y; }
    public void setY(double y) { this.y = y; }
    
    public long getTimestamp() { return timestamp; }
    public void setTimestamp(long timestamp) { this.timestamp = timestamp; }
}

/**
 * NodeMovePayload - Node movement data
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NodeMovePayload {
    
    @NotBlank
    private String nodeId;
    
    @NotNull
    private PointDTO position;
    
    // Getters and setters...
    public String getNodeId() { return nodeId; }
    public void setNodeId(String nodeId) { this.nodeId = nodeId; }
    
    public PointDTO getPosition() { return position; }
    public void setPosition(PointDTO position) { this.position = position; }
}

/**
 * NodeUpdatePayload - Node update data
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NodeUpdatePayload {
    
    @NotBlank
    private String nodeId;
    
    @NotNull
    private Map<String, Object> changes = new HashMap<>();
    
    // Getters and setters...
    public String getNodeId() { return nodeId; }
    public void setNodeId(String nodeId) { this.nodeId = nodeId; }
    
    public Map<String, Object> getChanges() { return changes; }
    public void setChanges(Map<String, Object> changes) { this.changes = changes; }
}

/**
 * SelectionPayload - User selection
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class SelectionPayload {
    
    private String userId;
    private Set<String> selectedNodeIds = new HashSet<>();
    private Set<String> selectedConnectionIds = new HashSet<>();
    
    // Getters and setters...
    public String getUserId() { return userId; }
    public void setUserId(String userId) { this.userId = userId; }
    
    public Set<String> getSelectedNodeIds() { return selectedNodeIds; }
    public void setSelectedNodeIds(Set<String> selectedNodeIds) { 
        this.selectedNodeIds = selectedNodeIds; 
    }
    
    public Set<String> getSelectedConnectionIds() { return selectedConnectionIds; }
    public void setSelectedConnectionIds(Set<String> selectedConnectionIds) { 
        this.selectedConnectionIds = selectedConnectionIds; 
    }
}

/**
 * NodeLockDTO - Node lock information
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NodeLockDTO {
    
    private String nodeId;
    private String userId;
    private Instant lockedAt;
    private Instant expiresAt;
    
    // Getters and setters...
    public String getNodeId() { return nodeId; }
    public void setNodeId(String nodeId) { this.nodeId = nodeId; }
    
    public String getUserId() { return userId; }
    public void setUserId(String userId) { this.userId = userId; }
    
    public Instant getLockedAt() { return lockedAt; }
    public void setLockedAt(Instant lockedAt) { this.lockedAt = lockedAt; }
    
    public Instant getExpiresAt() { return expiresAt; }
    public void setExpiresAt(Instant expiresAt) { this.expiresAt = expiresAt; }
}

// ----------------------------------------------------------------------------
// ENUMS
// ----------------------------------------------------------------------------

/**
 * WorkflowStatus - Workflow status
 */
@RegisterForReflection
public enum WorkflowStatus {
    DRAFT,
    VALIDATING,
    VALID,
    INVALID,
    PUBLISHED,
    ARCHIVED
}

/**
 * ValidationStatus - Validation status
 */
@RegisterForReflection
public enum ValidationStatus {
    NOT_VALIDATED,
    VALIDATING,
    VALID,
    INVALID,
    NEEDS_REVIEW
}

/**
 * ExecutionStatusEnum - Execution status
 */
@RegisterForReflection
public enum ExecutionStatusEnum {
    PENDING,
    RUNNING,
    PAUSED,
    COMPLETED,
    FAILED,
    CANCELLED,
    TIMEOUT
}

/**
 * MessageType - WebSocket message type (client -> server)
 */
@RegisterForReflection
public enum MessageType {
    CURSOR_MOVE,
    NODE_MOVE,
    NODE_LOCK,
    NODE_UNLOCK,
    NODE_UPDATE,
    CONNECTION_ADD,
    CONNECTION_DELETE,
    SELECTION_CHANGE
}

/**
 * EventType - WebSocket event type (server -> client)
 */
@RegisterForReflection
public enum EventType {
    USER_JOINED,
    USER_LEFT,
    CURSOR_MOVED,
    NODE_MOVED,
    NODE_LOCKED,
    NODE_UNLOCKED,
    LOCK_FAILED,
    NODE_UPDATED,
    CONNECTION_ADDED,
    CONNECTION_DELETED,
    SELECTION_CHANGED,
    VALIDATION_COMPLETED,
    ERROR
}

// ============================================================================
// WORKFLOW SERVICE - DOMAIN MODELS & DTOs
// ============================================================================

package io.kayys.wayang.workflow.domain;

import com.fasterxml.jackson.annotation.JsonInclude;
import io.quarkus.runtime.annotations.RegisterForReflection;
import jakarta.validation.constraints.*;

import java.time.Instant;
import java.util.*;

// ----------------------------------------------------------------------------
// WORKFLOW DOMAIN MODELS
// ----------------------------------------------------------------------------

/**
 * WorkflowDTO - Primary workflow data transfer object
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class WorkflowDTO {
    
    @NotNull
    private String id;
    
    @NotBlank
    private String version;
    
    @NotBlank
    @Size(min = 3, max = 255)
    private String name;
    
    @Size(max = 2000)
    private String description;
    
    @NotNull
    private WorkflowStatus status;
    
    @NotNull
    private Instant createdAt;
    
    @NotNull
    private Instant updatedAt;
    
    @NotBlank
    private String createdBy;
    
    @NotBlank
    private String tenantId;
    
    // Components
    private LogicDefinitionDTO logic;
    private UIDefinitionDTO ui;
    private RuntimeConfigDTO runtime;
    
    // Metadata
    private Set<String> tags = new HashSet<>();
    private Map<String, Object> metadata = new HashMap<>();
    
    // Validation
    private ValidationStatus validationStatus;
    private List<ValidationError> validationErrors = new ArrayList<>();
    
    // Audit
    private String lastModifiedBy;
    private String publishedBy;
    private Instant publishedAt;
    
    // Getters and setters...
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getVersion() { return version; }
    public void setVersion(String version) { this.version = version; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public WorkflowStatus getStatus() { return status; }
    public void setStatus(WorkflowStatus status) { this.status = status; }
    
    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }
    
    public Instant getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }
    
    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
    
    public String getTenantId() { return tenantId; }
    public void setTenantId(String tenantId) { this.tenantId = tenantId; }
    
    public LogicDefinitionDTO getLogic() { return logic; }
    public void setLogic(LogicDefinitionDTO logic) { this.logic = logic; }
    
    public UIDefinitionDTO getUi() { return ui; }
    public void setUi(UIDefinitionDTO ui) { this.ui = ui; }
    
    public RuntimeConfigDTO getRuntime() { return runtime; }
    public void setRuntime(RuntimeConfigDTO runtime) { this.runtime = runtime; }
    
    public Set<String> getTags() { return tags; }
    public void setTags(Set<String> tags) { this.tags = tags; }
    
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    
    public ValidationStatus getValidationStatus() { return validationStatus; }
    public void setValidationStatus(ValidationStatus validationStatus) { 
        this.validationStatus = validationStatus; 
    }
    
    public List<ValidationError> getValidationErrors() { return validationErrors; }
    public void setValidationErrors(List<ValidationError> validationErrors) { 
        this.validationErrors = validationErrors; 
    }
}

/**
 * LogicDefinitionDTO - Workflow logic structure
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class LogicDefinitionDTO {
    
    @NotNull
    private List<NodeDTO> nodes = new ArrayList<>();
    
    @NotNull
    private List<ConnectionDTO> connections = new ArrayList<>();
    
    private WorkflowRulesDTO rules;
    
    // Getters and setters...
    public List<NodeDTO> getNodes() { return nodes; }
    public void setNodes(List<NodeDTO> nodes) { this.nodes = nodes; }
    
    public List<ConnectionDTO> getConnections() { return connections; }
    public void setConnections(List<ConnectionDTO> connections) { 
        this.connections = connections; 
    }
    
    public WorkflowRulesDTO getRules() { return rules; }
    public void setRules(WorkflowRulesDTO rules) { this.rules = rules; }
}

/**
 * NodeDTO - Node definition
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NodeDTO {
    
    @NotBlank
    private String id;
    
    @NotBlank
    private String type;
    
    @NotBlank
    private String name;
    
    private Map<String, Object> properties = new HashMap<>();
    
    private List<PortDescriptorDTO> inputs = new ArrayList<>();
    private List<PortDescriptorDTO> outputs = new ArrayList<>();
    
    // UI position (denormalized for convenience)
    private PointDTO position;
    
    // Collaboration
    private boolean locked = false;
    private String lockedBy;
    private Instant lockedAt;
    
    // Metadata
    private String description;
    private Map<String, Object> metadata = new HashMap<>();
    
    // Error handling
    private ErrorHandlingConfigDTO errorHandling;
    
    // Getters and setters...
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Map<String, Object> getProperties() { return properties; }
    public void setProperties(Map<String, Object> properties) { 
        this.properties = properties; 
    }
    
    public List<PortDescriptorDTO> getInputs() { return inputs; }
    public void setInputs(List<PortDescriptorDTO> inputs) { this.inputs = inputs; }
    
    public List<PortDescriptorDTO> getOutputs() { return outputs; }
    public void setOutputs(List<PortDescriptorDTO> outputs) { this.outputs = outputs; }
    
    public PointDTO getPosition() { return position; }
    public void setPosition(PointDTO position) { this.position = position; }
    
    public boolean isLocked() { return locked; }
    public void setLocked(boolean locked) { this.locked = locked; }
    
    public String getLockedBy() { return lockedBy; }
    public void setLockedBy(String lockedBy) { this.lockedBy = lockedBy; }
    
    public Instant getLockedAt() { return lockedAt; }
    public void setLockedAt(Instant lockedAt) { this.lockedAt = lockedAt; }
    
    public ErrorHandlingConfigDTO getErrorHandling() { return errorHandling; }
    public void setErrorHandling(ErrorHandlingConfigDTO errorHandling) { 
        this.errorHandling = errorHandling; 
    }
}

/**
 * ConnectionDTO - Connection between nodes
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ConnectionDTO {
    
    @NotBlank
    private String id;
    
    @NotBlank
    private String from;
    
    @NotBlank
    private String to;
    
    @NotBlank
    private String fromPort;
    
    @NotBlank
    private String toPort;
    
    private String condition; // CEL expression
    
    private Map<String, Object> metadata = new HashMap<>();
    
    // Getters and setters...
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    
    public String getFrom() { return from; }
    public void setFrom(String from) { this.from = from; }
    
    public String getTo() { return to; }
    public void setTo(String to) { this.to = to; }
    
    public String getFromPort() { return fromPort; }
    public void setFromPort(String fromPort) { this.fromPort = fromPort; }
    
    public String getToPort() { return toPort; }
    public void setToPort(String toPort) { this.toPort = toPort; }
    
    public String getCondition() { return condition; }
    public void setCondition(String condition) { this.condition = condition; }
    
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
}

/**
 * PortDescriptorDTO - Input/Output port definition
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class PortDescriptorDTO {
    
    @NotBlank
    private String name;
    
    private String displayName;
    private String description;
    
    @NotNull
    private DataTypeDTO data;
    
    private boolean required = true;
    private boolean sensitive = false;
    
    // Getters and setters...
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDisplayName() { return displayName; }
    public void setDisplayName(String displayName) { this.displayName = displayName; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public DataTypeDTO getData() { return data; }
    public void setData(DataTypeDTO data) { this.data = data; }
    
    public boolean isRequired() { return required; }
    public void setRequired(boolean required) { this.required = required; }
    
    public boolean isSensitive() { return sensitive; }
    public void setSensitive(boolean sensitive) { this.sensitive = sensitive; }
}

/**
 * DataTypeDTO - Data type definition
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class DataTypeDTO {
    
    @NotBlank
    private String type; // json, string, number, etc.
    
    private String format;
    private Map<String, Object> schema; // JSON Schema
    private String multiplicity = "single"; // single, list, map, stream
    
    // Getters and setters...
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public String getFormat() { return format; }
    public void setFormat(String format) { this.format = format; }
    
    public Map<String, Object> getSchema() { return schema; }
    public void setSchema(Map<String, Object> schema) { this.schema = schema; }
    
    public String getMultiplicity() { return multiplicity; }
    public void setMultiplicity(String multiplicity) { this.multiplicity = multiplicity; }
}

/**
 * UIDefinitionDTO - UI layout information
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class UIDefinitionDTO {
    
    private CanvasStateDTO canvas;
    private List<NodeUIDTO> nodes = new ArrayList<>();
    private List<ConnectionUIDTO> connections = new ArrayList<>();
    
    // Getters and setters...
    public CanvasStateDTO getCanvas() { return canvas; }
    public void setCanvas(CanvasStateDTO canvas) { this.canvas = canvas; }
    
    public List<NodeUIDTO> getNodes() { return nodes; }
    public void setNodes(List<NodeUIDTO> nodes) { this.nodes = nodes; }
    
    public List<ConnectionUIDTO> getConnections() { return connections; }
    public void setConnections(List<ConnectionUIDTO> connections) { 
        this.connections = connections; 
    }
}

/**
 * CanvasStateDTO - Canvas state
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CanvasStateDTO {
    private double zoom = 1.0;
    private PointDTO offset = new PointDTO(0, 0);
    private String background;
    private boolean snapToGrid = true;
    
    // Getters and setters...
    public double getZoom() { return zoom; }
    public void setZoom(double zoom) { this.zoom = zoom; }
    
    public PointDTO getOffset() { return offset; }
    public void setOffset(PointDTO offset) { this.offset = offset; }
    
    public String getBackground() { return background; }
    public void setBackground(String background) { this.background = background; }
    
    public boolean isSnapToGrid() { return snapToGrid; }
    public void setSnapToGrid(boolean snapToGrid) { this.snapToGrid = snapToGrid; }
}

/**
 * NodeUIDTO - Node UI properties
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class NodeUIDTO {
    
    @NotBlank
    private String ref; // Node ID reference
    
    @NotNull
    private PointDTO position;
    
    private SizeDTO size;
    private String icon;
    private String color;
    private String shape;
    private boolean collapsed = false;
    private int zIndex = 0;
    
    // Getters and setters...
    public String getRef() { return ref; }
    public void setRef(String ref) { this.ref = ref; }
    
    public PointDTO getPosition() { return position; }
    public void setPosition(PointDTO position) { this.position = position; }
    
    public SizeDTO getSize() { return size; }
    public void setSize(SizeDTO size) { this.size = size; }
    
    public String getIcon() { return icon; }
    public void setIcon(String icon) { this.icon = icon; }
    
    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }
}

/**
 * ConnectionUIDTO - Connection UI properties
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ConnectionUIDTO {
    
    @NotBlank
    private String ref; // Connection ID reference
    
    private String color;
    private String pathStyle;
    
    // Getters and setters...
    public String getRef() { return ref; }
    public void setRef(String ref) { this.ref = ref; }
    
    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }
    
    public String getPathStyle() { return pathStyle; }
    public void setPathStyle(String pathStyle) { this.pathStyle = pathStyle; }
}

/**
 * PointDTO - 2D point
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class PointDTO {
    private double x;
    private double y;
    
    public PointDTO() {}
    
    public PointDTO(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    public double getX() { return x; }
    public void setX(double x) { this.x = x; }
    
    public double getY() { return y; }
    public void setY(double y) { this.y = y; }
}

/**
 * SizeDTO - 2D size
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class SizeDTO {
    private double width;
    private double height;
    
    public SizeDTO() {}
    
    public SizeDTO(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    public double getWidth() { return width; }
    public void setWidth(double width) { this.width = width; }
    
    public double getHeight() { return height; }
    public void setHeight(double height) { this.height = height; }
}

/**
 * RuntimeConfigDTO - Runtime configuration
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class RuntimeConfigDTO {
    
    private String mode = "sync"; // sync, async, stream
    private RetryPolicyDTO retryPolicy;
    private Integer timeoutMs;
    private ResourceProfileDTO resourceProfile;
    
    // Getters and setters...
    public String getMode() { return mode; }
    public void setMode(String mode) { this.mode = mode; }
    
    public RetryPolicyDTO getRetryPolicy() { return retryPolicy; }
    public void setRetryPolicy(RetryPolicyDTO retryPolicy) { 
        this.retryPolicy = retryPolicy; 
    }
    
    public Integer getTimeoutMs() { return timeoutMs; }
    public void setTimeoutMs(Integer timeoutMs) { this.timeoutMs = timeoutMs; }
    
    public ResourceProfileDTO getResourceProfile() { return resourceProfile; }
    public void setResourceProfile(ResourceProfileDTO resourceProfile) { 
        this.resourceProfile = resourceProfile; 
    }
}

/**
 * RetryPolicyDTO - Retry policy configuration
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class RetryPolicyDTO {
    
    private int maxAttempts = 3;
    private int initialDelayMs = 200;
    private int maxDelayMs = 30000;
    private String backoff = "exponential"; // fixed, exponential, linear
    private boolean jitter = true;
    private List<String> retryOn = new ArrayList<>();
    
    // Getters and setters...
    public int getMaxAttempts() { return maxAttempts; }
    public void setMaxAttempts(int maxAttempts) { this.maxAttempts = maxAttempts; }
    
    public int getInitialDelayMs() { return initialDelayMs; }
    public void setInitialDelayMs(int initialDelayMs) { 
        this.initialDelayMs = initialDelayMs; 
    }
    
    public int getMaxDelayMs() { return maxDelayMs; }
    public void setMaxDelayMs(int maxDelayMs) { this.maxDelayMs = maxDelayMs; }
    
    public String getBackoff() { return backoff; }
    public void setBackoff(String backoff) { this.backoff = backoff; }
    
    public boolean isJitter() { return jitter; }
    public void setJitter(boolean jitter) { this.jitter = jitter; }
    
    public List<String> getRetryOn() { return retryOn; }
    public void setRetryOn(List<String> retryOn) { this.retryOn = retryOn; }
}

/**
 * ResourceProfileDTO - Resource requirements
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ResourceProfileDTO {
    
    private String cpu = "100m";
    private String memory = "128Mi";
    private int gpu = 0;
    private String ephemeralStorage;
    
    // Getters and setters...
    public String getCpu() { return cpu; }
    public void setCpu(String cpu) { this.cpu = cpu; }
    
    public String getMemory() { return memory; }
    public void setMemory(String memory) { this.memory = memory; }
    
    public int getGpu() { return gpu; }
    public void setGpu(int gpu) { this.gpu = gpu; }
    
    public String getEphemeralStorage() { return ephemeralStorage; }
    public void setEphemeralStorage(String ephemeralStorage) { 
        this.ephemeralStorage = ephemeralStorage; 
    }
}

/**
 * ErrorHandlingConfigDTO - Error handling configuration
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorHandlingConfigDTO {
    
    private RetryPolicyDTO retryPolicy;
    private FallbackConfigDTO fallback;
    private CircuitBreakerConfigDTO circuitBreaker;
    private EscalationConfigDTO escalation;
    private HumanReviewConfigDTO humanReview;
    
    // Getters and setters...
    public RetryPolicyDTO getRetryPolicy() { return retryPolicy; }
    public void setRetryPolicy(RetryPolicyDTO retryPolicy) { 
        this.retryPolicy = retryPolicy; 
    }
    
    public FallbackConfigDTO getFallback() { return fallback; }
    public void setFallback(FallbackConfigDTO fallback) { this.fallback = fallback; }
    
    public CircuitBreakerConfigDTO getCircuitBreaker() { return circuitBreaker; }
    public void setCircuitBreaker(CircuitBreakerConfigDTO circuitBreaker) { 
        this.circuitBreaker = circuitBreaker; 
    }
    
    public EscalationConfigDTO getEscalation() { return escalation; }
    public void setEscalation(EscalationConfigDTO escalation) { 
        this.escalation = escalation; 
    }
    
    public HumanReviewConfigDTO getHumanReview() { return humanReview; }
    public void setHumanReview(HumanReviewConfigDTO humanReview) { 
        this.humanReview = humanReview; 
    }
}

/**
 * FallbackConfigDTO - Fallback configuration
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class FallbackConfigDTO {
    
    private String type = "none"; // node, static, none
    private String nodeId;
    private Object staticResponse;
    
    // Getters and setters...
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public String getNodeId() { return nodeId; }
    public void setNodeId(String nodeId) { this.nodeId = nodeId; }
    
    public Object getStaticResponse() { return staticResponse; }
    public void setStaticResponse(Object staticResponse) { 
        this.staticResponse = staticResponse; 
    }
}

/**
 * CircuitBreakerConfigDTO - Circuit breaker configuration
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class CircuitBreakerConfigDTO {
    
    private boolean enabled = false;
    private int failureThreshold = 5;
    private int successThreshold = 2;
    private int timeoutMs = 60000;
    private int windowMs = 600000;
    
    // Getters and setters...
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    
    public int getFailureThreshold() { return failureThreshold; }
    public void setFailureThreshold(int failureThreshold) { 
        this.failureThreshold = failureThreshold; 
    }
    
    public int getSuccessThreshold() { return successThreshold; }
    public void setSuccessThreshold(int successThreshold) { 
        this.successThreshold = successThreshold; 
    }
    
    public int getTimeoutMs() { return timeoutMs; }
    public void setTimeoutMs(int timeoutMs) { this.timeoutMs = timeoutMs; }
    
    public int getWindowMs() { return windowMs; }
    public void setWindowMs(int windowMs) { this.windowMs = windowMs; }
}

/**
 * EscalationConfigDTO - Escalation configuration
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class EscalationConfigDTO {
    
    private String onSeverityAtLeast = "ERROR"; // WARN, ERROR, CRITICAL
    private List<String> notify = new ArrayList<>();
    
    // Getters and setters...
    public String getOnSeverityAtLeast() { return onSeverityAtLeast; }
    public void setOnSeverityAtLeast(String onSeverityAtLeast) { 
        this.onSeverityAtLeast = onSeverityAtLeast; 
    }
    
    public List<String> getNotify() { return notify; }
    public void setNotify(List<String> notify) { this.notify = notify; }
}

/**
 * HumanReviewConfigDTO - Human review configuration
 */
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public class HumanReviewConfigDTO {
    
    private boolean enabled = false;
    private String thresholdSeverity = "CRITICAL";
    private String reviewQueue;
    
    // Getters and setters...
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    
    public String getThresholdSeverity() { return thresholdSeverity; }
    public void setThresholdSeverity(String thresholdSeverity) { 
        this.thresholdSeverity = thresholdSeverity; 
    }
    
    public String getReviewQueue() { return reviewQueue; }
    public void setReviewQueue(String reviewQueue) { this.reviewQueue = reviewQueue; }
}

// Continued in next artifact...
// ============================================================================
// WORKFLOW SERVICE - Core Domain Service
// ============================================================================

package io.kayys.wayang.workflow;

/**
 * Workflow Service - Core workflow management service
 * Exposes: GraphQL (queries/mutations), REST (operations), WebSocket (collaboration)
 */

// ----------------------------------------------------------------------------
// 1. GRAPHQL SCHEMA & RESOLVERS
// ----------------------------------------------------------------------------

/**
 * GraphQL Schema Definition
 * File: src/main/resources/schema.graphqls
 */
/*
type Query {
    # Workflow queries
    workflow(id: ID!): Workflow
    workflows(filter: WorkflowFilter, page: PageInput): WorkflowConnection
    workflowVersions(workflowId: ID!): [WorkflowVersion!]!
    
    # Node schema queries
    nodeSchema(id: ID!): NodeSchema
    nodeSchemas(filter: NodeSchemaFilter): [NodeSchema!]!
    nodeCategories: [NodeCategory!]!
    
    # Validation
    validateWorkflow(input: WorkflowInput!): ValidationResult!
    validateNode(input: NodeInput!): ValidationResult!
    validateConnection(input: ConnectionInput!): ValidationResult!
    
    # Capabilities
    toolCapabilities(nodeType: String!): [ToolCapability!]!
    agentCapabilities: [AgentCapability!]!
    
    # Diff/Compare
    compareWorkflows(baseId: ID!, targetId: ID!): WorkflowDiff!
}

type Mutation {
    # Workflow lifecycle
    createWorkflow(input: CreateWorkflowInput!): Workflow!
    updateWorkflow(id: ID!, input: UpdateWorkflowInput!): Workflow!
    deleteWorkflow(id: ID!): Boolean!
    
    # Versioning
    createVersion(workflowId: ID!, input: CreateVersionInput!): WorkflowVersion!
    publishVersion(versionId: ID!): WorkflowVersion!
    rollbackVersion(workflowId: ID!, versionId: ID!): Workflow!
    
    # Node operations
    addNode(workflowId: ID!, input: NodeInput!): Node!
    updateNode(workflowId: ID!, nodeId: ID!, input: NodeInput!): Node!
    deleteNode(workflowId: ID!, nodeId: ID!): Boolean!
    
    # Connection operations
    addConnection(workflowId: ID!, input: ConnectionInput!): Connection!
    updateConnection(workflowId: ID!, connectionId: ID!, input: ConnectionInput!): Connection!
    deleteConnection(workflowId: ID!, connectionId: ID!): Boolean!
    
    # Collaboration
    lockNode(workflowId: ID!, nodeId: ID!): NodeLock!
    unlockNode(workflowId: ID!, nodeId: ID!): Boolean!
}

type Subscription {
    # Real-time updates (fallback to WebSocket)
    workflowUpdated(workflowId: ID!): WorkflowUpdate!
}

type Workflow {
    id: ID!
    version: String!
    name: String!
    description: String
    status: WorkflowStatus!
    createdAt: DateTime!
    updatedAt: DateTime!
    createdBy: String!
    tenantId: String!
    
    # Components
    logic: LogicDefinition!
    ui: UIDefinition
    runtime: RuntimeConfig
    
    # Metadata
    tags: [String!]!
    metadata: JSON
    
    # Relations
    versions: [WorkflowVersion!]!
    currentVersion: WorkflowVersion
    
    # Validation
    validationStatus: ValidationStatus!
    validationErrors: [ValidationError!]!
}

type LogicDefinition {
    nodes: [Node!]!
    connections: [Connection!]!
    rules: WorkflowRules
}

type Node {
    id: ID!
    type: String!
    name: String!
    properties: JSON
    inputs: [PortDescriptor!]!
    outputs: [PortDescriptor!]!
    position: Point
    locked: Boolean!
    lockedBy: String
}

type Connection {
    id: ID!
    from: ID!
    to: ID!
    fromPort: String!
    toPort: String!
    condition: String
}

enum WorkflowStatus {
    DRAFT
    VALIDATING
    VALID
    INVALID
    PUBLISHED
    ARCHIVED
}
*/

// ----------------------------------------------------------------------------
// 2. GRAPHQL RESOLVERS
// ----------------------------------------------------------------------------

package io.kayys.wayang.workflow.graphql;

import io.kayys.wayang.workflow.domain.*;
import io.kayys.wayang.workflow.service.*;
import io.smallrye.graphql.api.Context;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.eclipse.microprofile.graphql.*;
import org.jboss.logging.Logger;

import java.util.List;

/**
 * Workflow GraphQL API - Query operations
 */
@GraphQLApi
@ApplicationScoped
public class WorkflowQueryResolver {
    
    private static final Logger LOG = Logger.getLogger(WorkflowQueryResolver.class);
    
    @Inject
    WorkflowQueryService queryService;
    
    @Inject
    NodeSchemaService schemaService;
    
    @Inject
    ValidationService validationService;
    
    @Inject
    Context context;
    
    /**
     * Get single workflow by ID
     */
    @Query("workflow")
    @Description("Retrieve workflow by ID")
    public Uni<WorkflowDTO> getWorkflow(@Name("id") String id) {
        String tenantId = extractTenantId();
        LOG.infof("GraphQL Query: workflow(id=%s, tenant=%s)", id, tenantId);
        return queryService.findById(id, tenantId);
    }
    
    /**
     * List workflows with filtering and pagination
     */
    @Query("workflows")
    @Description("List workflows with filtering")
    public Uni<WorkflowConnection> listWorkflows(
            @Name("filter") WorkflowFilterInput filter,
            @Name("page") PageInput page) {
        
        String tenantId = extractTenantId();
        LOG.infof("GraphQL Query: workflows(tenant=%s, filter=%s)", tenantId, filter);
        return queryService.findAll(tenantId, filter, page);
    }
    
    /**
     * Get workflow versions
     */
    @Query("workflowVersions")
    @Description("Get all versions of a workflow")
    public Uni<List<WorkflowVersionDTO>> getWorkflowVersions(@Name("workflowId") String workflowId) {
        String tenantId = extractTenantId();
        return queryService.findVersions(workflowId, tenantId);
    }
    
    /**
     * Get node schema definition
     */
    @Query("nodeSchema")
    @Description("Get node schema by ID")
    public Uni<NodeSchemaDTO> getNodeSchema(@Name("id") String id) {
        return schemaService.findById(id);
    }
    
    /**
     * List available node schemas
     */
    @Query("nodeSchemas")
    @Description("List available node types")
    public Uni<List<NodeSchemaDTO>> listNodeSchemas(@Name("filter") NodeSchemaFilterInput filter) {
        return schemaService.findAll(filter);
    }
    
    /**
     * Get node categories for UI
     */
    @Query("nodeCategories")
    @Description("Get node categories for palette")
    public Uni<List<NodeCategory>> getNodeCategories() {
        return schemaService.getCategories();
    }
    
    /**
     * Validate workflow structure
     */
    @Query("validateWorkflow")
    @Description("Validate workflow definition")
    public Uni<ValidationResult> validateWorkflow(@Name("input") WorkflowInput input) {
        String tenantId = extractTenantId();
        return validationService.validateWorkflow(input, tenantId);
    }
    
    /**
     * Validate single node
     */
    @Query("validateNode")
    @Description("Validate node configuration")
    public Uni<ValidationResult> validateNode(@Name("input") NodeInput input) {
        return validationService.validateNode(input);
    }
    
    /**
     * Validate connection
     */
    @Query("validateConnection")
    @Description("Validate connection between nodes")
    public Uni<ValidationResult> validateConnection(@Name("input") ConnectionInput input) {
        String tenantId = extractTenantId();
        return validationService.validateConnection(input, tenantId);
    }
    
    /**
     * Get tool capabilities for node type
     */
    @Query("toolCapabilities")
    @Description("Get available tool capabilities for node type")
    public Uni<List<ToolCapability>> getToolCapabilities(@Name("nodeType") String nodeType) {
        return schemaService.getToolCapabilities(nodeType);
    }
    
    /**
     * Get agent capabilities
     */
    @Query("agentCapabilities")
    @Description("Get available agent capabilities")
    public Uni<List<AgentCapability>> getAgentCapabilities() {
        return schemaService.getAgentCapabilities();
    }
    
    /**
     * Compare two workflows
     */
    @Query("compareWorkflows")
    @Description("Compare two workflow versions")
    public Uni<WorkflowDiffDTO> compareWorkflows(
            @Name("baseId") String baseId,
            @Name("targetId") String targetId) {
        
        String tenantId = extractTenantId();
        return queryService.compareWorkflows(baseId, targetId, tenantId);
    }
    
    private String extractTenantId() {
        // Extract from JWT token or context
        return context.getArgument("tenantId")
                .orElse(context.getHeader("X-Tenant-ID")
                .orElse("default"));
    }
}

/**
 * Workflow GraphQL API - Mutation operations
 */
@GraphQLApi
@ApplicationScoped
public class WorkflowMutationResolver {
    
    private static final Logger LOG = Logger.getLogger(WorkflowMutationResolver.class);
    
    @Inject
    WorkflowCommandService commandService;
    
    @Inject
    Context context;
    
    /**
     * Create new workflow
     */
    @Mutation("createWorkflow")
    @Description("Create a new workflow")
    public Uni<WorkflowDTO> createWorkflow(@Name("input") CreateWorkflowInput input) {
        String tenantId = extractTenantId();
        String userId = extractUserId();
        
        LOG.infof("GraphQL Mutation: createWorkflow(name=%s, tenant=%s)", 
            input.getName(), tenantId);
        
        return commandService.create(input, tenantId, userId);
    }
    
    /**
     * Update workflow
     */
    @Mutation("updateWorkflow")
    @Description("Update workflow")
    public Uni<WorkflowDTO> updateWorkflow(
            @Name("id") String id,
            @Name("input") UpdateWorkflowInput input) {
        
        String tenantId = extractTenantId();
        String userId = extractUserId();
        
        LOG.infof("GraphQL Mutation: updateWorkflow(id=%s)", id);
        return commandService.update(id, input, tenantId, userId);
    }
    
    /**
     * Delete workflow
     */
    @Mutation("deleteWorkflow")
    @Description("Delete workflow")
    public Uni<Boolean> deleteWorkflow(@Name("id") String id) {
        String tenantId = extractTenantId();
        LOG.infof("GraphQL Mutation: deleteWorkflow(id=%s)", id);
        return commandService.delete(id, tenantId);
    }
    
    /**
     * Create version
     */
    @Mutation("createVersion")
    @Description("Create new workflow version")
    public Uni<WorkflowVersionDTO> createVersion(
            @Name("workflowId") String workflowId,
            @Name("input") CreateVersionInput input) {
        
        String tenantId = extractTenantId();
        String userId = extractUserId();
        return commandService.createVersion(workflowId, input, tenantId, userId);
    }
    
    /**
     * Publish version
     */
    @Mutation("publishVersion")
    @Description("Publish workflow version")
    public Uni<WorkflowVersionDTO> publishVersion(@Name("versionId") String versionId) {
        String tenantId = extractTenantId();
        String userId = extractUserId();
        return commandService.publishVersion(versionId, tenantId, userId);
    }
    
    /**
     * Add node to workflow
     */
    @Mutation("addNode")
    @Description("Add node to workflow")
    public Uni<NodeDTO> addNode(
            @Name("workflowId") String workflowId,
            @Name("input") NodeInput input) {
        
        String tenantId = extractTenantId();
        String userId = extractUserId();
        return commandService.addNode(workflowId, input, tenantId, userId);
    }
    
    /**
     * Update node
     */
    @Mutation("updateNode")
    @Description("Update node in workflow")
    public Uni<NodeDTO> updateNode(
            @Name("workflowId") String workflowId,
            @Name("nodeId") String nodeId,
            @Name("input") NodeInput input) {
        
        String tenantId = extractTenantId();
        String userId = extractUserId();
        return commandService.updateNode(workflowId, nodeId, input, tenantId, userId);
    }
    
    /**
     * Delete node
     */
    @Mutation("deleteNode")
    @Description("Delete node from workflow")
    public Uni<Boolean> deleteNode(
            @Name("workflowId") String workflowId,
            @Name("nodeId") String nodeId) {
        
        String tenantId = extractTenantId();
        return commandService.deleteNode(workflowId, nodeId, tenantId);
    }
    
    /**
     * Add connection
     */
    @Mutation("addConnection")
    @Description("Add connection between nodes")
    public Uni<ConnectionDTO> addConnection(
            @Name("workflowId") String workflowId,
            @Name("input") ConnectionInput input) {
        
        String tenantId = extractTenantId();
        String userId = extractUserId();
        return commandService.addConnection(workflowId, input, tenantId, userId);
    }
    
    /**
     * Lock node for editing
     */
    @Mutation("lockNode")
    @Description("Lock node for exclusive editing")
    public Uni<NodeLockDTO> lockNode(
            @Name("workflowId") String workflowId,
            @Name("nodeId") String nodeId) {
        
        String tenantId = extractTenantId();
        String userId = extractUserId();
        return commandService.lockNode(workflowId, nodeId, userId, tenantId);
    }
    
    /**
     * Unlock node
     */
    @Mutation("unlockNode")
    @Description("Unlock node")
    public Uni<Boolean> unlockNode(
            @Name("workflowId") String workflowId,
            @Name("nodeId") String nodeId) {
        
        String tenantId = extractTenantId();
        String userId = extractUserId();
        return commandService.unlockNode(workflowId, nodeId, userId, tenantId);
    }
    
    private String extractTenantId() {
        return context.getArgument("tenantId")
                .orElse(context.getHeader("X-Tenant-ID")
                .orElse("default"));
    }
    
    private String extractUserId() {
        return context.getArgument("userId")
                .orElse(context.getHeader("X-User-ID")
                .orElse("anonymous"));
    }
}

// ----------------------------------------------------------------------------
// 3. REST API - Operations & Heavy Lifting
// ----------------------------------------------------------------------------

package io.kayys.wayang.workflow.rest;

import io.kayys.wayang.workflow.domain.*;
import io.kayys.wayang.workflow.service.*;
import io.smallrye.mutiny.Uni;
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import org.eclipse.microprofile.openapi.annotations.Operation;
import org.eclipse.microprofile.openapi.annotations.tags.Tag;
import org.jboss.logging.Logger;
import org.jboss.resteasy.reactive.MultipartForm;
import org.jboss.resteasy.reactive.RestStreamElementType;

import java.io.File;
import java.util.UUID;

/**
 * Workflow REST API - Execution and heavy operations
 */
@Path("/api/v1/workflows")
@Tag(name = "Workflow Operations", description = "Workflow execution and management operations")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class WorkflowResource {
    
    private static final Logger LOG = Logger.getLogger(WorkflowResource.class);
    
    @Inject
    WorkflowExecutionService executionService;
    
    @Inject
    WorkflowPublishService publishService;
    
    @Inject
    WorkflowImportExportService importExportService;
    
    /**
     * Execute workflow
     */
    @POST
    @Path("/{id}/execute")
    @Operation(summary = "Execute workflow", description = "Start workflow execution")
    public Uni<Response> executeWorkflow(
            @PathParam("id") String workflowId,
            @HeaderParam("X-Tenant-ID") String tenantId,
            ExecutionRequest request) {
        
        LOG.infof("REST: Execute workflow %s (tenant=%s)", workflowId, tenantId);
        
        return executionService.execute(workflowId, request, tenantId)
                .map(execution -> Response.accepted()
                        .entity(execution)
                        .header("X-Execution-ID", execution.getId())
                        .build());
    }
    
    /**
     * Get execution status
     */
    @GET
    @Path("/executions/{executionId}")
    @Operation(summary = "Get execution status")
    public Uni<ExecutionStatus> getExecutionStatus(
            @PathParam("executionId") String executionId,
            @HeaderParam("X-Tenant-ID") String tenantId) {
        
        return executionService.getStatus(executionId, tenantId);
    }
    
    /**
     * Cancel execution
     */
    @POST
    @Path("/executions/{executionId}/cancel")
    @Operation(summary = "Cancel workflow execution")
    public Uni<Response> cancelExecution(
            @PathParam("executionId") String executionId,
            @HeaderParam("X-Tenant-ID") String tenantId) {
        
        return executionService.cancel(executionId, tenantId)
                .map(success -> Response.ok()
                        .entity(Map.of("cancelled", success))
                        .build());
    }
    
    /**
     * Publish workflow
     */
    @POST
    @Path("/{id}/publish")
    @Operation(summary = "Publish workflow", description = "Publish workflow to production")
    public Uni<Response> publishWorkflow(
            @PathParam("id") String workflowId,
            @HeaderParam("X-Tenant-ID") String tenantId,
            @HeaderParam("X-User-ID") String userId,
            PublishRequest request) {
        
        LOG.infof("REST: Publish workflow %s", workflowId);
        
        return publishService.publish(workflowId, request, tenantId, userId)
                .map(result -> Response.ok()
                        .entity(result)
                        .build());
    }
    
    /**
     * Export workflow
     */
    @GET
    @Path("/{id}/export")
    @Produces("application/zip")
    @Operation(summary = "Export workflow", description = "Export workflow with dependencies")
    public Uni<Response> exportWorkflow(
            @PathParam("id") String workflowId,
            @HeaderParam("X-Tenant-ID") String tenantId,
            @QueryParam("format") @DefaultValue("json") String format) {
        
        LOG.infof("REST: Export workflow %s (format=%s)", workflowId, format);
        
        return importExportService.export(workflowId, format, tenantId)
                .map(exportFile -> Response.ok(exportFile)
                        .header("Content-Disposition", 
                                "attachment; filename=workflow-" + workflowId + ".zip")
                        .build());
    }
    
    /**
     * Import workflow
     */
    @POST
    @Path("/import")
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Operation(summary = "Import workflow", description = "Import workflow from file")
    public Uni<Response> importWorkflow(
            @MultipartForm WorkflowImportForm form,
            @HeaderParam("X-Tenant-ID") String tenantId,
            @HeaderParam("X-User-ID") String userId) {
        
        LOG.infof("REST: Import workflow (tenant=%s, user=%s)", tenantId, userId);
        
        return importExportService.importWorkflow(form.file, tenantId, userId)
                .map(workflow -> Response.created(
                        URI.create("/api/v1/workflows/" + workflow.getId()))
                        .entity(workflow)
                        .build());
    }
    
    /**
     * Upload document/artifact
     */
    @POST
    @Path("/{id}/artifacts")
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Operation(summary = "Upload artifact", description = "Upload document or artifact")
    public Uni<Response> uploadArtifact(
            @PathParam("id") String workflowId,
            @MultipartForm ArtifactUploadForm form,
            @HeaderParam("X-Tenant-ID") String tenantId) {
        
        LOG.infof("REST: Upload artifact to workflow %s", workflowId);
        
        return importExportService.uploadArtifact(workflowId, form, tenantId)
                .map(artifact -> Response.created(
                        URI.create("/api/v1/workflows/" + workflowId + "/artifacts/" + artifact.getId()))
                        .entity(artifact)
                        .build());
    }
    
    /**
     * Download artifact
     */
    @GET
    @Path("/{id}/artifacts/{artifactId}")
    @Produces(MediaType.APPLICATION_OCTET_STREAM)
    @Operation(summary = "Download artifact")
    public Uni<Response> downloadArtifact(
            @PathParam("id") String workflowId,
            @PathParam("artifactId") String artifactId,
            @HeaderParam("X-Tenant-ID") String tenantId) {
        
        return importExportService.downloadArtifact(workflowId, artifactId, tenantId)
                .map(file -> Response.ok(file)
                        .header("Content-Disposition", 
                                "attachment; filename=" + file.getName())
                        .build());
    }
    
    /**
     * Generate standalone agent code
     */
    @POST
    @Path("/{id}/codegen")
    @Operation(summary = "Generate standalone code", 
               description = "Generate portable agent code")
    public Uni<Response> generateCode(
            @PathParam("id") String workflowId,
            @HeaderParam("X-Tenant-ID") String tenantId,
            CodeGenRequest request) {
        
        LOG.infof("REST: Generate code for workflow %s (target=%s)", 
            workflowId, request.getTarget());
        
        return executionService.generateCode(workflowId, request, tenantId)
                .map(artifact -> Response.accepted()
                        .entity(artifact)
                        .header("X-CodeGen-Job-ID", artifact.getJobId())
                        .build());
    }
}

// ----------------------------------------------------------------------------
// 4. WEBSOCKET API - Real-time Collaboration
// ----------------------------------------------------------------------------

package io.kayys.wayang.workflow.websocket;

import io.kayys.wayang.workflow.domain.*;
import io.kayys.wayang.workflow.service.CollaborationService;
import io.quarkus.websockets.next.*;
import io.smallrye.mutiny.Uni;
import jakarta.inject.Inject;
import org.jboss.logging.Logger;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Workflow Collaboration WebSocket
 * Handles real-time multi-user editing
 */
@WebSocket(path = "/ws/workflows/{workflowId}")
public class WorkflowCollaborationSocket {
    
    private static final Logger LOG = Logger.getLogger(WorkflowCollaborationSocket.class);
    
    @Inject
    CollaborationService collaborationService;
    
    // Active sessions: workflowId -> Set<sessionId>
    private final Map<String, Map<String, WebSocketConnection>> activeSessions = 
            new ConcurrentHashMap<>();
    
    /**
     * Client connected
     */
    @OnOpen
    public Uni<Void> onOpen(WebSocketConnection connection, 
                            @PathParam String workflowId) {
        
        String sessionId = connection.id();
        String userId = extractUserId(connection);
        String tenantId = extractTenantId(connection);
        
        LOG.infof("WS: User %s connected to workflow %s (session=%s, tenant=%s)", 
            userId, workflowId, sessionId, tenantId);
        
        // Register session
        activeSessions
            .computeIfAbsent(workflowId, k -> new ConcurrentHashMap<>())
            .put(sessionId, connection);
        
        // Notify other users
        return collaborationService.userJoined(workflowId, userId, tenantId)
            .invoke(event -> broadcastToWorkflow(workflowId, event, sessionId));
    }
    
    /**
     * Client disconnected
     */
    @OnClose
    public Uni<Void> onClose(WebSocketConnection connection,
                             @PathParam String workflowId) {
        
        String sessionId = connection.id();
        String userId = extractUserId(connection);
        String tenantId = extractTenantId(connection);
        
        LOG.infof("WS: User %s disconnected from workflow %s", userId, workflowId);
        
        // Unregister session
        Map<String, WebSocketConnection> sessions = activeSessions.get(workflowId);
        if (sessions != null) {
            sessions.remove(sessionId);
            if (sessions.isEmpty()) {
                activeSessions.remove(workflowId);
            }
        }
        
        // Release locks and notify
        return collaborationService.userLeft(workflowId, userId, tenantId)
            .invoke(event -> broadcastToWorkflow(workflowId, event, sessionId));
    }
    
    /**
     * Handle incoming messages
     */
    @OnTextMessage
    public Uni<Void> onMessage(String message,
                                WebSocketConnection connection,
                                @PathParam String workflowId) {
        
        String userId = extractUserId(connection);
        String tenantId = extractTenantId(connection);
        String sessionId = connection.id();
        
        CollaborationMessage msg = JsonUtils.fromJson(message, CollaborationMessage.class);
        
        LOG.debugf("WS: Received %s from user %s on workflow %s", 
            msg.getType(), userId, workflowId);
        
        return switch (msg.getType()) {
            case CURSOR_MOVE -> handleCursorMove(workflowId, userId, msg, sessionId);
            case NODE_MOVE -> handleNodeMove(workflowId, userId, msg, tenantId, sessionId);
            case NODE_LOCK -> handleNodeLock(workflowId, userId, msg, tenantId, sessionId);
            case NODE_UNLOCK -> handleNodeUnlock(workflowId, userId, msg, tenantId, sessionId);
            case NODE_UPDATE -> handleNodeUpdate(workflowId, userId, msg, tenantId, sessionId);
            case CONNECTION_ADD -> handleConnectionAdd(workflowId, userId, msg, tenantId, sessionId);
            case CONNECTION_DELETE -> handleConnectionDelete(workflowId, userId, msg, tenantId, sessionId);
            case SELECTION_CHANGE -> handleSelectionChange(workflowId, userId, msg, sessionId);
            default -> Uni.createFrom().voidItem();
        };
    }
    
    /**
     * Handle cursor movement
     */
    private Uni<Void> handleCursorMove(String workflowId, String userId,
                                        CollaborationMessage msg, String excludeSession) {
        
        CursorPosition cursor = msg.getPayload(CursorPosition.class);
        cursor.setUserId(userId);
        cursor.setTimestamp(System.currentTimeMillis());
        
        // Broadcast to others immediately (no persistence)
        CollaborationEvent event = CollaborationEvent.builder()
            .type(EventType.CURSOR_MOVED)
            .userId(userId)
            .workflowId(workflowId)
            .payload(cursor)
            .build();
        
        broadcastToWorkflow(workflowId, event, excludeSession);
        return Uni.createFrom().voidItem();
    }
    
    /**
     * Handle node movement
     */
    private Uni<Void> handleNodeMove(String workflowId, String userId,
                                      CollaborationMessage msg, String tenantId,
                                      String excludeSession) {
        
        NodeMovePayload moveData = msg.getPayload(NodeMovePayload.class);
        
        return collaborationService.moveNode(
                workflowId, moveData.getNodeId(), 
                moveData.getPosition(), userId, tenantId)
            .invoke(event -> broadcastToWorkflow(workflowId, event, excludeSession));
    }
    
    /**
     * Handle node lock
     */
    private Uni<Void> handleNodeLock(String workflowId, String userId,
                                      CollaborationMessage msg, String tenantId,
                                      String excludeSession) {
        
        String nodeId = msg.getPayload(String.class);
        
        return collaborationService.lockNode(workflowId, nodeId, userId, tenantId)
            .invoke(event -> broadcastToWorkflow(workflowId, event, excludeSession))
            .onFailure().recoverWithUni(error -> {
                // Send error back to requesting user only
                CollaborationEvent errorEvent = CollaborationEvent.builder()
                    .type(EventType.LOCK_FAILED)
                    .userId(userId)
                    .workflowId(workflowId)
                    .payload(Map.of("nodeId", nodeId, "error", error.getMessage()))
                    .build();
                
                sendToSession(excludeSession, errorEvent);
                return Uni.createFrom().voidItem();
            });
    }
    
    /**
     * Handle node unlock
     */
    private Uni<Void> handleNodeUnlock(String workflowId, String userId,
                                        CollaborationMessage msg, String tenantId,
                                        String excludeSession) {
        
        String nodeId = msg.getPayload(String.class);
        
        return collaborationService.unlockNode(workflowId, nodeId, userId, tenantId)
            .invoke(event -> broadcastToWorkflow(workflowId, event, excludeSession));
    }
    
    /**
     * Handle node update
     */
    private Uni<Void> handleNodeUpdate(String workflowId, String userId,
                                        CollaborationMessage msg, String tenantId,
                                        String excludeSession) {
        
        NodeUpdatePayload updateData = msg.getPayload(NodeUpdatePayload.class);
        
        return collaborationService.updateNode(
                workflowId, updateData.getNodeId(),
                updateData.getChanges(), userId, tenantId)
            .invoke(event -> broadcastToWorkflow(workflowId, event, excludeSession));
    }
    
    /**
     * Handle connection add
     */
    private Uni<Void> handleConnectionAdd(String workflowId, String userId,
                                           CollaborationMessage msg, String tenantId,
                                           String excludeSession) {
        
        ConnectionPayload connData = msg.getPayload(ConnectionPayload.class);
        
        return collaborationService.addConnection(workflowId, connData, userId, tenantId)
            .invoke(event -> broadcastToWorkflow(workflowId, event, excludeSession));
    }
    
    /**
     * Handle connection delete
     */
    private Uni<Void> handleConnectionDelete(String workflowId, String userId,
                                              CollaborationMessage msg, String tenantId,
                                              String excludeSession) {
        
        String connectionId = msg.getPayload(String.class);
        
        return collaborationService.deleteConnection(workflowId, connectionId, userId, tenantId)
            .invoke(event -> broadcastToWorkflow(workflowId, event, excludeSession));
    }
    
    /**
     * Handle selection change
     */
    private Uni<Void> handleSelectionChange(String workflowId, String userId,
                                             CollaborationMessage msg, String excludeSession) {
        
        SelectionPayload selection = msg.getPayload(SelectionPayload.class);
        selection.setUserId(userId);
        
        CollaborationEvent event = CollaborationEvent.builder()
            .type(EventType.SELECTION_CHANGED)
            .userId(userId)
            .workflowId(workflowId)
            .payload(selection)
            .build();
        
        broadcastToWorkflow(workflowId, event, excludeSession);
        return Uni.createFrom().voidItem();
    }
    
    /**
     * Broadcast event to all users in workflow except sender
     */
    private void broadcastToWorkflow(String workflowId, CollaborationEvent event,
                                      String excludeSessionId) {
        
        Map<String, WebSocketConnection> sessions = activeSessions.get(workflowId);
        if (sessions == null) return;
        
        String eventJson = JsonUtils.toJson(event);
        
        sessions.forEach((sessionId, connection) -> {
            if (!sessionId.equals(excludeSessionId)) {
                connection.sendText(eventJson);
            }
        });
    }
    
    /**
     * Send event to specific session
     */
    private void sendToSession(String sessionId, CollaborationEvent event) {
        activeSessions.values().stream()
            .flatMap(sessions -> sessions.entrySet().stream())
            .filter(entry -> entry.getKey().equals(sessionId))
            .findFirst()
            .ifPresent(entry -> {
                String eventJson = JsonUtils.toJson(event);
                entry.getValue().sendText(eventJson);
            });
    }
    
    private String extractUserId(WebSocketConnection connection) {
        return connection.handshakeRequest()
            .header("X-User-ID")
            .orElse("anonymous");
    }
    
    private String extractTenantId(WebSocketConnection connection) {
        return connection.handshakeRequest()
            .header("X-Tenant-ID")
            .orElse("default");
    }
}

// ----------------------------------------------------------------------------
// 5. DESIGNER SERVICE - Client to Workflow Service
// ----------------------------------------------------------------------------

package io.kayys.wayang.designer.client;

import io.kayys.wayang.designer.domain.*;
import io.smallrye.graphql.client.typesafe.api.GraphQLClientApi;
import io.smallrye.mutiny.Uni;
import org.eclipse.microprofile.graphql.*;
import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import java.util.List;

/**
 * GraphQL Client for Workflow Service
 */
@GraphQLClientApi(configKey = "workflow-service-graphql")
public interface WorkflowGraphQLClient {
    
    // Queries
    
    @Query("workflow")
    Uni<WorkflowDTO> getWorkflow(@Name("id") String id);
    
    @Query("workflows")
    Uni<WorkflowConnection> listWorkflows(
        @Name("filter") WorkflowFilterInput filter,
        @Name("page") PageInput page
    );
    
    @Query("nodeSchema")
    Uni<NodeSchemaDTO> getNodeSchema(@Name("id") String id);
    
    @Query("nodeSchemas")
    Uni<List<NodeSchemaDTO>> listNodeSchemas(
        @Name("filter") NodeSchemaFilterInput filter
    );
    
    @Query("validateWorkflow")
    Uni<ValidationResult> validateWorkflow(@Name("input") WorkflowInput input);
    
    @Query("compareWorkflows")
    Uni<WorkflowDiffDTO> compareWorkflows(
        @Name("baseId") String baseId,
        @Name("targetId") String targetId
    );
    
    // Mutations
    
    @Mutation("createWorkflow")
    Uni<WorkflowDTO> createWorkflow(@Name("input") CreateWorkflowInput input);
    
    @Mutation("updateWorkflow")
    Uni<WorkflowDTO> updateWorkflow(
        @Name("id") String id,
        @Name("input") UpdateWorkflowInput input
    );
    
    @Mutation("addNode")
    Uni<NodeDTO> addNode(
        @Name("workflowId") String workflowId,
        @Name("input") NodeInput input
    );
    
    @Mutation("lockNode")
    Uni<NodeLockDTO> lockNode(
        @Name("workflowId") String workflowId,
        @Name("nodeId") String nodeId
    );
}

/**
 * REST Client for Workflow Service operations
 */
@Path("/api/v1/workflows")
@RegisterRestClient(configKey = "workflow-service-rest")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public interface WorkflowRestClient {
    
    @POST
    @Path("/{id}/execute")
    Uni<ExecutionResponse> executeWorkflow(
        @PathParam("id") String workflowId,
        @HeaderParam("X-Tenant-ID") String tenantId,
        ExecutionRequest request
    );
    
    @GET
    @Path("/executions/{executionId}")
    Uni<ExecutionStatus> getExecutionStatus(
        @PathParam("executionId") String executionId,
        @HeaderParam("X-Tenant-ID") String tenantId
    );
    
    @POST
    @Path("/{id}/publish")
    Uni<PublishResponse> publishWorkflow(
        @PathParam("id") String workflowId,
        @HeaderParam("X-Tenant-ID") String tenantId,
        PublishRequest request
    );
    
    @GET
    @Path("/{id}/export")
    @Produces("application/zip")
    Uni<File> exportWorkflow(
        @PathParam("id") String workflowId,
        @HeaderParam("X-Tenant-ID") String tenantId,
        @QueryParam("format") String format
    );
    
    @POST
    @Path("/import")
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    Uni<WorkflowDTO> importWorkflow(
        @MultipartForm WorkflowImportForm form,
        @HeaderParam("X-Tenant-ID") String tenantId
    );
}

/**
 * Designer Service - Orchestrates GraphQL and REST clients
 */
@ApplicationScoped
public class DesignerWorkflowService {
    
    private static final Logger LOG = Logger.getLogger(DesignerWorkflowService.class);
    
    @Inject
    WorkflowGraphQLClient graphQLClient;
    
    @Inject
    WorkflowRestClient restClient;
    
    @Inject
    DesignerWebSocketClient wsClient;
    
    /**
     * Get workflow (GraphQL)
     */
    public Uni<WorkflowDTO> getWorkflow(String id, String tenantId) {
        LOG.infof("Designer: Fetching workflow %s via GraphQL", id);
        return graphQLClient.getWorkflow(id)
            .onFailure().retry().atMost(3);
    }
    
    /**
     * List workflows with filtering (GraphQL)
     */
    public Uni<WorkflowConnection> listWorkflows(WorkflowFilterInput filter, 
                                                   PageInput page) {
        LOG.infof("Designer: Listing workflows via GraphQL");
        return graphQLClient.listWorkflows(filter, page);
    }
    
    /**
     * Create workflow (GraphQL)
     */
    public Uni<WorkflowDTO> createWorkflow(CreateWorkflowInput input) {
        LOG.infof("Designer: Creating workflow via GraphQL");
        return graphQLClient.createWorkflow(input);
    }
    
    /**
     * Execute workflow (REST)
     */
    public Uni<ExecutionResponse> executeWorkflow(String workflowId, 
                                                    ExecutionRequest request,
                                                    String tenantId) {
        LOG.infof("Designer: Executing workflow %s via REST", workflowId);
        return restClient.executeWorkflow(workflowId, tenantId, request);
    }
    
    /**
     * Publish workflow (REST)
     */
    public Uni<PublishResponse> publishWorkflow(String workflowId,
                                                 PublishRequest request,
                                                 String tenantId) {
        LOG.infof("Designer: Publishing workflow %s via REST", workflowId);
        return restClient.publishWorkflow(workflowId, tenantId, request);
    }
    
    /**
     * Export workflow (REST)
     */
    public Uni<File> exportWorkflow(String workflowId, String format, 
                                     String tenantId) {
        LOG.infof("Designer: Exporting workflow %s via REST", workflowId);
        return restClient.exportWorkflow(workflowId, tenantId, format);
    }
    
    /**
     * Connect to collaboration WebSocket
     */
    public Uni<Void> connectCollaboration(String workflowId, String userId,
                                           String tenantId, 
                                           CollaborationHandler handler) {
        LOG.infof("Designer: Connecting to collaboration WebSocket for workflow %s", 
            workflowId);
        return wsClient.connect(workflowId, userId, tenantId, handler);
    }
}

// ----------------------------------------------------------------------------
// 6. CONFIGURATION
// ----------------------------------------------------------------------------

/**
 * application.yml for Workflow Service
 */
/*
quarkus:
  application:
    name: workflow-service
  
  # GraphQL
  smallrye-graphql:
    root-path: /graphql
    ui:
      enable: true
    
  # REST
  http:
    port: 8081
    
  # WebSocket
  websockets-next:
    server:
      per-message-deflate: true
      idle-timeout: 30m
    
  # Multi-tenancy
  hibernate-orm:
    multitenant: DISCRIMINATOR
    
  # Security
  security:
    jpa:
      enabled: true
  
  # Client configs
  rest-client:
    workflow-service-rest:
      url: ${WORKFLOW_SERVICE_URL:http://localhost:8081}
      scope: jakarta.inject.Singleton
      
  graphql-client:
    workflow-service-graphql:
      url: ${WORKFLOW_SERVICE_URL:http://localhost:8081}/graphql
      
  # Observability
  log:
    category:
      "io.kayys":
        level: INFO
  
  micrometer:
    enabled: true
    export:
      prometheus:
        enabled: true
*/

/**
 * application.yml for Designer Service
 */
/*
quarkus:
  application:
    name: designer-service
  
  http:
    port: 8080
    
  # Client to Workflow Service
  rest-client:
    workflow-service-rest:
      url: ${WORKFLOW_SERVICE_URL:http://localhost:8081}
      connect-timeout: 5000
      read-timeout: 30000
      
  graphql-client:
    workflow-service-graphql:
      url: ${WORKFLOW_SERVICE_URL:http://localhost:8081}/graphql
      
  # WebSocket client
  websockets-next:
    client:
      auto-reconnect: true
      reconnect-interval: 5s
*/

