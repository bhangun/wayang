# NodePlugin Enhancement: Complete Guide

## Overview

The enhanced `NodePlugin` interface transforms a basic plugin system into an **enterprise-grade, production-ready framework** with lifecycle management, observability, multi-tenancy, and advanced error handling.

---

## üìä Before vs After Comparison

### Original Interface (Basic)

```java
public interface NodePlugin extends Plugin {
    Map<String, NodeFactory> getNodeFactories();
    List<NodeDescriptor> getNodeDescriptors();
}
```

**Limitations:**
- ‚ùå No lifecycle management (init, start, stop)
- ‚ùå No health checks or readiness
- ‚ùå No metrics or monitoring
- ‚ùå No configuration validation
- ‚ùå No multi-tenancy support
- ‚ùå No error handling hooks
- ‚ùå No hot reload support
- ‚ùå Minimal metadata

### Enhanced Interface (Enterprise)

```java
public interface NodePlugin extends Plugin {
    // Core (Enhanced)
    Map<String, NodeFactoryRegistration> getNodeFactories();
    List<NodeDescriptor> getNodeDescriptors();
    Map<String, NodeCategory> getNodeCategories();
    
    // Lifecycle (NEW)
    Uni<Void> initialize(PluginContext context);
    Uni<Void> start();
    Uni<Void> stop(Duration timeout);
    Uni<Void> destroy();
    
    // Health & Monitoring (NEW)
    Uni<HealthCheckResult> healthCheck();
    Uni<ReadinessCheckResult> readinessCheck();
    PluginMetrics getMetrics();
    
    // Configuration (NEW)
    Optional<ConfigurationSchema> getConfigurationSchema();
    ValidationResult validateConfiguration(Map<String, Object> config);
    Uni<Void> updateConfiguration(Map<String, Object> config);
    
    // Multi-Tenancy (NEW)
    boolean isMultiTenantAware();
    Uni<Void> initializeTenant(String tenantId, Map<String, Object> config);
    Uni<Void> cleanupTenantResources(String tenantId);
    
    // Error Handling (NEW)
    Uni<ErrorHandlingDecision> handleNodeError(...);
    Uni<RecoveryResult> attemptRecovery(...);
    
    // Hot Reload (NEW)
    boolean supportsHotReload();
    Uni<PluginState> prepareForReload();
    Uni<Void> restoreState(PluginState state);
    
    // Advanced (NEW)
    Set<String> getCapabilities();
    PerformanceProfile getPerformanceProfile();
    PluginDocumentation getDocumentation();
    // + more...
}
```

**Advantages:**
- ‚úÖ Complete lifecycle control
- ‚úÖ Built-in health monitoring
- ‚úÖ Automatic metrics collection
- ‚úÖ Schema-based configuration
- ‚úÖ Native multi-tenancy
- ‚úÖ Sophisticated error handling
- ‚úÖ Zero-downtime updates
- ‚úÖ Rich metadata & documentation

---

## üéØ Key Improvements

### 1. **Lifecycle Management**

**Before:**
```java
// No initialization - plugin loaded and immediately used
// No cleanup - resources might leak
```

**After:**
```java
// Controlled lifecycle
plugin.initialize(context).await();  // Setup resources
plugin.start().await();              // Start services
// ... use plugin ...
plugin.stop(Duration.ofSeconds(30)).await();  // Graceful shutdown
plugin.destroy().await();            // Final cleanup
```

### 2. **Health & Readiness**

**Before:**
```java
// No way to check plugin health
// Can't tell if plugin is ready
```

**After:**
```java
// Kubernetes-style health checks
HealthCheckResult health = plugin.healthCheck().await();
if (!health.isHealthy()) {
    // Take action: restart, alert, etc.
}

ReadinessCheckResult ready = plugin.readinessCheck().await();
if (!ready.isReady()) {
    // Don't route traffic yet
}
```

### 3. **Metrics & Observability**

**Before:**
```java
// No built-in metrics
// Manual instrumentation required
```

**After:**
```java
// Automatic metrics collection
PluginMetrics metrics = plugin.getMetrics();
System.out.println("Requests: " + metrics.getRequestCount());
System.out.println("Errors: " + metrics.getErrorCount());
System.out.println("P95 Latency: " + metrics.getP95LatencyMs() + "ms");

// Per-node metrics
Map<String, Long> nodeCounts = metrics.getNodeExecutionCounts();
Map<String, Double> nodeLatencies = metrics.getNodeAverageLatencies();
```

### 4. **Configuration Validation**

**Before:**
```java
// No schema
// Runtime errors from bad config
Map<String, Object> config = Map.of("concurrency", "not-a-number");
plugin.configure(config); // Fails at runtime
```

**After:**
```java
// Schema-based validation
ConfigurationSchema schema = plugin.getConfigurationSchema().get();
ValidationResult result = plugin.validateConfiguration(config);

if (!result.isValid()) {
    for (ValidationError error : result.getErrors()) {
        System.err.println(error.getField() + ": " + error.getMessage());
    }
    // Fix issues before applying
}
```

### 5. **Multi-Tenancy**

**Before:**
```java
// Single global state
// Tenant data might mix
```

**After:**
```java
// Tenant isolation
if (plugin.isMultiTenantAware()) {
    plugin.initializeTenant("tenant-123", tenantConfig).await();
    
    // Get tenant-specific factory
    NodeFactory factory = plugin.getTenantNodeFactory(
        "data-processor",
        "tenant-123"
    ).get();
    
    // Cleanup when tenant leaves
    plugin.cleanupTenantResources("tenant-123").await();
}
```

### 6. **Error Handling**

**Before:**
```java
// Errors just thrown
// No recovery logic
try {
    node.execute(context);
} catch (Exception e) {
    // What now?
}
```

**After:**
```java
// Sophisticated error handling
ErrorHandlingDecision decision = plugin.handleNodeError(
    nodeId,
    error,
    context
).await();

switch (decision.getAction()) {
    case RETRY -> retry(maxAttempts);
    case ESCALATE -> escalateToHuman();
    case CUSTOM_RECOVERY -> {
        RecoveryResult result = plugin.attemptRecovery(nodeId, error).await();
        if (result.isRecovered()) {
            continueWithState(result.getRecoveredState());
        }
    }
}
```

### 7. **Hot Reload**

**Before:**
```java
// Restart entire system to update plugin
// Downtime required
```

**After:**
```java
if (plugin.supportsHotReload()) {
    // Save state
    PluginState state = oldPlugin.prepareForReload().await();
    
    // Unload old version
    oldPlugin.stop(Duration.ofSeconds(5)).await();
    
    // Load new version
    newPlugin.initialize(context).await();
    newPlugin.restoreState(state).await();
    newPlugin.start().await();
    
    // Zero downtime!
}
```

### 8. **Rich Metadata**

**Before:**
```java
// Minimal node info
NodeDescriptor descriptor = new NodeDescriptor(id, name);
```

**After:**
```java
// Comprehensive metadata
NodeFactoryRegistration registration = NodeFactoryRegistration.builder()
    .factory(factory)
    .nodeTypeId("data-transformer")
    .displayName("Data Transformer")
    .description("Transforms data using JSONPath")
    .icon("transform")
    .category("data-processing")
    .order(1)
    .experimental(false)
    .deprecated(false)
    .tags(Set.of("data", "transform", "etl"))
    .metadata(Map.of(
        "author", "Platform Team",
        "license", "Apache-2.0",
        "documentation", "https://docs.example.com"
    ))
    .build();
```

---

## üöÄ Migration Guide

### Step 1: Update Interface Implementation

**Before:**
```java
public class MyPlugin implements NodePlugin {
    @Override
    public Map<String, NodeFactory> getNodeFactories() {
        return Map.of("my-node", new MyNodeFactory());
    }
    
    @Override
    public List<NodeDescriptor> getNodeDescriptors() {
        return List.of(createDescriptor());
    }
}
```

**After:**
```java
public class MyPlugin implements NodePlugin {
    private PluginContext context;
    private boolean initialized = false;
    
    @Override
    public Map<String, NodeFactoryRegistration> getNodeFactories() {
        return Map.of(
            "my-node",
            NodeFactoryRegistration.builder()
                .factory(new MyNodeFactory())
                .nodeTypeId("my-node")
                .displayName("My Node")
                .category("custom")
                .build()
        );
    }
    
    @Override
    public List<NodeDescriptor> getNodeDescriptors() {
        return List.of(createEnhancedDescriptor());
    }
    
    @Override
    public Uni<Void> initialize(PluginContext context) {
        this.context = context;
        // Setup resources
        return Uni.createFrom().voidItem();
    }
    
    @Override
    public Uni<Void> start() {
        initialized = true;
        return Uni.createFrom().voidItem();
    }
    
    @Override
    public Uni<HealthCheckResult> healthCheck() {
        return Uni.createFrom().item(
            HealthCheckResult.healthy("Plugin OK")
        );
    }
    
    // Implement other methods as needed...
}
```

### Step 2: Add Configuration Schema

```java
@Override
public Optional<ConfigurationSchema> getConfigurationSchema() {
    return Optional.of(ConfigurationSchema.builder()
        .properties(Map.of(
            "timeout", PropertySchema.builder()
                .type("integer")
                .description("Timeout in milliseconds")
                .defaultValue(5000)
                .minimum(1000)
                .maximum(60000)
                .build(),
            "retries", PropertySchema.builder()
                .type("integer")
                .description("Max retry attempts")
                .defaultValue(3)
                .build()
        ))
        .required(List.of("timeout"))
        .build()
    );
}

@Override
public ValidationResult validateConfiguration(Map<String, Object> config) {
    ValidationResult result = ValidationResult.valid();
    
    Object timeout = config.get("timeout");
    if (timeout instanceof Number) {
        int value = ((Number) timeout).intValue();
        if (value < 1000 || value > 60000) {
            result.addError("timeout", "Must be between 1000 and 60000");
        }
    }
    
    return result;
}
```

### Step 3: Add Metrics

```java
private final AtomicLong requestCount = new AtomicLong(0);
private final AtomicLong errorCount = new AtomicLong(0);

@Override
public PluginMetrics getMetrics() {
    return PluginMetrics.builder()
        .requestCount(requestCount.get())
        .errorCount(errorCount.get())
        .averageLatencyMs(calculateLatency())
        .build();
}

// In your node execution:
public ExecutionResult execute(NodeContext context) {
    requestCount.incrementAndGet();
    try {
        // ... execute ...
        return ExecutionResult.success(result);
    } catch (Exception e) {
        errorCount.incrementAndGet();
        return ExecutionResult.error(e);
    }
}
```

### Step 4: Add Multi-Tenancy (Optional)

```java
private final Map<String, TenantContext> tenants = new ConcurrentHashMap<>();

@Override
public boolean isMultiTenantAware() {
    return true;
}

@Override
public Uni<Void> initializeTenant(String tenantId, Map<String, Object> config) {
    return Uni.createFrom().item(() -> {
        tenants.put(tenantId, new TenantContext(tenantId, config));
        return null;
    });
}

@Override
public Uni<Void> cleanupTenantResources(String tenantId) {
    return Uni.createFrom().item(() -> {
        TenantContext removed = tenants.remove(tenantId);
        if (removed != null) {
            removed.cleanup();
        }
        return null;
    });
}
```

---

## üìà Benefits Summary

| Feature | Before | After | Impact |
|---------|--------|-------|--------|
| **Lifecycle Control** | None | Full | Proper resource management |
| **Health Monitoring** | Manual | Automatic | Early problem detection |
| **Metrics** | External | Built-in | Real-time visibility |
| **Configuration** | Unvalidated | Schema-based | Fewer runtime errors |
| **Multi-Tenancy** | Not supported | Native | Tenant isolation |
| **Error Handling** | Basic | Advanced | Better resilience |
| **Hot Reload** | Not possible | Supported | Zero downtime |
| **Documentation** | Minimal | Rich | Better discoverability |

---

## üéì Best Practices

### 1. Always Implement Lifecycle Methods

Even if you don't need them now, provide implementations:

```java
@Override
public Uni<Void> initialize(PluginContext context) {
    LOG.info("Initializing plugin");
    // Future-proof: add initialization here when needed
    return Uni.createFrom().voidItem();
}
```

### 2. Make Health Checks Meaningful

```java
@Override
public Uni<HealthCheckResult> healthCheck() {
    // Check actual health, not just "return true"
    boolean databaseReachable = checkDatabase();
    boolean cacheAvailable = checkCache();
    
    if (!databaseReachable) {
        return Uni.createFrom().item(
            HealthCheckResult.unhealthy(
                "Database unreachable",
                Map.of("lastError", lastDbError)
            )
        );
    }
    
    return Uni.createFrom().item(HealthCheckResult.healthy("All systems OK"));
}
```

### 3. Provide Comprehensive Schemas

```java
@Override
public Optional<ConfigurationSchema> getConfigurationSchema() {
    // Don't just return empty - document your configuration!
    return Optional.of(ConfigurationSchema.builder()
        .properties(/* all config options */)
        .required(/* required fields */)
        .defaults(/* sensible defaults */)
        .build()
    );
}
```

### 4. Track Meaningful Metrics

```java
// Track more than just counts
private final Histogram latencyHistogram = new Histogram();

@Override
public PluginMetrics getMetrics() {
    return PluginMetrics.builder()
        .requestCount(requestCount.get())
        .errorCount(errorCount.get())
        .averageLatencyMs(latencyHistogram.mean())
        .p95LatencyMs(latencyHistogram.percentile(95))
        .p99LatencyMs(latencyHistogram.percentile(99))
        .nodeExecutionCounts(getPerNodeCounts())
        .build();
}
```

### 5. Support Hot Reload When Possible

```java
@Override
public boolean supportsHotReload() {
    return true; // Enable zero-downtime updates
}

@Override
public Uni<PluginState> prepareForReload() {
    // Save everything needed to resume
    return Uni.createFrom().item(
        PluginState.builder()
            .state(Map.of(
                "activeConnections", activeConnections,
                "cache", cacheSnapshot(),
                "config", config
            ))
            .build()
    );
}
```

---

## üîß Testing Your Enhanced Plugin

```java
@Test
public void testPluginLifecycle() {
    MyPlugin plugin = new MyPlugin();
    
    // Test initialization
    PluginContext context = PluginContext.builder()
        .pluginId("test-plugin")
        .version("1.0.0")
        .configuration(Map.of("timeout", 5000))
        .build();
    
    plugin.initialize(context).await().indefinitely();
    assertTrue(plugin.isInitialized());
    
    // Test start
    plugin.start().await().indefinitely();
    
    // Test health
    HealthCheckResult health = plugin.healthCheck().await().indefinitely();
    assertTrue(health.isHealthy());
    
    // Test metrics
    PluginMetrics metrics = plugin.getMetrics();
    assertEquals(0, metrics.getRequestCount());
    
    // Test configuration
    ValidationResult validation = plugin.validateConfiguration(
        Map.of("timeout", -1)
    );
    assertFalse(validation.isValid());
    
    // Test stop
    plugin.stop(Duration.ofSeconds(5)).await().indefinitely();
    plugin.destroy().await().indefinitely();
}
```

---

## üìö Additional Resources

- Full implementation example in `DataProcessingPlugin.java`
- Configuration schema examples
- Multi-tenancy patterns
- Hot reload strategies
- Metrics collection best practices

---

**Ready to upgrade?** Start with the lifecycle methods, add health checks, then gradually implement the other features. Each improvement makes your plugin more production-ready! üöÄ