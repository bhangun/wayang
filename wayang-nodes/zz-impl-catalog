package tech.kayys.wayang.nodes.builtin;

import io.smallrye.mutiny.Uni;
import tech.kayys.wayang.core.node.*;
import jakarta.enterprise.context.ApplicationScoped;

/**
 * ==============================================
 * CONTROL FLOW NODES
 * ==============================================
 */

/**
 * Start Node - Entry point for workflow execution
 * Validates initial inputs and sets up execution context
 */
@ApplicationScoped
@NodeType("builtin.start")
public class StartNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        return Uni.createFrom().item(() -> {
            // Validate workflow-level inputs
            var inputs = context.getAllInputs();
            
            // Emit workflow start event
            context.emitEvent("workflow.started", Map.of(
                "runId", context.getRunId(),
                "inputs", inputs,
                "timestamp", Instant.now()
            ));
            
            // Pass through inputs to next nodes
            return ExecutionResult.success(inputs);
        });
    }
}

/**
 * End Node - Terminal node for workflow completion
 * Collects final outputs and triggers cleanup
 */
@ApplicationScoped
@NodeType("builtin.end")
public class EndNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        return Uni.createFrom().item(() -> {
            var finalOutputs = context.getAllInputs();
            
            // Emit workflow completion event
            context.emitEvent("workflow.completed", Map.of(
                "runId", context.getRunId(),
                "outputs", finalOutputs,
                "timestamp", Instant.now()
            ));
            
            return ExecutionResult.success(finalOutputs);
        });
    }
}

/**
 * Decision Node - Conditional branching using CEL expressions
 * Routes execution based on evaluated conditions
 */
@ApplicationScoped
@NodeType("builtin.decision")
public class DecisionNode extends AbstractNode {
    
    private CelEngine celEngine;
    
    @Override
    protected void doOnLoad(NodeDescriptor descriptor, NodeConfig config) {
        this.celEngine = CelEngine.create();
    }
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        return Uni.createFrom().item(() -> {
            var condition = config.getString("condition");
            var celContext = buildCelContext(context);
            
            try {
                var result = celEngine.evaluate(condition, celContext);
                var branch = Boolean.TRUE.equals(result) ? "true" : "false";
                
                return ExecutionResult.success(Map.of(
                    "branch", branch,
                    "condition", condition,
                    "result", result
                ));
            } catch (Exception e) {
                throw new ValidationException("CEL evaluation failed: " + e.getMessage(), e);
            }
        });
    }
    
    private Map<String, Object> buildCelContext(NodeContext context) {
        var celCtx = new HashMap<String, Object>();
        celCtx.putAll(context.getAllInputs());
        celCtx.put("metadata", context.getMetadata());
        return celCtx;
    }
}

/**
 * Loop Node - Iterative execution over collections
 * Supports for-each pattern with configurable parallelism
 */
@ApplicationScoped
@NodeType("builtin.loop")
public class LoopNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var collection = (Collection<?>) context.getInput("collection");
        var maxParallel = config.getInt("maxParallel", 1);
        
        if (collection == null || collection.isEmpty()) {
            return Uni.createFrom().item(ExecutionResult.success(Map.of("items", List.of())));
        }
        
        // Execute iterations with controlled parallelism
        return Uni.join().all(
            collection.stream()
                .map(item -> executeIteration(context, item))
                .collect(Collectors.toList())
        ).andCollectFailures()
        .map(results -> ExecutionResult.success(Map.of(
            "items", results,
            "count", results.size()
        )));
    }
    
    private Uni<Object> executeIteration(NodeContext context, Object item) {
        // Create iteration-scoped context
        var iterationCtx = context.createChild();
        iterationCtx.setVariable("item", item);
        
        // Execute iteration logic (delegated to sub-workflow)
        return Uni.createFrom().item(item);
    }
}

/**
 * Merge Node - Combines multiple input branches
 * Supports various merge strategies (all, any, first)
 */
@ApplicationScoped
@NodeType("builtin.merge")
public class MergeNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        return Uni.createFrom().item(() -> {
            var strategy = config.getString("strategy", "all");
            var inputs = context.getAllInputs();
            
            var merged = switch (strategy) {
                case "all" -> mergeAll(inputs);
                case "first" -> mergeFirst(inputs);
                case "any" -> mergeAny(inputs);
                default -> throw new ValidationException("Unknown merge strategy: " + strategy);
            };
            
            return ExecutionResult.success(Map.of("merged", merged));
        });
    }
    
    private Map<String, Object> mergeAll(Map<String, Object> inputs) {
        // Wait for all branches, merge outputs
        var merged = new HashMap<String, Object>();
        inputs.forEach((key, value) -> {
            if (value instanceof Map) {
                merged.putAll((Map<String, Object>) value);
            }
        });
        return merged;
    }
    
    private Map<String, Object> mergeFirst(Map<String, Object> inputs) {
        // Return first non-null input
        return inputs.values().stream()
            .filter(v -> v != null)
            .findFirst()
            .map(v -> v instanceof Map ? (Map<String, Object>) v : Map.of("value", v))
            .orElse(Map.of());
    }
    
    private Map<String, Object> mergeAny(Map<String, Object> inputs) {
        // Return any non-null input
        return mergeFirst(inputs);
    }
}

/**
 * ==============================================
 * AI & LLM NODES
 * ==============================================
 */

/**
 * Agent Node - LLM-powered reasoning with chain-of-thought
 * Supports function calling, streaming, and persona injection
 */
@ApplicationScoped
@NodeType("builtin.agent")
public class AgentNode extends AbstractNode {
    
    @Inject
    ModelRouterClient modelRouter;
    
    @Inject
    PersonaService personaService;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        // Emit agent preparation event
        emitNodeEvent(context, "agent.preparing", Map.of(
            "stage", "preparing",
            "message", "Building prompt and selecting model"
        ));
        
        var prompt = buildPrompt(context);
        var modelHints = config.getObject("modelHints", Map.class);
        var functions = config.getList("functions", Map.class);
        
        var request = LLMRequest.builder()
            .prompt(prompt)
            .modelHints(modelHints)
            .functions(functions)
            .maxTokens(config.getInt("maxTokens", 1024))
            .temperature(config.getDouble("temperature", 0.7))
            .stream(config.getBoolean("stream", false))
            .metadata(Map.of(
                "runId", context.getRunId(),
                "nodeId", context.getNodeId(),
                "tenantId", context.getTenantId()
            ))
            .build();
        
        // Emit model calling event
        emitNodeEvent(context, "agent.calling.model", Map.of(
            "stage", "inference",
            "message", "Calling LLM for inference"
        ));
        
        return modelRouter.call(request)
            .onItem().invoke(response -> {
                // Emit response received event
                emitNodeEvent(context, "agent.response.received", Map.of(
                    "stage", "complete",
                    "message", "Response received from LLM",
                    "model", response.getModelId(),
                    "tokensUsed", response.getTokensUsed(),
                    "cost", response.getCost()
                ));
            })
            .map(response -> ExecutionResult.success(Map.of(
                "response", response.getOutput(),
                "model", response.getModelId(),
                "tokensUsed", response.getTokensUsed(),
                "cost", response.getCost(),
                "functionCalls", response.getFunctionCalls()
            )));
    }
    
    private Prompt buildPrompt(NodeContext context) {
        var personaId = config.getString("persona");
        var persona = personaId != null 
            ? personaService.getPersona(personaId) 
            : Persona.defaultPersona();
        
        var systemPrompt = persona.getSystemPrompt();
        var userMessage = context.getInput("message");
        
        return Prompt.builder()
            .system(systemPrompt)
            .user(userMessage)
            .context(buildContext(context))
            .build();
    }
    
    private Map<String, Object> buildContext(NodeContext context) {
        var ctx = new HashMap<String, Object>();
        
        // Add RAG context if available
        var ragContext = context.getInput("ragContext");
        if (ragContext != null) {
            ctx.put("knowledge", ragContext);
        }
        
        // Add memory context
        var memoryContext = context.getInput("memory");
        if (memoryContext != null) {
            ctx.put("memory", memoryContext);
        }
        
        return ctx;
    }
}

/**
 * RAG Node - Retrieval Augmented Generation
 * Performs hybrid search (vector + keyword) with re-ranking
 */
@ApplicationScoped
@NodeType("builtin.rag")
public class RAGNode extends AbstractNode {
    
    @Inject
    RAGClient ragClient;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var query = (String) context.getInput("query");
        var topK = config.getInt("topK", 5);
        var indexName = config.getString("index", "default");
        var useHybrid = config.getBoolean("hybrid", true);
        var rerank = config.getBoolean("rerank", true);
        
        var request = RAGRequest.builder()
            .query(query)
            .topK(topK)
            .index(indexName)
            .hybrid(useHybrid)
            .rerank(rerank)
            .filters(buildFilters(context))
            .build();
        
        return ragClient.retrieve(request)
            .map(response -> ExecutionResult.success(Map.of(
                "documents", response.getDocuments(),
                "scores", response.getScores(),
                "context", response.assembleContext(),
                "citations", response.getCitations()
            )));
    }
    
    private Map<String, Object> buildFilters(NodeContext context) {
        var filters = new HashMap<String, Object>();
        filters.put("tenantId", context.getTenantId());
        
        // Add custom filters from config
        var customFilters = config.getObject("filters", Map.class);
        if (customFilters != null) {
            filters.putAll(customFilters);
        }
        
        return filters;
    }
}

/**
 * Embedder Node - Generate embeddings for text
 * Supports batch processing and multiple embedding models
 */
@ApplicationScoped
@NodeType("builtin.embedder")
public class EmbedderNode extends AbstractNode {
    
    @Inject
    ModelRouterClient modelRouter;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var texts = (Collection<String>) context.getInput("texts");
        var model = config.getString("model", "default");
        
        if (texts == null || texts.isEmpty()) {
            return Uni.createFrom().item(ExecutionResult.success(Map.of("embeddings", List.of())));
        }
        
        var request = EmbedRequest.builder()
            .texts(new ArrayList<>(texts))
            .model(model)
            .normalize(config.getBoolean("normalize", true))
            .build();
        
        return modelRouter.embed(request)
            .map(response -> ExecutionResult.success(Map.of(
                "embeddings", response.getEmbeddings(),
                "dimensions", response.getDimensions(),
                "model", response.getModel()
            )));
    }
}

/**
 * ==============================================
 * MEMORY & STATE NODES
 * ==============================================
 */

/**
 * Memory Write Node - Store information in agent memory
 * Supports episodic, semantic, and procedural memory types
 */
@ApplicationScoped
@NodeType("builtin.memory.write")
public class MemoryWriteNode extends AbstractNode {
    
    @Inject
    MemoryClient memoryClient;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var content = context.getInput("content");
        var type = config.getString("type", "episodic");
        var ttl = config.getString("ttl", "P30D");
        
        var memory = Memory.builder()
            .type(MemoryType.valueOf(type.toUpperCase()))
            .content(content)
            .ttl(Duration.parse(ttl))
            .runId(context.getRunId())
            .tenantId(context.getTenantId())
            .metadata(context.getMetadata().toMap())
            .build();
        
        return memoryClient.write(memory)
            .map(memoryId -> ExecutionResult.success(Map.of(
                "memoryId", memoryId,
                "type", type
            )));
    }
}

/**
 * Memory Read Node - Retrieve relevant memories
 * Uses semantic search over stored memories
 */
@ApplicationScoped
@NodeType("builtin.memory.read")
public class MemoryReadNode extends AbstractNode {
    
    @Inject
    MemoryClient memoryClient;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var query = (String) context.getInput("query");
        var topK = config.getInt("topK", 5);
        var types = config.getList("types", String.class);
        
        var request = MemoryQuery.builder()
            .query(query)
            .topK(topK)
            .types(types != null ? types.stream().map(MemoryType::valueOf).collect(Collectors.toList()) : null)
            .tenantId(context.getTenantId())
            .build();
        
        return memoryClient.query(request)
            .map(memories -> ExecutionResult.success(Map.of(
                "memories", memories,
                "count", memories.size()
            )));
    }
}

/**
 * ==============================================
 * TOOL & INTEGRATION NODES
 * ==============================================
 */

/**
 * Tool Call Node - Execute external tools via MCP
 * Supports schema validation and retry logic
 */
@ApplicationScoped
@NodeType("builtin.tool")
public class ToolCallNode extends AbstractNode {
    
    @Inject
    ToolGatewayClient toolGateway;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var toolName = config.getString("tool");
        var parameters = context.getInput("parameters");
        
        var request = ToolRequest.builder()
            .tool(toolName)
            .parameters(parameters)
            .timeout(config.getInt("timeout", 30000))
            .runId(context.getRunId())
            .tenantId(context.getTenantId())
            .build();
        
        return toolGateway.execute(request)
            .map(response -> {
                if (response.isError()) {
                    return ExecutionResult.error(
                        ErrorPayload.builder()
                            .type(ErrorType.ToolError)
                            .message(response.getError())
                            .retryable(response.isRetryable())
                            .build()
                    );
                }
                
                return ExecutionResult.success(Map.of(
                    "result", response.getResult(),
                    "tool", toolName,
                    "duration", response.getDuration()
                ));
            });
    }
}

/**
 * HTTP Node - Make HTTP requests with full configurability
 * Supports all methods, headers, auth, and retries
 */
@ApplicationScoped
@NodeType("builtin.http")
public class HttpNode extends AbstractNode {
    
    @Inject
    @RestClient
    HttpClientService httpClient;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var url = config.getString("url");
        var method = config.getString("method", "GET");
        var headers = config.getObject("headers", Map.class);
        var body = context.getInput("body");
        
        var request = HttpRequest.builder()
            .url(url)
            .method(HttpMethod.valueOf(method))
            .headers(headers)
            .body(body)
            .timeout(config.getInt("timeout", 30000))
            .build();
        
        return httpClient.execute(request)
            .map(response -> ExecutionResult.success(Map.of(
                "status", response.getStatus(),
                "headers", response.getHeaders(),
                "body", response.getBody()
            )));
    }
}

/**
 * ==============================================
 * DATA TRANSFORMATION NODES
 * ==============================================
 */

/**
 * Transformer Node - Transform data using templates or scripts
 * Supports JSONPath, JOLT, and JavaScript transformations
 */
@ApplicationScoped
@NodeType("builtin.transform")
public class TransformerNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var input = context.getInput("data");
        var type = config.getString("type", "jsonpath");
        var template = config.getString("template");
        
        return Uni.createFrom().item(() -> {
            var transformed = switch (type) {
                case "jsonpath" -> applyJsonPath(input, template);
                case "jolt" -> applyJolt(input, template);
                case "javascript" -> applyJavaScript(input, template);
                default -> throw new ValidationException("Unknown transform type: " + type);
            };
            
            return ExecutionResult.success(Map.of("result", transformed));
        });
    }
    
    private Object applyJsonPath(Object input, String path) {
        return JsonPath.read(input, path);
    }
    
    private Object applyJolt(Object input, String spec) {
        var chainr = Chainr.fromSpec(JsonUtils.jsonToObject(spec));
        return chainr.transform(input);
    }
    
    private Object applyJavaScript(Object input, String script) {
        var engine = new ScriptEngineManager().getEngineByName("nashorn");
        engine.put("input", input);
        try {
            return engine.eval(script);
        } catch (ScriptException e) {
            throw new ValidationException("JavaScript execution failed", e);
        }
    }
}

/**
 * Validator Node - Validate data against schemas
 * Supports JSON Schema, CEL, and custom validators
 */
@ApplicationScoped
@NodeType("builtin.validator")
public class ValidatorNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var data = context.getInput("data");
        var schema = config.getObject("schema", Map.class);
        var celRules = config.getList("celRules", String.class);
        
        return Uni.createFrom().item(() -> {
            var errors = new ArrayList<String>();
            
            // JSON Schema validation
            if (schema != null) {
                var schemaErrors = SchemaValidator.validate(data, schema);
                errors.addAll(schemaErrors);
            }
            
            // CEL rules validation
            if (celRules != null) {
                var celErrors = validateCelRules(data, celRules);
                errors.addAll(celErrors);
            }
            
            var isValid = errors.isEmpty();
            
            return ExecutionResult.success(Map.of(
                "valid", isValid,
                "errors", errors,
                "data", data
            ));
        });
    }
    
    private List<String> validateCelRules(Object data, List<String> rules) {
        var errors = new ArrayList<String>();
        var celEngine = CelEngine.create();
        
        for (var rule : rules) {
            try {
                var result = celEngine.evaluate(rule, Map.of("data", data));
                if (!Boolean.TRUE.equals(result)) {
                    errors.add("Rule failed: " + rule);
                }
            } catch (Exception e) {
                errors.add("Rule error: " + e.getMessage());
            }
        }
        
        return errors;
    }
}

/**
 * ==============================================
 * ERROR HANDLING & OBSERVABILITY NODES
 * ==============================================
 */

/**
 * Error Handler Node - Process and route errors
 * Implements retry, fallback, auto-fix, and escalation logic
 */
@ApplicationScoped
@NodeType("builtin.error.handler")
public class ErrorHandlerNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var error = (ErrorPayload) context.getInput("error");
        var rules = config.getList("rules", Map.class);
        
        return Uni.createFrom().item(() -> {
            // Evaluate rules to determine action
            for (var rule : rules) {
                var condition = (String) rule.get("when");
                var action = (String) rule.get("action");
                
                if (evaluateErrorCondition(error, condition)) {
                    return ExecutionResult.success(Map.of(
                        "action", action,
                        "error", error,
                        "rule", rule.get("name")
                    ));
                }
            }
            
            // Default action
            return ExecutionResult.success(Map.of(
                "action", "abort",
                "error", error
            ));
        });
    }
    
    private boolean evaluateErrorCondition(ErrorPayload error, String condition) {
        var celEngine = CelEngine.create();
        var context = Map.of("error", error);
        
        try {
            var result = celEngine.evaluate(condition, context);
            return Boolean.TRUE.equals(result);
        } catch (Exception e) {
            context.getLogger().warn("Error condition evaluation failed", e);
            return false;
        }
    }
}

/**
 * Audit Node - Log events for compliance and tracing
 * Provides tamper-proof execution logs with optional signing
 */
@ApplicationScoped
@NodeType("builtin.audit")
public class AuditNode extends AbstractNode {
    
    @Inject
    AuditService auditService;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var event = context.getInput("event");
        var level = config.getString("level", "INFO");
        var tags = config.getList("tags", String.class);
        
        var auditEntry = AuditEntry.builder()
            .event(event)
            .level(AuditLevel.valueOf(level))
            .tags(tags)
            .runId(context.getRunId())
            .nodeId(context.getNodeId())
            .tenantId(context.getTenantId())
            .timestamp(Instant.now())
            .metadata(context.getMetadata().toMap())
            .build();
        
        return auditService.log(auditEntry)
            .map(auditId -> ExecutionResult.success(Map.of(
                "auditId", auditId,
                "level", level
            )));
    }
}

/**
 * Human-in-the-Loop Node - Pause for human review
 * Creates approval tasks and waits for human decision
 */
@ApplicationScoped
@NodeType("builtin.hitl")
public class HumanReviewNode extends AbstractNode {
    
    @Inject
    HITLService hitlService;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var data = context.getAllInputs();
        var reviewType = config.getString("reviewType", "approval");
        var timeout = config.getInt("timeout", 3600000); // 1 hour default
        
        var task = HITLTask.builder()
            .type(reviewType)
            .data(data)
            .runId(context.getRunId())
            .nodeId(context.getNodeId())
            .tenantId(context.getTenantId())
            .timeout(timeout)
            .build();
        
        return hitlService.createTask(task)
            .flatMap(taskId -> hitlService.waitForCompletion(taskId))
            .map(decision -> ExecutionResult.success(Map.of(
                "decision", decision.getAction(),
                "reviewer", decision.getReviewer(),
                "notes", decision.getNotes(),
                "correctedData", decision.getCorrectedData()
            )));
    }
    
    @Override
    public Optional<CheckpointState> checkpoint(NodeContext context) {
        // Support resumability after human review
        return Optional.of(CheckpointState.of(
            "awaiting_human_review",
            context.getAllInputs()
        ));
    }
}

/**
 * Self-Healing Node - Auto-repair errors using LLM
 * Attempts to fix malformed inputs or outputs
 */
@ApplicationScoped
@NodeType("builtin.self.heal")
public class SelfHealingNode extends AbstractNode {
    
    @Inject
    ModelRouterClient modelRouter;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var errorData = context.getInput("error");
        var schema = config.getObject("targetSchema", Map.class);
        var maxAttempts = config.getInt("maxAttempts", 2);
        
        var prompt = buildRepairPrompt(errorData, schema);
        
        var request = LLMRequest.builder()
            .prompt(prompt)
            .maxTokens(512)
            .temperature(0.1) // Low temperature for deterministic repair
            .build();
        
        return modelRouter.call(request)
            .map(response -> {
                var fixed = response.getOutput();
                
                // Validate fixed output against schema
                var errors = SchemaValidator.validate(fixed, schema);
                if (!errors.isEmpty()) {
                    return ExecutionResult.failed("Auto-fix failed validation");
                }
                
                return ExecutionResult.success(Map.of(
                    "fixed", fixed,
                    "original", errorData,
                    "tokensUsed", response.getTokensUsed()
                ));
            });
    }
    
    private Prompt buildRepairPrompt(Object errorData, Map<String, Object> schema) {
        return Prompt.builder()
            .system("You are a data repair assistant. Fix the provided data to match the schema.")
            .user(String.format(
                "Data: %s\n\nSchema: %s\n\nProvide corrected JSON only.",
                JsonUtils.toJson(errorData),
                JsonUtils.toJson(schema)
            ))
            .build();
    }
}