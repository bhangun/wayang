package tech.kayys.wayang.service.impl;

import tech.kayys.wayang.api.dto.*;
import tech.kayys.wayang.sdk.api.WorkflowEngineAPI;
import tech.kayys.wayang.sdk.client.*;
import tech.kayys.wayang.sdk.dto.*;
import tech.kayys.wayang.sdk.dto.workflow.*;
import tech.kayys.wayang.service.*;
import tech.kayys.wayang.repository.*;
import io.smallrye.mutiny.Multi;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.eclipse.microprofile.rest.client.inject.RestClient;
import org.jboss.logging.Logger;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

/**
 * WorkflowDesignerService - Manages workflow design and definition.
 * 
 * Responsibilities:
 * - Create, update, delete workflow definitions
 * - Validate workflow structure and compatibility
 * - Publish workflows for execution
 * - Version management
 * 
 * Architecture:
 * - Uses WorkflowDefinitionClient for persistence
 * - Validates against schema and invariants
 * - Multi-tenant isolated
 * - Audit trail for all changes
 * 
 * @since 1.0.0
 */
@ApplicationScoped
public class WorkflowDesignerServiceImpl implements WorkflowDesignerService {

    private static final Logger LOG = Logger.getLogger(WorkflowDesignerServiceImpl.class);

    @Inject
    @RestClient
    WorkflowDefinitionClient definitionClient;

    @Inject
    WorkflowRepository workflowRepository;

    @Inject
    AuditService auditService;

    @Inject
    ValidationService validationService;

    @Override
    public Uni<WorkflowDefinitionResponse> createWorkflow(
        WorkflowDesignRequest request, 
        String tenantId, 
        String userId
    ) {
        LOG.infof("Creating workflow: %s for tenant: %s", request.getName(), tenantId);

        return validationService.validateWorkflowDesign(request, tenantId)
            .onItem().transformToUni(validationResult -> {
                if (!validationResult.isValid()) {
                    return Uni.createFrom().failure(
                        new ValidationException("Workflow validation failed", validationResult)
                    );
                }

                // Convert design request to workflow definition
                WorkflowDefinitionRequest defRequest = new WorkflowDefinitionRequest();
                defRequest.setId(UUID.randomUUID().toString());
                defRequest.setName(request.getName());
                defRequest.setDescription(request.getDescription());
                defRequest.setVersion("1.0.0");
                defRequest.setTenantId(tenantId);
                defRequest.setCreatedBy(userId);
                defRequest.setCreatedAt(Instant.now().toString());
                defRequest.setNodes(request.getNodes());
                defRequest.setEdges(request.getEdges());
                defRequest.setMetadata(request.getMetadata());
                defRequest.setTags(request.getTags());

                // Save to registry
                return definitionClient.createWorkflow(defRequest);
            })
            .call(workflow -> auditService.logWorkflowCreated(workflow, userId))
            .invoke(workflow -> LOG.infof("Workflow created: %s", workflow.getId()));
    }

    @Override
    public Uni<WorkflowDefinitionResponse> updateWorkflow(
        String workflowId,
        WorkflowDesignRequest request,
        String tenantId,
        String userId
    ) {
        LOG.infof("Updating workflow: %s", workflowId);

        return validationService.validateWorkflowDesign(request, tenantId)
            .onItem().transformToUni(validationResult -> {
                if (!validationResult.isValid()) {
                    return Uni.createFrom().failure(
                        new ValidationException("Workflow validation failed", validationResult)
                    );
                }

                // Convert to update request
                WorkflowDefinitionRequest defRequest = new WorkflowDefinitionRequest();
                defRequest.setId(workflowId);
                defRequest.setName(request.getName());
                defRequest.setDescription(request.getDescription());
                defRequest.setNodes(request.getNodes());
                defRequest.setEdges(request.getEdges());
                defRequest.setMetadata(request.getMetadata());
                defRequest.setTags(request.getTags());

                return definitionClient.updateWorkflow(workflowId, defRequest);
            })
            .call(workflow -> auditService.logWorkflowUpdated(workflow, userId))
            .invoke(workflow -> LOG.infof("Workflow updated: %s", workflow.getId()));
    }

    @Override
    public Uni<WorkflowDefinitionResponse> getWorkflow(String workflowId, String tenantId) {
        return definitionClient.getWorkflow(workflowId)
            .onItem().transform(workflow -> {
                // Verify tenant ownership
                if (!workflow.getTenantId().equals(tenantId)) {
                    throw new ForbiddenException("Access denied to workflow: " + workflowId);
                }
                return workflow;
            });
    }

    @Override
    public Uni<PagedResponse<WorkflowDefinitionResponse>> listWorkflows(
        String tenantId,
        int page,
        int size,
        String status,
        List<String> tags
    ) {
        return definitionClient.listWorkflows(tenantId, tags)
            .map(workflows -> {
                // Filter by status if provided
                List<WorkflowDefinitionResponse> filtered = workflows;
                if (status != null) {
                    filtered = workflows.stream()
                        .filter(w -> status.equals(w.getStatus()))
                        .collect(Collectors.toList());
                }

                // Paginate
                int start = page * size;
                int end = Math.min(start + size, filtered.size());
                List<WorkflowDefinitionResponse> paged = filtered.subList(start, end);

                PagedResponse<WorkflowDefinitionResponse> response = new PagedResponse<>();
                response.setContent(paged);
                response.setPage(page);
                response.setSize(size);
                response.setTotalElements((long) filtered.size());
                response.setTotalPages((int) Math.ceil((double) filtered.size() / size));
                return response;
            });
    }

    @Override
    public Uni<ValidationResponse> validateWorkflow(
        WorkflowDesignRequest request,
        String tenantId
    ) {
        return validationService.validateWorkflowDesign(request, tenantId);
    }

    @Override
    public Uni<WorkflowDefinitionResponse> publishWorkflow(
        String workflowId,
        String version,
        String tenantId,
        String userId
    ) {
        LOG.infof("Publishing workflow: %s version: %s", workflowId, version);

        return definitionClient.publishWorkflow(workflowId, version)
            .call(workflow -> auditService.logWorkflowPublished(workflow, userId, version))
            .invoke(workflow -> LOG.infof("Workflow published: %s", workflow.getId()));
    }

    @Override
    public Uni<Void> deleteWorkflow(String workflowId, String tenantId) {
        return getWorkflow(workflowId, tenantId)
            .onItem().transformToUni(workflow -> 
                definitionClient.deleteWorkflow(workflowId)
            )
            .call(() -> auditService.logWorkflowDeleted(workflowId, tenantId));
    }
}

/**
 * WorkflowExecutionService - Manages workflow execution and monitoring.
 * 
 * Responsibilities:
 * - Execute workflows via WorkflowEngineClient
 * - Monitor execution status
 * - Handle errors and recovery
 * - Manage human tasks (HITL)
 * - Provide metrics and analytics
 * 
 * Architecture:
 * - Delegates to WorkflowEngineClient for actual execution
 * - Wraps engine responses with additional context
 * - Multi-tenant isolated
 * - Real-time streaming support
 * 
 * @since 1.0.0
 */
@ApplicationScoped
public class WorkflowExecutionServiceImpl implements WorkflowExecutionService {

    private static final Logger LOG = Logger.getLogger(WorkflowExecutionServiceImpl.class);

    @Inject
    @RestClient
    WorkflowEngineClient engineClient;

    @Inject
    @RestClient
    WorkflowDefinitionClient definitionClient;

    @Inject
    @RestClient
    HITLClient hitlClient;

    @Inject
    WorkflowEngineAPI workflowAPI;

    @Inject
    AuditService auditService;

    @Inject
    WorkflowRunRepository runRepository;

    @Override
    public Uni<WorkflowRunResponse> executeWorkflow(
        String workflowId,
        WorkflowExecutionRequest request,
        String tenantId,
        String userId
    ) {
        LOG.infof("Executing workflow: %s for tenant: %s", workflowId, tenantId);

        // Get workflow definition to determine type
        return definitionClient.getWorkflow(workflowId)
            .onItem().transformToUni(workflow -> {
                // Verify tenant ownership
                if (!workflow.getTenantId().equals(tenantId)) {
                    return Uni.createFrom().failure(
                        new ForbiddenException("Access denied to workflow: " + workflowId)
                    );
                }

                // Determine workflow type and execute accordingly
                String workflowType = determineWorkflowType(workflow, request);
                
                return executeByType(workflowId, workflowType, request, tenantId, userId);
            })
            .call(run -> auditService.logWorkflowExecuted(run, userId))
            .invoke(run -> LOG.infof("Workflow execution started: runId=%s", run.getRunId()));
    }

    private Uni<WorkflowRunResponse> executeByType(
        String workflowId,
        String workflowType,
        WorkflowExecutionRequest request,
        String tenantId,
        String userId
    ) {
        switch (workflowType) {
            case "agentic":
                return executeAgenticWorkflow(workflowId, request, tenantId, userId);
            
            case "integration":
                return executeIntegrationWorkflow(workflowId, request, tenantId, userId);
            
            case "business":
                return executeBusinessWorkflow(workflowId, request, tenantId, userId);
            
            default:
                return executeUnifiedWorkflow(workflowId, request, tenantId, userId);
        }
    }

    private Uni<WorkflowRunResponse> executeAgenticWorkflow(
        String workflowId,
        WorkflowExecutionRequest request,
        String tenantId,
        String userId
    ) {
        AgenticWorkflowRequest agenticRequest = AgenticWorkflowRequest.builder()
            .workflowId(workflowId)
            .tenantId(tenantId)
            .triggeredBy(userId)
            .agentConfig(request.getAgentConfig())
            .build();
        
        // Copy inputs
        if (request.getInputs() != null) {
            request.getInputs().forEach((k, v) -> 
                agenticRequest.getInputs().put(k, v));
        }

        return engineClient.executeAgenticWorkflow(agenticRequest);
    }

    private Uni<WorkflowRunResponse> executeIntegrationWorkflow(
        String workflowId,
        WorkflowExecutionRequest request,
        String tenantId,
        String userId
    ) {
        IntegrationWorkflowRequest integrationRequest = IntegrationWorkflowRequest.builder()
            .workflowId(workflowId)
            .tenantId(tenantId)
            .triggeredBy(userId)
            .integrationConfig(request.getIntegrationConfig())
            .batchConfig(request.getBatchConfig())
            .build();
        
        if (request.getInputs() != null) {
            request.getInputs().forEach((k, v) -> 
                integrationRequest.getInputs().put(k, v));
        }

        return engineClient.executeIntegrationWorkflow(integrationRequest);
    }

    private Uni<WorkflowRunResponse> executeBusinessWorkflow(
        String workflowId,
        WorkflowExecutionRequest request,
        String tenantId,
        String userId
    ) {
        BusinessWorkflowRequest businessRequest = BusinessWorkflowRequest.builder()
            .workflowId(workflowId)
            .tenantId(tenantId)
            .triggeredBy(userId)
            .businessConfig(request.getBusinessConfig())
            .build();
        
        if (request.getInputs() != null) {
            request.getInputs().forEach((k, v) -> 
                businessRequest.getInputs().put(k, v));
        }

        return engineClient.executeBusinessWorkflow(businessRequest);
    }

    private Uni<WorkflowRunResponse> executeUnifiedWorkflow(
        String workflowId,
        WorkflowExecutionRequest request,
        String tenantId,
        String userId
    ) {
        UnifiedWorkflowRequest unifiedRequest = UnifiedWorkflowRequest.builder()
            .workflowId(workflowId)
            .tenantId(tenantId)
            .build();
        
        if (request.getInputs() != null) {
            request.getInputs().forEach((k, v) -> 
                unifiedRequest.getInputs().put(k, v));
        }

        return engineClient.executeWorkflow(unifiedRequest);
    }

    @Override
    public Uni<WorkflowRunDetailResponse> getWorkflowRunDetails(String runId, String tenantId) {
        return engineClient.getWorkflowRun(runId)
            .onItem().transformToUni(run -> {
                // Verify tenant ownership
                if (!run.getTenantId().equals(tenantId)) {
                    return Uni.createFrom().failure(
                        new ForbiddenException("Access denied to run: " + runId)
                    );
                }

                // Get additional details
                return Uni.combine().all()
                    .unis(
                        engineClient.getWorkflowState(runId),
                        engineClient.getExecutionHistory(runId),
                        engineClient.getWorkflowErrors(runId)
                    )
                    .combinedWith((state, history, errors) -> {
                        WorkflowRunDetailResponse detail = new WorkflowRunDetailResponse();
                        detail.setRun(run);
                        detail.setState(state);
                        detail.setHistory(history);
                        detail.setErrors(errors);
                        return detail;
                    });
            });
    }

    @Override
    public Uni<List<NodeExecutionRecord>> getExecutionHistory(String runId, String tenantId) {
        return engineClient.getWorkflowRun(runId)
            .onItem().transformToUni(run -> {
                if (!run.getTenantId().equals(tenantId)) {
                    return Uni.createFrom().failure(
                        new ForbiddenException("Access denied to run: " + runId)
                    );
                }
                return engineClient.getExecutionHistory(runId);
            });
    }

    @Override
    public Multi<WorkflowExecutionEvent> streamExecution(String runId, String tenantId) {
        // Verify tenant ownership first
        return Multi.createFrom().uni(
            engineClient.getWorkflowRun(runId)
                .onItem().transform(run -> {
                    if (!run.getTenantId().equals(tenantId)) {
                        throw new ForbiddenException("Access denied to run: " + runId);
                    }
                    return run;
                })
        ).onItem().transformToMulti(run -> engineClient.streamExecution(runId));
    }

    @Override
    public Uni<PagedResponse<WorkflowRunSummary>> listWorkflowRuns(
        String tenantId,
        String workflowId,
        String status,
        int page,
        int size
    ) {
        return engineClient.listWorkflowRuns(workflowId, page, size)
            .map(runs -> {
                // Filter by tenant and status
                List<WorkflowRunResponse> filtered = runs.stream()
                    .filter(r -> r.getTenantId().equals(tenantId))
                    .filter(r -> status == null || status.equals(r.getStatus()))
                    .collect(Collectors.toList());

                // Convert to summaries
                List<WorkflowRunSummary> summaries = filtered.stream()
                    .map(this::toSummary)
                    .collect(Collectors.toList());

                PagedResponse<WorkflowRunSummary> response = new PagedResponse<>();
                response.setContent(summaries);
                response.setPage(page);
                response.setSize(size);
                response.setTotalElements((long) summaries.size());
                response.setTotalPages((int) Math.ceil((double) summaries.size() / size));
                return response;
            });
    }

    @Override
    public Uni<WorkflowRunResponse> pauseWorkflow(String runId, String reason, String tenantId) {
        return verifyTenantAccess(runId, tenantId)
            .onItem().transformToUni(v -> engineClient.pauseWorkflow(runId, reason));
    }

    @Override
    public Uni<WorkflowRunResponse> resumeWorkflow(String runId, String tenantId) {
        return verifyTenantAccess(runId, tenantId)
            .onItem().transformToUni(v -> engineClient.resumeWorkflow(runId));
    }

    @Override
    public Uni<WorkflowRunResponse> cancelWorkflow(
        String runId,
        CancelWorkflowRequest request,
        String tenantId
    ) {
        return verifyTenantAccess(runId, tenantId)
            .onItem().transformToUni(v -> engineClient.cancelWorkflow(runId, request));
    }

    @Override
    public Uni<WorkflowRunResponse> retryWorkflow(
        String runId,
        RetryWorkflowRequest request,
        String tenantId
    ) {
        return verifyTenantAccess(runId, tenantId)
            .onItem().transformToUni(v -> engineClient.retryWorkflow(runId, request));
    }

    @Override
    public Uni<List<ErrorPayloadResponse>> getWorkflowErrors(String runId, String tenantId) {
        return verifyTenantAccess(runId, tenantId)
            .onItem().transformToUni(v -> engineClient.getWorkflowErrors(runId));
    }

    @Override
    public Uni<SelfHealingResponse> triggerSelfHealing(
        String runId,
        String nodeId,
        String tenantId
    ) {
        return verifyTenantAccess(runId, tenantId)
            .onItem().transformToUni(v -> engineClient.triggerSelfHealing(runId, nodeId));
    }

    @Override
    public Uni<HumanTaskResponse> escalateToHuman(
        String runId,
        String nodeId,
        EscalationRequest request,
        String tenantId,
        String userId
    ) {
        return verifyTenantAccess(runId, tenantId)
            .onItem().transformToUni(v -> 
                engineClient.escalateToHuman(runId, nodeId, request)
            )
            .call(task -> auditService.logTaskEscalated(task, userId));
    }

    @Override
    public Uni<List<HumanTaskResponse>> getPendingTasksForUser(String userId, String priority) {
        TaskPriority taskPriority = priority != null ? TaskPriority.valueOf(priority) : null;
        return hitlClient.getPendingTasks(userId, taskPriority);
    }

    @Override
    public Uni<HumanTaskResponse> getTaskDetails(String taskId, String userId) {
        return hitlClient.getTask(taskId);
    }

    @Override
    public Uni<Void> completeTask(
        String taskId,
        TaskCompletionRequest request,
        String userId
    ) {
        return hitlClient.completeTask(taskId, request)
            .call(() -> auditService.logTaskCompleted(taskId, userId, request));
    }

    @Override
    public Uni<Void> addTaskComment(String taskId, TaskCommentRequest comment) {
        return hitlClient.addComment(taskId, comment);
    }

    @Override
    public Uni<WorkflowMetricsResponse> getWorkflowMetrics(
        String workflowId,
        int days,
        String tenantId
    ) {
        MetricsRequest metricsRequest = new MetricsRequest();
        metricsRequest.setFromTime(Instant.now().minus(days, ChronoUnit.DAYS));
        metricsRequest.setToTime(Instant.now());
        metricsRequest.setIncludeNodeMetrics(true);

        return engineClient.getWorkflowMetrics(workflowId, metricsRequest);
    }

    @Override
    public Uni<DashboardStatsResponse> getDashboardStats(String tenantId) {
        // Aggregate statistics from multiple sources
        return Uni.combine().all()
            .unis(
                runRepository.countRunsByTenant(tenantId),
                runRepository.countRunsByStatus(tenantId, "RUNNING"),
                runRepository.countRunsByStatus(tenantId, "FAILED"),
                hitlClient.getPendingTasks(null, null)
            )
            .combinedWith((totalRuns, runningRuns, failedRuns, pendingTasks) -> {
                DashboardStatsResponse stats = new DashboardStatsResponse();
                stats.setTotalWorkflowRuns(totalRuns);
                stats.setRunningWorkflows(runningRuns);
                stats.setFailedWorkflows(failedRuns);
                stats.setPendingTasks(pendingTasks.size());
                return stats;
            });
    }

    // Helper methods

    private Uni<Void> verifyTenantAccess(String runId, String tenantId) {
        return engineClient.getWorkflowRun(runId)
            .onItem().transform(run -> {
                if (!run.getTenantId().equals(tenantId)) {
                    throw new ForbiddenException("Access denied to run: " + runId);
                }
                return null;
            });
    }

    private String determineWorkflowType(
        WorkflowDefinitionResponse workflow,
        WorkflowExecutionRequest request
    ) {
        // Check metadata first
        if (workflow.getMetadata() != null && workflow.getMetadata().containsKey("type")) {
            return (String) workflow.getMetadata().get("type");
        }

        // Infer from request configuration
        if (request.getAgentConfig() != null) {
            return "agentic";
        } else if (request.getIntegrationConfig() != null) {
            return "integration";
        } else if (request.getBusinessConfig() != null) {
            return "business";
        }

        // Default to unified
        return "unified";
    }

    private WorkflowRunSummary toSummary(WorkflowRunResponse run) {
        WorkflowRunSummary summary = new WorkflowRunSummary();
        summary.setRunId(run.getRunId());
        summary.setWorkflowId(run.getWorkflowId());
        summary.setStatus(run.getStatus());
        summary.setStartedAt(run.getStartedAt());
        summary.setCompletedAt(run.getCompletedAt());
        summary.setDurationMs(run.getDurationMs());
        return summary;
    }
}

/**
 * NodeTypeService - Interface for node type catalog.
 */
interface NodeTypeService {
    Uni<NodeTypeCatalogResponse> getNodeTypeCatalog(String tenantId);
    Uni<NodeTypeDescriptor> getNodeTypeDescriptor(String nodeTypeId, String tenantId);
    Uni<List<NodeTypeDescriptor>> searchNodeTypes(String query, String category, String tenantId);
}

/**
 * WorkflowDesignerService - Interface for workflow design operations.
 */
interface WorkflowDesignerService {
    Uni<WorkflowDefinitionResponse> createWorkflow(
        WorkflowDesignRequest request, String tenantId, String userId
    );
    Uni<WorkflowDefinitionResponse> updateWorkflow(
        String workflowId, WorkflowDesignRequest request, String tenantId, String userId
    );
    Uni<WorkflowDefinitionResponse> getWorkflow(String workflowId, String tenantId);
    Uni<PagedResponse<WorkflowDefinitionResponse>> listWorkflows(
        String tenantId, int page, int size, String status, List<String> tags
    );
    Uni<ValidationResponse> validateWorkflow(WorkflowDesignRequest request, String tenantId);
    Uni<WorkflowDefinitionResponse> publishWorkflow(
        String workflowId, String version, String tenantId, String userId
    );
    Uni<Void> deleteWorkflow(String workflowId, String tenantId);
}

/**
 * WorkflowExecutionService - Interface for workflow execution operations.
 */
interface WorkflowExecutionService {
    Uni<WorkflowRunResponse> executeWorkflow(
        String workflowId, WorkflowExecutionRequest request, String tenantId, String userId
    );
    Uni<WorkflowRunDetailResponse> getWorkflowRunDetails(String runId, String tenantId);
    Uni<List<NodeExecutionRecord>> getExecutionHistory(String runId, String tenantId);
    Multi<WorkflowExecutionEvent> streamExecution(String runId, String tenantId);
    Uni<PagedResponse<WorkflowRunSummary>> listWorkflowRuns(
        String tenantId, String workflowId, String status, int page, int size
    );
    Uni<WorkflowRunResponse> pauseWorkflow(String runId, String reason, String tenantId);
    Uni<WorkflowRunResponse> resumeWorkflow(String runId, String tenantId);
    Uni<WorkflowRunResponse> cancelWorkflow(
        String runId, CancelWorkflowRequest request, String tenantId
    );
    Uni<WorkflowRunResponse> retryWorkflow(
        String runId, RetryWorkflowRequest request, String tenantId
    );
    Uni<List<ErrorPayloadResponse>> getWorkflowErrors(String runId, String tenantId);
    Uni<SelfHealingResponse> triggerSelfHealing(String runId, String nodeId, String tenantId);
    Uni<HumanTaskResponse> escalateToHuman(
        String runId, String nodeId, EscalationRequest request, String tenantId, String userId
    );
    Uni<List<HumanTaskResponse>> getPendingTasksForUser(String userId, String priority);
    Uni<HumanTaskResponse> getTaskDetails(String taskId, String userId);
    Uni<Void> completeTask(String taskId, TaskCompletionRequest request, String userId);
    Uni<Void> addTaskComment(String taskId, TaskCommentRequest comment);
    Uni<WorkflowMetricsResponse> getWorkflowMetrics(String workflowId, int days, String tenantId);
    Uni<DashboardStatsResponse> getDashboardStats(String tenantId);
}

/**
 * Custom exceptions for service layer.
 */
class ValidationException extends RuntimeException {
    private final ValidationResponse validationResponse;

    public ValidationException(String message, ValidationResponse validationResponse) {
        super(message);
        this.validationResponse = validationResponse;
    }

    public ValidationResponse getValidationResponse() {
        return validationResponse;
    }
}

class ForbiddenException extends RuntimeException {
    public ForbiddenException(String message) {
        super(message);
    }
}

package tech.kayys.wayang.service;

import tech.kayys.wayang.api.dto.*;
import tech.kayys.wayang.sdk.dto.*;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.jboss.logging.Logger;

import java.time.Instant;
import java.util.*;

/**
 * AuditService - Handles audit logging for all operations.
 * 
 * Responsibilities:
 * - Log all workflow operations (create, update, execute, etc.)
 * - Log human task operations
 * - Log error escalations
 * - Provide audit trail for compliance
 * 
 * Architecture:
 * - Async non-blocking audit writes
 * - Multi-tenant isolated
 * - Cryptographic hashing for tamper-proof logs
 * - Retention policy enforcement
 * 
 * @since 1.0.0
 */
@ApplicationScoped
public class AuditService {

    private static final Logger LOG = Logger.getLogger(AuditService.class);

    @Inject
    AuditRepository auditRepository;

    public Uni<Void> logWorkflowCreated(WorkflowDefinitionResponse workflow, String userId) {
        AuditEntry entry = AuditEntry.builder()
            .eventType("WORKFLOW_CREATED")
            .subjectType("workflow")
            .subjectId(workflow.getId())
            .tenantId(workflow.getTenantId())
            .actor(userId)
            .timestamp(Instant.now())
            .details(Map.of(
                "name", workflow.getName(),
                "version", workflow.getVersion()
            ))
            .build();

        return auditRepository.save(entry)
            .invoke(() -> LOG.infof("Audit: Workflow created - %s by %s", 
                workflow.getId(), userId));
    }

    public Uni<Void> logWorkflowUpdated(WorkflowDefinitionResponse workflow, String userId) {
        AuditEntry entry = AuditEntry.builder()
            .eventType("WORKFLOW_UPDATED")
            .subjectType("workflow")
            .subjectId(workflow.getId())
            .tenantId(workflow.getTenantId())
            .actor(userId)
            .timestamp(Instant.now())
            .details(Map.of(
                "name", workflow.getName(),
                "version", workflow.getVersion()
            ))
            .build();

        return auditRepository.save(entry);
    }

    public Uni<Void> logWorkflowPublished(
        WorkflowDefinitionResponse workflow,
        String userId,
        String version
    ) {
        AuditEntry entry = AuditEntry.builder()
            .eventType("WORKFLOW_PUBLISHED")
            .subjectType("workflow")
            .subjectId(workflow.getId())
            .tenantId(workflow.getTenantId())
            .actor(userId)
            .timestamp(Instant.now())
            .details(Map.of(
                "name", workflow.getName(),
                "version", version,
                "previousVersion", workflow.getVersion()
            ))
            .build();

        return auditRepository.save(entry)
            .invoke(() -> LOG.infof("Audit: Workflow published - %s version %s by %s", 
                workflow.getId(), version, userId));
    }

    public Uni<Void> logWorkflowDeleted(String workflowId, String tenantId) {
        AuditEntry entry = AuditEntry.builder()
            .eventType("WORKFLOW_DELETED")
            .subjectType("workflow")
            .subjectId(workflowId)
            .tenantId(tenantId)
            .actor("system")
            .timestamp(Instant.now())
            .build();

        return auditRepository.save(entry);
    }

    public Uni<Void> logWorkflowExecuted(WorkflowRunResponse run, String userId) {
        AuditEntry entry = AuditEntry.builder()
            .eventType("WORKFLOW_EXECUTED")
            .subjectType("workflow_run")
            .subjectId(run.getRunId())
            .tenantId(run.getTenantId())
            .actor(userId)
            .timestamp(Instant.now())
            .details(Map.of(
                "workflowId", run.getWorkflowId(),
                "status", run.getStatus()
            ))
            .build();

        return auditRepository.save(entry)
            .invoke(() -> LOG.infof("Audit: Workflow executed - %s by %s", 
                run.getWorkflowId(), userId));
    }

    public Uni<Void> logTaskEscalated(HumanTaskResponse task, String userId) {
        AuditEntry entry = AuditEntry.builder()
            .eventType("TASK_ESCALATED")
            .subjectType("human_task")
            .subjectId(task.getTaskId())
            .tenantId(task.getTenantId())
            .actor(userId)
            .timestamp(Instant.now())
            .details(Map.of(
                "priority", task.getPriority(),
                "assignedTo", task.getAssignedTo()
            ))
            .build();

        return auditRepository.save(entry);
    }

    public Uni<Void> logTaskCompleted(
        String taskId,
        String userId,
        TaskCompletionRequest request
    ) {
        AuditEntry entry = AuditEntry.builder()
            .eventType("TASK_COMPLETED")
            .subjectType("human_task")
            .subjectId(taskId)
            .actor(userId)
            .timestamp(Instant.now())
            .details(Map.of(
                "action", request.getAction(),
                "notes", request.getNotes() != null ? request.getNotes() : ""
            ))
            .build();

        return auditRepository.save(entry)
            .invoke(() -> LOG.infof("Audit: Task completed - %s by %s", taskId, userId));
    }
}

/**
 * ValidationService - Validates workflow definitions.
 * 
 * Responsibilities:
 * - Validate workflow graph structure (DAG, no orphans)
 * - Validate port compatibility
 * - Validate node references (agents, connectors, plugins exist)
 * - Validate CEL expressions
 * - Enforce architectural invariants
 * 
 * @since 1.0.0
 */
@ApplicationScoped
public class ValidationService {

    private static final Logger LOG = Logger.getLogger(ValidationService.class);

    @Inject
    NodeTypeService nodeTypeService;

    public Uni<ValidationResponse> validateWorkflowDesign(
        WorkflowDesignRequest request,
        String tenantId
    ) {
        LOG.infof("Validating workflow: %s", request.getName());

        ValidationResponse response = new ValidationResponse();
        response.setValid(true);
        response.setErrors(new ArrayList<>());
        response.setWarnings(new ArrayList<>());

        return Uni.createFrom().item(response)
            .onItem().transformToUni(r -> validateGraph(request, r))
            .onItem().transformToUni(r -> validatePorts(request, tenantId, r))
            .onItem().transformToUni(r -> validateNodeReferences(request, tenantId, r))
            .onItem().transform(r -> {
                r.setValid(r.getErrors().isEmpty());
                return r;
            })
            .invoke(r -> LOG.infof("Validation complete: valid=%s, errors=%d, warnings=%d",
                r.isValid(), r.getErrors().size(), r.getWarnings().size()));
    }

    private Uni<ValidationResponse> validateGraph(
        WorkflowDesignRequest request,
        ValidationResponse response
    ) {
        // 1. Check for orphaned nodes
        Set<String> nodeIds = new HashSet<>();
        request.getNodes().forEach(node -> nodeIds.add(node.getId()));

        Set<String> connectedNodes = new HashSet<>();
        request.getEdges().forEach(edge -> {
            connectedNodes.add(edge.getFrom());
            connectedNodes.add(edge.getTo());
        });

        nodeIds.stream()
            .filter(id -> !connectedNodes.contains(id))
            .forEach(id -> response.addWarning("Orphaned node: " + id));

        // 2. Check for circular dependencies (simplified)
        if (hasCircularDependency(request)) {
            response.addError("Workflow contains circular dependencies");
        }

        // 3. Validate edge references
        request.getEdges().forEach(edge -> {
            if (!nodeIds.contains(edge.getFrom())) {
                response.addError("Edge references non-existent source node: " + edge.getFrom());
            }
            if (!nodeIds.contains(edge.getTo())) {
                response.addError("Edge references non-existent target node: " + edge.getTo());
            }
        });

        return Uni.createFrom().item(response);
    }

    private Uni<ValidationResponse> validatePorts(
        WorkflowDesignRequest request,
        String tenantId,
        ValidationResponse response
    ) {
        // Validate port compatibility for each edge
        List<Uni<Void>> validations = new ArrayList<>();

        for (EdgeDefinition edge : request.getEdges()) {
            Uni<Void> validation = validateEdgePortCompatibility(
                request, edge, tenantId, response
            );
            validations.add(validation);
        }

        return Uni.combine().all().unis(validations)
            .combinedWith(results -> response);
    }

    private Uni<Void> validateEdgePortCompatibility(
        WorkflowDesignRequest request,
        EdgeDefinition edge,
        String tenantId,
        ValidationResponse response
    ) {
        // Find source and target nodes
        NodeDefinition sourceNode = findNode(request, edge.getFrom());
        NodeDefinition targetNode = findNode(request, edge.getTo());

        if (sourceNode == null || targetNode == null) {
            return Uni.createFrom().voidItem();
        }

        // Get node type descriptors to check port schemas
        return Uni.combine().all()
            .unis(
                nodeTypeService.getNodeTypeDescriptor(sourceNode.getType(), tenantId),
                nodeTypeService.getNodeTypeDescriptor(targetNode.getType(), tenantId)
            )
            .combinedWith((sourceType, targetType) -> {
                // Find output port on source
                PortDescriptor sourcePort = findOutputPort(sourceType, edge.getFromPort());
                // Find input port on target
                PortDescriptor targetPort = findInputPort(targetType, edge.getToPort());

                if (sourcePort == null) {
                    response.addError(String.format(
                        "Source node %s does not have output port: %s",
                        edge.getFrom(), edge.getFromPort()
                    ));
                }

                if (targetPort == null) {
                    response.addError(String.format(
                        "Target node %s does not have input port: %s",
                        edge.getTo(), edge.getToPort()
                    ));
                }

                // Check type compatibility
                if (sourcePort != null && targetPort != null) {
                    if (!areTypesCompatible(sourcePort, targetPort)) {
                        response.addError(String.format(
                            "Port type mismatch: %s.%s (%s) -> %s.%s (%s)",
                            edge.getFrom(), edge.getFromPort(), sourcePort.getData().getType(),
                            edge.getTo(), edge.getToPort(), targetPort.getData().getType()
                        ));
                    }
                }

                return null;
            });
    }

    private Uni<ValidationResponse> validateNodeReferences(
        WorkflowDesignRequest request,
        String tenantId,
        ValidationResponse response
    ) {
        // Validate that all node types exist
        List<Uni<Void>> validations = new ArrayList<>();

        for (NodeDefinition node : request.getNodes()) {
            Uni<Void> validation = nodeTypeService
                .getNodeTypeDescriptor(node.getType(), tenantId)
                .onItem().transform(descriptor -> null)
                .onFailure().recoverWithItem(error -> {
                    response.addError(String.format(
                        "Node %s references unknown type: %s",
                        node.getId(), node.getType()
                    ));
                    return null;
                });
            validations.add(validation);
        }

        return Uni.combine().all().unis(validations)
            .combinedWith(results -> response);
    }

    // Helper methods

    private boolean hasCircularDependency(WorkflowDesignRequest request) {
        // Simplified cycle detection - would need full DFS for production
        Map<String, Set<String>> adjacency = new HashMap<>();
        
        request.getEdges().forEach(edge -> {
            adjacency.computeIfAbsent(edge.getFrom(), k -> new HashSet<>()).add(edge.getTo());
        });

        Set<String> visited = new HashSet<>();
        Set<String> recursionStack = new HashSet<>();

        for (NodeDefinition node : request.getNodes()) {
            if (hasCycle(node.getId(), adjacency, visited, recursionStack)) {
                return true;
            }
        }

        return false;
    }

    private boolean hasCycle(
        String nodeId,
        Map<String, Set<String>> adjacency,
        Set<String> visited,
        Set<String> recursionStack
    ) {
        if (recursionStack.contains(nodeId)) {
            return true;
        }
        if (visited.contains(nodeId)) {
            return false;
        }

        visited.add(nodeId);
        recursionStack.add(nodeId);

        Set<String> neighbors = adjacency.getOrDefault(nodeId, Collections.emptySet());
        for (String neighbor : neighbors) {
            if (hasCycle(neighbor, adjacency, visited, recursionStack)) {
                return true;
            }
        }

        recursionStack.remove(nodeId);
        return false;
    }

    private NodeDefinition findNode(WorkflowDesignRequest request, String nodeId) {
        return request.getNodes().stream()
            .filter(n -> n.getId().equals(nodeId))
            .findFirst()
            .orElse(null);
    }

    private PortDescriptor findOutputPort(NodeTypeDescriptor nodeType, String portName) {
        if (nodeType.getOutputs() == null || nodeType.getOutputs().getChannels() == null) {
            return null;
        }
        return nodeType.getOutputs().getChannels().stream()
            .filter(p -> p.getName().equals(portName))
            .map(OutputChannel::getSchema)
            .findFirst()
            .orElse(null);
    }

    private PortDescriptor findInputPort(NodeTypeDescriptor nodeType, String portName) {
        if (nodeType.getInputs() == null) {
            return null;
        }
        return nodeType.getInputs().stream()
            .filter(p -> p.getName().equals(portName))
            .findFirst()
            .orElse(null);
    }

    private boolean areTypesCompatible(PortDescriptor source, PortDescriptor target) {
        String sourceType = source.getData().getType();
        String targetType = target.getData().getType();

        // Exact match
        if (sourceType.equals(targetType)) {
            return true;
        }

        // Check multiplicity compatibility
        String sourceMulti = source.getData().getMultiplicity();
        String targetMulti = target.getData().getMultiplicity();
        
        if ("stream".equals(sourceMulti) && !"stream".equals(targetMulti)) {
            return false; // Can't connect stream to non-stream
        }

        // Object/JSON are compatible
        if (isGenericType(sourceType) && isGenericType(targetType)) {
            return true;
        }

        return false;
    }

    private boolean isGenericType(String type) {
        return "object".equals(type) || "json".equals(type);
    }
}

/**
 * Audit Repository - Persists audit entries.
 */
@ApplicationScoped
class AuditRepository {

    private static final Logger LOG = Logger.getLogger(AuditRepository.class);

    // In production, this would use reactive Hibernate or MongoDB
    private final List<AuditEntry> inMemoryStore = Collections.synchronizedList(new ArrayList<>());

    public Uni<Void> save(AuditEntry entry) {
        return Uni.createFrom().item(() -> {
            // Generate hash for tamper-proof audit
            entry.setHash(generateHash(entry));
            inMemoryStore.add(entry);
            LOG.debugf("Audit entry saved: %s", entry.getEventType());
            return null;
        });
    }

    public Uni<List<AuditEntry>> findByTenant(String tenantId, int limit) {
        return Uni.createFrom().item(() -> 
            inMemoryStore.stream()
                .filter(e -> tenantId.equals(e.getTenantId()))
                .limit(limit)
                .toList()
        );
    }

    private String generateHash(AuditEntry entry) {
        // Simplified - in production use proper cryptographic hashing
        return UUID.randomUUID().toString();
    }
}

/**
 * Workflow Run Repository - Queries workflow execution data.
 */
@ApplicationScoped
class WorkflowRunRepository {

    private static final Logger LOG = Logger.getLogger(WorkflowRunRepository.class);

    // In production, this would query the actual database
    public Uni<Long> countRunsByTenant(String tenantId) {
        return Uni.createFrom().item(0L); // Placeholder
    }

    public Uni<Long> countRunsByStatus(String tenantId, String status) {
        return Uni.createFrom().item(0L); // Placeholder
    }
}

/**
 * Workflow Repository - Manages workflow definitions.
 */
@ApplicationScoped
class WorkflowRepository {

    private static final Logger LOG = Logger.getLogger(WorkflowRepository.class);

    // Placeholder - in production, use reactive Panache or similar
    public Uni<Void> save(WorkflowDefinitionResponse workflow) {
        return Uni.createFrom().voidItem();
    }

    public Uni<WorkflowDefinitionResponse> findById(String id) {
        return Uni.createFrom().nullItem();
    }
}

/**
 * Audit Entry - Immutable audit log entry.
 */
class AuditEntry {
    private String id;
    private String eventType;
    private String subjectType;
    private String subjectId;
    private String tenantId;
    private String actor;
    private Instant timestamp;
    private Map<String, Object> details;
    private String hash;

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private final AuditEntry entry = new AuditEntry();

        public Builder eventType(String eventType) {
            entry.eventType = eventType;
            return this;
        }

        public Builder subjectType(String subjectType) {
            entry.subjectType = subjectType;
            return this;
        }

        public Builder subjectId(String subjectId) {
            entry.subjectId = subjectId;
            return this;
        }

        public Builder tenantId(String tenantId) {
            entry.tenantId = tenantId;
            return this;
        }

        public Builder actor(String actor) {
            entry.actor = actor;
            return this;
        }

        public Builder timestamp(Instant timestamp) {
            entry.timestamp = timestamp;
            return this;
        }

        public Builder details(Map<String, Object> details) {
            entry.details = details;
            return this;
        }

        public AuditEntry build() {
            entry.id = UUID.randomUUID().toString();
            return entry;
        }
    }

    // Getters
    public String getId() { return id; }
    public String getEventType() { return eventType; }
    public String getSubjectType() { return subjectType; }
    public String getSubjectId() { return subjectId; }
    public String getTenantId() { return tenantId; }
    public String getActor() { return actor; }
    public Instant getTimestamp() { return timestamp; }
    public Map<String, Object> getDetails() { return details; }
    public String getHash() { return hash; }

    public void setHash(String hash) { this.hash = hash; }
}

package tech.kayys.wayang.api.dto;

import tech.kayys.wayang.schema.node.*;
import tech.kayys.wayang.sdk.dto.workflow.*;
import jakarta.validation.constraints.NotNull;

import java.time.Instant;
import java.util.*;

/**
 * Frontend API DTOs for Wayang Workflow Platform.
 * 
 * These DTOs are specifically designed for the frontend UI and provide:
 * - Simplified request models
 * - Rich response models with UI metadata
 * - Validation annotations
 * - Builder patterns for ease of use
 * 
 * @since 1.0.0
 */

// ============================================================================
// NODE TYPE CATALOG
// ============================================================================

/**
 * Node Type Catalog Response - Organized by category.
 */
public class NodeTypeCatalogResponse {
    private List<NodeTypeCategory> categories = new ArrayList<>();
    private int totalNodes;

    public void addCategory(String name, String description, List<NodeTypeDescriptor> nodes) {
        NodeTypeCategory category = new NodeTypeCategory();
        category.setName(name);
        category.setDescription(description);
        category.setNodes(nodes);
        categories.add(category);
    }

    public int calculateTotalNodes() {
        return categories.stream()
            .mapToInt(c -> c.getNodes().size())
            .sum();
    }

    public Optional<NodeTypeDescriptor> findNodeType(String nodeTypeId) {
        return categories.stream()
            .flatMap(c -> c.getNodes().stream())
            .filter(n -> n.getId().equals(nodeTypeId))
            .findFirst();
    }

    public List<NodeTypeDescriptor> search(String query, String category) {
        return categories.stream()
            .filter(c -> category == null || c.getName().equals(category))
            .flatMap(c -> c.getNodes().stream())
            .filter(n -> matchesQuery(n, query))
            .toList();
    }

    private boolean matchesQuery(NodeTypeDescriptor node, String query) {
        String lowerQuery = query.toLowerCase();
        return node.getName().toLowerCase().contains(lowerQuery) ||
               node.getDescription().toLowerCase().contains(lowerQuery) ||
               node.getCategory().toLowerCase().contains(lowerQuery);
    }

    // Getters and setters
    public List<NodeTypeCategory> getCategories() { return categories; }
    public void setCategories(List<NodeTypeCategory> categories) { this.categories = categories; }
    public int getTotalNodes() { return totalNodes; }
    public void setTotalNodes(int totalNodes) { this.totalNodes = totalNodes; }
}

/**
 * Node Type Category - Groups related nodes.
 */
public class NodeTypeCategory {
    private String name;
    private String description;
    private List<NodeTypeDescriptor> nodes = new ArrayList<>();

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public List<NodeTypeDescriptor> getNodes() { return nodes; }
    public void setNodes(List<NodeTypeDescriptor> nodes) { this.nodes = nodes; }
}

/**
 * Node Type Descriptor - Detailed node information.
 */
public class NodeTypeDescriptor {
    private String id;
    private String name;
    private String description;
    private String category;
    private String icon;
    private String color;
    private List<PortDescriptor> inputs = new ArrayList<>();
    private Outputs outputs;
    private List<PropertyDescriptor> properties = new ArrayList<>();
    private Map<String, Object> uiMetadata = new HashMap<>();

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private final NodeTypeDescriptor descriptor = new NodeTypeDescriptor();

        public Builder id(String id) {
            descriptor.id = id;
            return this;
        }

        public Builder name(String name) {
            descriptor.name = name;
            return this;
        }

        public Builder description(String description) {
            descriptor.description = description;
            return this;
        }

        public Builder category(String category) {
            descriptor.category = category;
            return this;
        }

        public Builder icon(String icon) {
            descriptor.icon = icon;
            return this;
        }

        public Builder color(String color) {
            descriptor.color = color;
            return this;
        }

        public Builder addInput(PortDescriptor input) {
            descriptor.inputs.add(input);
            return this;
        }

        public Builder addOutput(String channel, PortDescriptor output) {
            if (descriptor.outputs == null) {
                descriptor.outputs = new Outputs();
                descriptor.outputs.setChannels(new ArrayList<>());
            }
            OutputChannel outputChannel = new OutputChannel();
            outputChannel.setName(channel);
            outputChannel.setType(channel.equals("error") ? "error" : "success");
            outputChannel.setSchema(output);
            descriptor.outputs.getChannels().add(outputChannel);
            return this;
        }

        public Builder addProperty(String name, String type, Object defaultValue, boolean required) {
            PropertyDescriptor prop = new PropertyDescriptor();
            prop.setName(name);
            prop.setType(type);
            prop.setDefault(defaultValue);
            prop.setRequired(required);
            descriptor.properties.add(prop);
            return this;
        }

        public NodeTypeDescriptor build() {
            return descriptor;
        }
    }

    // Getters and setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public String getCategory() { return category; }
    public void setCategory(String category) { this.category = category; }
    public String getIcon() { return icon; }
    public void setIcon(String icon) { this.icon = icon; }
    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }
    public List<PortDescriptor> getInputs() { return inputs; }
    public void setInputs(List<PortDescriptor> inputs) { this.inputs = inputs; }
    public Outputs getOutputs() { return outputs; }
    public void setOutputs(Outputs outputs) { this.outputs = outputs; }
    public List<PropertyDescriptor> getProperties() { return properties; }
    public void setProperties(List<PropertyDescriptor> properties) { this.properties = properties; }
    public Map<String, Object> getUiMetadata() { return uiMetadata; }
    public void setUiMetadata(Map<String, Object> uiMetadata) { this.uiMetadata = uiMetadata; }
}

/**
 * Output Channel - Output port with routing type.
 */
public class OutputChannel {
    private String name;
    private String displayName;
    private String description;
    private String type; // success, error, conditional, etc.
    private String condition;
    private PortDescriptor schema;
    private Integer order;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDisplayName() { return displayName; }
    public void setDisplayName(String displayName) { this.displayName = displayName; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    public String getCondition() { return condition; }
    public void setCondition(String condition) { this.condition = condition; }
    public PortDescriptor getSchema() { return schema; }
    public void setSchema(PortDescriptor schema) { this.schema = schema; }
    public Integer getOrder() { return order; }
    public void setOrder(Integer order) { this.order = order; }
}

/**
 * Port Descriptor - Input/Output port definition.
 */
public class PortDescriptor {
    private String name;
    private String displayName;
    private String description;
    private PortData data;
    private PortUI ui;

    public static Builder builder() {
        return new Builder();
    }

    public static PortDescriptor errorOutput() {
        return builder()
            .name("error")
            .displayName("Error")
            .type("error_payload")
            .required(false)
            .description("Error output when node fails")
            .build();
    }

    public static class Builder {
        private final PortDescriptor descriptor = new PortDescriptor();
        private final PortData data = new PortData();

        public Builder name(String name) {
            descriptor.name = name;
            return this;
        }

        public Builder displayName(String displayName) {
            descriptor.displayName = displayName;
            return this;
        }

        public Builder description(String description) {
            descriptor.description = description;
            return this;
        }

        public Builder type(String type) {
            data.setType(type);
            return this;
        }

        public Builder required(boolean required) {
            data.setRequired(required);
            return this;
        }

        public Builder defaultValue(Object value) {
            data.setDefaultValue(value);
            return this;
        }

        public PortDescriptor build() {
            descriptor.data = data;
            return descriptor;
        }
    }

    // Getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDisplayName() { return displayName; }
    public void setDisplayName(String displayName) { this.displayName = displayName; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public PortData getData() { return data; }
    public void setData(PortData data) { this.data = data; }
    public PortUI getUi() { return ui; }
    public void setUi(PortUI ui) { this.ui = ui; }
}

/**
 * Port UI - UI metadata for port rendering.
 */
public class PortUI {
    private String widget;
    private Integer order;
    private String helpText;
    private String visibleWhen;
    private Boolean editable = true;

    // Getters and setters
    public String getWidget() { return widget; }
    public void setWidget(String widget) { this.widget = widget; }
    public Integer getOrder() { return order; }
    public void setOrder(Integer order) { this.order = order; }
    public String getHelpText() { return helpText; }
    public void setHelpText(String helpText) { this.helpText = helpText; }
    public String getVisibleWhen() { return visibleWhen; }
    public void setVisibleWhen(String visibleWhen) { this.visibleWhen = visibleWhen; }
    public Boolean getEditable() { return editable; }
    public void setEditable(Boolean editable) { this.editable = editable; }
}

// ============================================================================
// WORKFLOW DESIGN
// ============================================================================

/**
 * Workflow Design Request - Create/update workflow.
 */
public class WorkflowDesignRequest {
    @NotNull
    private String name;
    private String description;
    @NotNull
    private List<NodeDefinition> nodes = new ArrayList<>();
    @NotNull
    private List<EdgeDefinition> edges = new ArrayList<>();
    private Map<String, Object> metadata = new HashMap<>();
    private List<String> tags = new ArrayList<>();

    // Getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public List<NodeDefinition> getNodes() { return nodes; }
    public void setNodes(List<NodeDefinition> nodes) { this.nodes = nodes; }
    public List<EdgeDefinition> getEdges() { return edges; }
    public void setEdges(List<EdgeDefinition> edges) { this.edges = edges; }
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    public List<String> getTags() { return tags; }
    public void setTags(List<String> tags) { this.tags = tags; }
}

/**
 * Workflow Definition Response - Complete workflow definition.
 */
public class WorkflowDefinitionResponse {
    private String id;
    private String name;
    private String description;
    private String version;
    private String tenantId;
    private String createdBy;
    private Instant createdAt;
    private Instant updatedAt;
    private String status; // draft, published, archived
    private List<NodeDefinition> nodes;
    private List<EdgeDefinition> edges;
    private Map<String, Object> metadata;
    private List<String> tags;

    // Getters and setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public String getVersion() { return version; }
    public void setVersion(String version) { this.version = version; }
    public String getTenantId() { return tenantId; }
    public void setTenantId(String tenantId) { this.tenantId = tenantId; }
    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }
    public Instant getCreatedAt() { return createdAt; }
    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }
    public Instant getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(Instant updatedAt) { this.updatedAt = updatedAt; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    public List<NodeDefinition> getNodes() { return nodes; }
    public void setNodes(List<NodeDefinition> nodes) { this.nodes = nodes; }
    public List<EdgeDefinition> getEdges() { return edges; }
    public void setEdges(List<EdgeDefinition> edges) { this.edges = edges; }
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
    public List<String> getTags() { return tags; }
    public void setTags(List<String> tags) { this.tags = tags; }
}

// ============================================================================
// WORKFLOW EXECUTION
// ============================================================================

/**
 * Workflow Execution Request - Trigger workflow.
 */
public class WorkflowExecutionRequest {
    @NotNull
    private Map<String, Object> inputs = new HashMap<>();
    private AgentConfig agentConfig;
    private IntegrationConfig integrationConfig;
    private BusinessConfig businessConfig;
    private BatchConfig batchConfig;
    private Map<String, Object> metadata = new HashMap<>();

    // Getters and setters
    public Map<String, Object> getInputs() { return inputs; }
    public void setInputs(Map<String, Object> inputs) { this.inputs = inputs; }
    public AgentConfig getAgentConfig() { return agentConfig; }
    public void setAgentConfig(AgentConfig agentConfig) { this.agentConfig = agentConfig; }
    public IntegrationConfig getIntegrationConfig() { return integrationConfig; }
    public void setIntegrationConfig(IntegrationConfig integrationConfig) { 
        this.integrationConfig = integrationConfig; 
    }
    public BusinessConfig getBusinessConfig() { return businessConfig; }
    public void setBusinessConfig(BusinessConfig businessConfig) { 
        this.businessConfig = businessConfig; 
    }
    public BatchConfig getBatchConfig() { return batchConfig; }
    public void setBatchConfig(BatchConfig batchConfig) { this.batchConfig = batchConfig; }
    public Map<String, Object> getMetadata() { return metadata; }
    public void setMetadata(Map<String, Object> metadata) { this.metadata = metadata; }
}

/**
 * Workflow Run Detail Response - Complete run information.
 */
public class WorkflowRunDetailResponse {
    private WorkflowRunResponse run;
    private WorkflowStateResponse state;
    private List<NodeExecutionRecord> history;
    private List<ErrorPayloadResponse> errors;

    // Getters and setters
    public WorkflowRunResponse getRun() { return run; }
    public void setRun(WorkflowRunResponse run) { this.run = run; }
    public WorkflowStateResponse getState() { return state; }
    public void setState(WorkflowStateResponse state) { this.state = state; }
    public List<NodeExecutionRecord> getHistory() { return history; }
    public void setHistory(List<NodeExecutionRecord> history) { this.history = history; }
    public List<ErrorPayloadResponse> getErrors() { return errors; }
    public void setErrors(List<ErrorPayloadResponse> errors) { this.errors = errors; }
}

/**
 * Workflow Run Summary - Lightweight run info for lists.
 */
public class WorkflowRunSummary {
    private String runId;
    private String workflowId;
    private String workflowName;
    private String status;
    private Instant startedAt;
    private Instant completedAt;
    private Long durationMs;
    private String triggeredBy;

    // Getters and setters
    public String getRunId() { return runId; }
    public void setRunId(String runId) { this.runId = runId; }
    public String getWorkflowId() { return workflowId; }
    public void setWorkflowId(String workflowId) { this.workflowId = workflowId; }
    public String getWorkflowName() { return workflowName; }
    public void setWorkflowName(String workflowName) { this.workflowName = workflowName; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    public Instant getStartedAt() { return startedAt; }
    public void setStartedAt(Instant startedAt) { this.startedAt = startedAt; }
    public Instant getCompletedAt() { return completedAt; }
    public void setCompletedAt(Instant completedAt) { this.completedAt = completedAt; }
    public Long getDurationMs() { return durationMs; }
    public void setDurationMs(Long durationMs) { this.durationMs = durationMs; }
    public String getTriggeredBy() { return triggeredBy; }
    public void setTriggeredBy(String triggeredBy) { this.triggeredBy = triggeredBy; }
}

// ============================================================================
// DASHBOARD
// ============================================================================

/**
 * Dashboard Statistics Response.
 */
public class DashboardStatsResponse {
    private long totalWorkflowRuns;
    private long runningWorkflows;
    private long failedWorkflows;
    private int pendingTasks;
    private Map<String, Long> workflowCounts = new HashMap<>();
    private List<RecentActivity> recentActivities = new ArrayList<>();

    // Getters and setters
    public long getTotalWorkflowRuns() { return totalWorkflowRuns; }
    public void setTotalWorkflowRuns(long totalWorkflowRuns) { 
        this.totalWorkflowRuns = totalWorkflowRuns; 
    }
    public long getRunningWorkflows() { return runningWorkflows; }
    public void setRunningWorkflows(long runningWorkflows) { 
        this.runningWorkflows = runningWorkflows; 
    }
    public long getFailedWorkflows() { return failedWorkflows; }
    public void setFailedWorkflows(long failedWorkflows) { 
        this.failedWorkflows = failedWorkflows; 
    }
    public int getPendingTasks() { return pendingTasks; }
    public void setPendingTasks(int pendingTasks) { this.pendingTasks = pendingTasks; }
    public Map<String, Long> getWorkflowCounts() { return workflowCounts; }
    public void setWorkflowCounts(Map<String, Long> workflowCounts) { 
        this.workflowCounts = workflowCounts; 
    }
    public List<RecentActivity> getRecentActivities() { return recentActivities; }
    public void setRecentActivities(List<RecentActivity> recentActivities) { 
        this.recentActivities = recentActivities; 
    }
}

/**
 * Recent Activity - Dashboard activity item.
 */
public class RecentActivity {
    private String type;
    private String description;
    private Instant timestamp;
    private String userId;

    // Getters and setters
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public Instant getTimestamp() { return timestamp; }
    public void setTimestamp(Instant timestamp) { this.timestamp = timestamp; }
    public String getUserId() { return userId; }
    public void setUserId(String userId) { this.userId = userId; }
}

// ============================================================================
// GENERIC RESPONSES
// ============================================================================

/**
 * Paged Response - Generic pagination wrapper.
 */
public class PagedResponse<T> {
    private List<T> content;
    private int page;
    private int size;
    private long totalElements;
    private int totalPages;

    // Getters and setters
    public List<T> getContent() { return content; }
    public void setContent(List<T> content) { this.content = content; }
    public int getPage() { return page; }
    public void setPage(int page) { this.page = page; }
    public int getSize() { return size; }
    public void setSize(int size) { this.size = size; }
    public long getTotalElements() { return totalElements; }
    public void setTotalElements(long totalElements) { this.totalElements = totalElements; }
    public int getTotalPages() { return totalPages; }
    public void setTotalPages(int totalPages) { this.totalPages = totalPages; }
}

/**
 * Validation Response - Validation result with errors/warnings.
 */
public class ValidationResponse {
    private boolean valid;
    private List<String> errors = new ArrayList<>();
    private List<String> warnings = new ArrayList<>();

    public void addError(String error) {
        errors.add(error);
    }

    public void addWarning(String warning) {
        warnings.add(warning);
    }

    // Getters and setters
    public boolean isValid() { return valid; }
    public void setValid(boolean valid) { this.valid = valid; }
    public List<String> getErrors() { return errors; }
    public void setErrors(List<String> errors) { this.errors = errors; }
    public List<String> getWarnings() { return warnings; }
    public void setWarnings(List<String> warnings) { this.warnings = warnings; }
}

