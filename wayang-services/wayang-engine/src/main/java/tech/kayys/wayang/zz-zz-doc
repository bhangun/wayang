# Wayang Platform - Frontend Integration Guide

## Overview

This guide provides comprehensive information for frontend developers to integrate with the Wayang AI Agent Workflow Platform APIs.

## Base URL

    ```
Production: https://api.wayang.tech
Development: https://dev-api.wayang.tech
Local: http://localhost:8080
```

## Authentication

All API requests require authentication using JWT Bearer tokens:

    ```typescript
headers: {
  'Authorization': 'Bearer YOUR_JWT_TOKEN',
  'Content-Type': 'application/json',
  'X-Tenant-ID': 'your-tenant-id'
}
```

---

## 1. Node Types API

### Get Node Type Catalog

Retrieve complete catalog of all available node types organized by category.

** Endpoint:** `GET /api/v1/node-types/catalog`

    ** Response:**
        ```json
{
  "version": "1.0.0",
  "lastUpdated": "2025-12-19T10:00:00Z",
  "totalNodes": 58,
  "categories": [
    {
      "name": "Agent",
      "description": "AI-powered reasoning and decision making",
      "nodeCount": 10,
      "nodes": [
        {
          "id": "builtin.agent.llm-completion",
          "name": "LLM Completion",
          "description": "Generate text completion using language model",
          "category": "Agent",
          "icon": "brain",
          "color": "#8B5CF6",
          "inputs": [
            {
              "name": "prompt",
              "displayName": "Prompt",
              "type": "string",
              "required": true,
              "description": "The prompt to send to the LLM"
            }
          ],
          "outputs": {
            "success": {
              "name": "completion",
              "type": "string",
              "description": "Generated text completion"
            },
            "error": {
              "name": "error",
              "type": "error_payload",
              "description": "Error details"
            }
          },
          "properties": [
            {
              "name": "model",
              "type": "string",
              "default": "claude-sonnet-4-5",
              "required": true,
              "description": "LLM model to use"
            }
          ]
        }
      ]
    }
  ]
}
```

        ** React Example:**
            ```typescript
import { useQuery } from '@tanstack/react-query';

function NodePalette() {
  const { data: catalog } = useQuery({
    queryKey: ['node-catalog'],
    queryFn: async () => {
      const response = await fetch('/api/v1/node-types/catalog', {
        headers: {
          'Authorization': `Bearer ${ token } `,
        }
      });
      return response.json();
    }
  });

  return (
    <div className="node-palette">
      {catalog?.categories.map(category => (
        <CategorySection key={category.name} category={category} />
      ))}
    </div>
  );
}
```

### Search Node Types

    ** Endpoint:** `GET /api/v1/node-types/search?q={query}&category={category}`

        ** Parameters:**
            - `q`(string): Search query
                - `category`(string, optional): Filter by category

                    ** Example:**
                        ```typescript
const searchNodes = async (query: string) => {
  const response = await fetch(
    `/ api / v1 / node - types / search ? q = ${ encodeURIComponent(query) } `,
    { headers: getAuthHeaders() }
  );
  return response.json();
};
```

### Get Node Type Details

    ** Endpoint:** `GET /api/v1/node-types/{nodeTypeId}`

        ** Example:**
            ```typescript
const getNodeDetails = async (nodeTypeId: string) => {
  const response = await fetch(
    `/ api / v1 / node - types / ${ nodeTypeId } `,
    { headers: getAuthHeaders() }
  );
  return response.json();
};
```

---

## 2. Workflow Engine API

### Execute Workflow

    ** Endpoint:** `POST /api/v1/engine/execute`

        ** Request Body:**
            ```json
{
  "workflowId": "customer-support-bot",
  "workflowType": "agentic",
  "inputs": {
    "customerQuery": "How do I reset my password?"
  },
  "metadata": {
    "source": "web-chat",
    "sessionId": "session-123"
  }
}
```

            ** Response:**
                ```json
{
  "runId": "run-uuid-123",
  "workflowId": "customer-support-bot",
  "status": "RUNNING",
  "createdAt": "2025-12-19T10:00:00Z",
  "inputs": {...},
  "outputs": null
}
```

                ** React Hook Example:**
                    ```typescript
import { useMutation } from '@tanstack/react-query';

function useExecuteWorkflow() {
  return useMutation({
    mutationFn: async (request: WorkflowExecutionRequest) => {
      const response = await fetch('/api/v1/engine/execute', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${ token } `,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(request),
      });
      
      if (!response.ok) {
        throw new Error('Failed to execute workflow');
      }
      
      return response.json();
    },
  });
}

// Usage in component
function WorkflowExecutor() {
  const { mutate, data, isPending } = useExecuteWorkflow();

  const handleExecute = () => {
    mutate({
      workflowId: 'my-workflow',
      workflowType: 'agentic',
      inputs: { query: 'test' }
    });
  };

  return (
    <button onClick={handleExecute} disabled={isPending}>
      {isPending ? 'Running...' : 'Execute Workflow'}
    </button>
  );
}
```

### Stream Workflow Execution

    ** Endpoint:** `GET /api/v1/engine/{runId}/stream`(Server - Sent Events)

        ** React Example with SSE:**
            ```typescript
import { useEffect, useState } from 'react';

function useWorkflowStream(runId: string) {
  const [events, setEvents] = useState<WorkflowEvent[]>([]);
  const [status, setStatus] = useState<string>('connecting');

  useEffect(() => {
    const eventSource = new EventSource(
      `/ api / v1 / engine / ${ runId }/stream`,
{
    headers: {
        'Authorization': `Bearer ${token}`,
        }
}
    );

eventSource.onopen = () => {
    setStatus('connected');
};

eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    setEvents(prev => [...prev, data]);

    if (data.eventType === 'NODE_COMPLETED') {
        console.log('Node completed:', data.nodeId);
    }
};

eventSource.onerror = () => {
    setStatus('error');
    eventSource.close();
};

return () => {
    eventSource.close();
};
  }, [runId]);

return { events, status };
}

// Usage
function WorkflowMonitor({ runId }: { runId: string }) {
    const { events, status } = useWorkflowStream(runId);

    return (
        <div>
            <div>Status: {status}</div>
            <div>
                {events.map((event, idx) => (
                    <div key={idx}>
                        {event.eventType}: {event.nodeId}
                    </div>
                ))}
            </div>
        </div>
    );
}
```

### Get Workflow State

**Endpoint:** `GET / api / v1 / engine / { runId } / state`

**Response:**
```json
{
    "runId": "run-uuid-123",
        "status": "RUNNING",
            "currentNode": "node-5",
                "completedNodes": ["node-1", "node-2", "node-3"],
                    "pendingNodes": ["node-6", "node-7"],
                        "workflowState": {
        "variables": {... },
        "context": {... }
    },
    "progress": {
        "completed": 3,
            "total": 7,
                "percentage": 42.86
    }
}
```

### Execute Agentic Workflow with Streaming

**Endpoint:** `POST / api / v1 / engine / agentic / stream`

**Request:**
```json
{
    "workflowId": "ai-assistant",
        "agentConfig": {
        "primaryAgent": "support-agent",
            "orchestrationStrategy": "dynamic",
                "toolsEnabled": ["knowledge-base", "ticket-system"],
                    "enableRAG": true
    },
    "inputs": {
        "userMessage": "I need help with my order"
    }
}
```

**Response:** Server-Sent Events stream

```typescript
// React component for agentic workflow with streaming
function AgenticWorkflowChat() {
    const [messages, setMessages] = useState < Message[] > ([]);
    const [isRunning, setIsRunning] = useState(false);

    const executeWithStream = async (userMessage: string) => {
        setIsRunning(true);

        const response = await fetch('/api/v1/engine/agentic/stream', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                workflowId: 'ai-assistant',
                agentConfig: {
                    primaryAgent: 'support-agent',
                    orchestrationStrategy: 'dynamic',
                    toolsEnabled: ['knowledge-base'],
                    enableRAG: true
                },
                inputs: { userMessage }
            }),
        });

        const reader = response.body!.getReader();
        const decoder = new TextDecoder();

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const events = chunk.split('\n\n');

            for (const event of events) {
                if (event.startsWith('data: ')) {
                    const data = JSON.parse(event.slice(6));

                    if (data.eventType === 'AGENT_THINKING') {
                        setMessages(prev => [...prev, {
                            type: 'thinking',
                            content: data.thought
                        }]);
                    } else if (data.eventType === 'AGENT_RESPONSE') {
                        setMessages(prev => [...prev, {
                            type: 'response',
                            content: data.response
                        }]);
                    }
                }
            }
        }

        setIsRunning(false);
    };

    return (
        <div className="chat-container">
            <div className="messages">
                {messages.map((msg, idx) => (
                    <Message key={idx} message={msg} />
                ))}
            </div>
            <ChatInput onSend={executeWithStream} disabled={isRunning} />
        </div>
    );
}
```

---

## 3. Workflow Definition API

### Create Workflow

**Endpoint:** `POST / api / v1 / workflows`

**Request:**
```json
{
    "id": "my-workflow",
        "name": "Customer Support Workflow",
            "description": "AI-powered customer support automation",
                "nodes": [
                    {
                        "id": "node-1",
                        "type": "builtin.agent.llm-completion",
                        "displayName": "Analyze Query",
                        "inputs": [...],
                        "outputs": { ...},
                        "properties": [...]
                    }
                ],
                    "edges": [
                        {
                            "from": "node-1",
                            "to": "node-2",
                            "fromPort": "success",
                            "toPort": "input"
                        }
                    ]
}
```

### Get Workflow

**Endpoint:** `GET / api / v1 / workflows / { workflowId }`

### Update Workflow

**Endpoint:** `PUT / api / v1 / workflows / { workflowId }`

### List Workflows

**Endpoint:** `GET / api / v1 / workflows ? page = 0 & size=20`

---

## 4. Human-in-the-Loop (HITL) API

### Get My Tasks

**Endpoint:** `GET / api / v1 / tasks / my - tasks`

**Response:**
```json
{
    "tasks": [
        {
            "taskId": "task-123",
            "workflowRunId": "run-456",
            "nodeId": "approval-node-1",
            "type": "APPROVAL",
            "title": "Approve Purchase Request",
            "description": "Review and approve $5000 purchase request",
            "data": { ...},
            "createdAt": "2025-12-19T09:00:00Z",
            "dueDate": "2025-12-20T09:00:00Z",
            "priority": "high",
            "status": "PENDING"
        }
    ]
}
```

**React Example:**
```typescript
function MyTasks() {
    const { data: tasks } = useQuery({
        queryKey: ['my-tasks'],
        queryFn: async () => {
            const response = await fetch('/api/v1/tasks/my-tasks', {
                headers: getAuthHeaders()
            });
            return response.json();
        },
        refetchInterval: 30000 // Poll every 30 seconds
    });

    return (
        <div className="tasks-list">
            {tasks?.tasks.map(task => (
                <TaskCard key={task.taskId} task={task} />
            ))}
        </div>
    );
}
```

### Complete Task

**Endpoint:** `POST / api / v1 / tasks / { taskId } / complete`

**Request:**
```json
{
    "action": "approved",
        "notes": "Approved by manager",
            "correctedInput": null
}
```

---

## 5. WebSocket for Real-time Updates

Connect to WebSocket for real-time workflow updates:

```typescript
const ws = new WebSocket(
    `wss://api.wayang.tech/ws/workflows/${runId}?token=${token}`
);

ws.onmessage = (event) => {
    const update = JSON.parse(event.data);

    switch (update.type) {
        case 'NODE_STARTED':
            console.log('Node started:', update.nodeId);
            break;
        case 'NODE_COMPLETED':
            console.log('Node completed:', update.nodeId);
            break;
        case 'WORKFLOW_COMPLETED':
            console.log('Workflow completed');
            break;
        case 'ERROR':
            console.error('Error:', update.error);
            break;
    }
};
```

---

## 6. TypeScript Type Definitions

```typescript
// Node Types
interface NodeTypeDescriptor {
    id: string;
    name: string;
    description: string;
    category: string;
    icon: string;
    color: string;
    inputs: PortDescriptor[];
    outputs: OutputsDescriptor;
    properties: PropertyDescriptor[];
    errorHandling?: ErrorHandlingConfig;
    documentation?: string;
}

interface PortDescriptor {
    name: string;
    displayName: string;
    type: string;
    required: boolean;
    description: string;
    schema?: object;
}

// Workflow Execution
interface WorkflowExecutionRequest {
    workflowId: string;
    workflowType: 'agentic' | 'integration' | 'business';
    inputs: Record<string, any>;
    metadata?: Record<string, any>;
}

interface WorkflowRunResponse {
    runId: string;
    workflowId: string;
    status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';
    createdAt: string;
    completedAt?: string;
    inputs: Record<string, any>;
    outputs?: Record<string, any>;
    error?: ErrorPayload;
}

// Execution Events
interface WorkflowExecutionEvent {
    eventType: string;
    runId: string;
    nodeId?: string;
    timestamp: string;
    data: any;
}

// HITL Task
interface HumanTask {
    taskId: string;
    workflowRunId: string;
    nodeId: string;
    type: 'APPROVAL' | 'FORM_INPUT' | 'REVIEW' | 'DECISION';
    title: string;
    description: string;
    data: any;
    createdAt: string;
    dueDate?: string;
    priority: 'low' | 'normal' | 'high' | 'urgent';
    status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
}
```

---

## 7. Error Handling

All API errors follow this format:

```json
{
    "error": "WorkflowNotFoundException",
        "message": "Workflow not found: my-workflow",
            "code": "NOT_FOUND",
                "timestamp": 1703001600000
}
```

**Status Codes:**
- `200` - Success
- `201` - Created
- `202` - Accepted (async operation started)
- `400` - Bad Request
- `401` - Unauthorized
- `403` - Forbidden
- `404` - Not Found
- `409` - Conflict
- `422` - Validation Error
- `500` - Internal Server Error

---

## 8. Rate Limiting

API endpoints are rate-limited:
- Node Types API: 100 requests/minute
- Workflow Execution: 50 requests/minute
- Streaming endpoints: 10 concurrent connections

Headers:
```
X - RateLimit - Limit: 100
X - RateLimit - Remaining: 85
X - RateLimit - Reset: 1703001660
    ```

---

## 9. Best Practices

### 1. Use React Query for Data Fetching
```typescript
const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            staleTime: 60000, // 1 minute
            cacheTime: 300000, // 5 minutes
        },
    },
});
```

### 2. Implement Optimistic Updates
```typescript
const { mutate } = useMutation({
    mutationFn: updateWorkflow,
    onMutate: async (newWorkflow) => {
        await queryClient.cancelQueries(['workflow', workflowId]);
        const previousWorkflow = queryClient.getQueryData(['workflow', workflowId]);
        queryClient.setQueryData(['workflow', workflowId], newWorkflow);
        return { previousWorkflow };
    },
    onError: (err, newWorkflow, context) => {
        queryClient.setQueryData(['workflow', workflowId], context.previousWorkflow);
    },
});
```

### 3. Handle Loading States
```typescript
function WorkflowList() {
    const { data, isLoading, isError, error } = useQuery({
        queryKey: ['workflows'],
        queryFn: fetchWorkflows,
    });

    if (isLoading) return <Spinner />;
    if (isError) return <ErrorMessage error={error} />;

    return <WorkflowGrid workflows={data.workflows} />;
}
```

### 4. Implement Retry Logic
```typescript
const { mutate } = useMutation({
    mutationFn: executeWorkflow,
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
});
```

---

## 10. Complete React Example

Here's a complete example of a workflow execution component:

```typescript
import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

function WorkflowExecutionPanel() {
    const [selectedWorkflow, setSelectedWorkflow] = useState < string | null > (null);
    const [inputs, setInputs] = useState < Record < string, any>> ({});
    const queryClient = useQueryClient();

    // Fetch available workflows
    const { data: workflows } = useQuery({
        queryKey: ['workflows'],
        queryFn: async () => {
            const response = await fetch('/api/v1/workflows', {
                headers: getAuthHeaders(),
            });
            return response.json();
        },
    });

    // Execute workflow mutation
    const { mutate: execute, data: run, isPending } = useMutation({
        mutationFn: async (request: WorkflowExecutionRequest) => {
            const response = await fetch('/api/v1/engine/execute', {
                method: 'POST',
                headers: {
                    ...getAuthHeaders(),
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(request),
            });
            return response.json();
        },
        onSuccess: (data) => {
            queryClient.invalidateQueries({ queryKey: ['workflow-runs'] });
            console.log('Workflow started:', data.runId);
        },
    });

    const handleExecute = () => {
        if (!selectedWorkflow) return;

        execute({
            workflowId: selectedWorkflow,
            workflowType: 'agentic',
            inputs,
        });
    };

    return (
        <div className="execution-panel">
            <select
                value={selectedWorkflow || ''}
                onChange={(e) => setSelectedWorkflow(e.target.value)}
            >
                <option value="">Select Workflow</option>
                {workflows?.map(wf => (
                    <option key={wf.id} value={wf.id}>{wf.name}</option>
                ))}
            </select>

            <InputsEditor
                inputs={inputs}
                onChange={setInputs}
            />

            <button
                onClick={handleExecute}
                disabled={!selectedWorkflow || isPending}
            >
                {isPending ? 'Executing...' : 'Execute Workflow'}
            </button>

            {run && (
                <WorkflowMonitor runId={run.runId} />
            )}
        </div>
    );
}
```

---

## Support

For questions or issues:
- Documentation: https://docs.wayang.tech
- API Status: https://status.wayang.tech
- Support: support@wayang.tech