package tech.kayys.wayang.core.node;

import io.smallrye.mutiny.Uni;
import java.util.Map;
import java.util.Optional;

/**
 * Base interface for all executable nodes in the Wayang platform.
 * Follows the triplet pattern: inputs → execute → outputs (success, error)
 * 
 * All implementations must be:
 * - Idempotent (safe to retry)
 * - Thread-safe
 * - Resource-aware (respect quotas)
 * - Observable (emit metrics/traces)
 */
public interface Node {
    
    /**
     * Lifecycle hook: called once when node is loaded into runtime
     * @param descriptor The immutable node descriptor
     * @param config Runtime configuration
     */
    void onLoad(NodeDescriptor descriptor, NodeConfig config) throws NodeException;
    
    /**
     * Main execution method - MUST be idempotent
     * @param context Execution context with inputs, variables, metadata
     * @return Execution result with outputs and status
     */
    Uni<ExecutionResult> execute(NodeContext context) throws NodeExecutionException;
    
    /**
     * Lifecycle hook: called when node is unloaded from runtime
     */
    void onUnload();
    
    /**
     * Optional: Checkpoint current state for resumability
     * @param context Current execution context
     * @return Checkpoint state or empty if not supported
     */
    default Optional<CheckpointState> checkpoint(NodeContext context) {
        return Optional.empty();
    }
    
    /**
     * Optional: Resume from checkpoint
     * @param context Execution context
     * @param checkpoint Previous checkpoint state
     * @return Execution result continuing from checkpoint
     */
    default Uni<ExecutionResult> resume(NodeContext context, CheckpointState checkpoint) {
        return execute(context);
    }
    
    /**
     * Health check - verify node can execute
     */
    default Uni<HealthStatus> healthCheck() {
        return Uni.createFrom().item(HealthStatus.healthy());
    }
}

/**
 * Abstract base class providing common functionality for all nodes
 * Handles error wrapping, observability, and validation
 */
public abstract class AbstractNode implements Node {
    
    protected NodeDescriptor descriptor;
    protected NodeConfig config;
    protected MetricsCollector metrics;
    protected ProvenanceLogger provenance;
    protected GuardrailsEngine guardrails;
    
    @Override
    public void onLoad(NodeDescriptor descriptor, NodeConfig config) {
        this.descriptor = descriptor;
        this.config = config;
        this.metrics = MetricsCollector.forNode(descriptor.getId());
        this.provenance = ProvenanceLogger.forNode(descriptor.getId());
        this.guardrails = GuardrailsEngine.instance();
        
        // Hook for subclass initialization
        doOnLoad(descriptor, config);
    }
    
    @Override
    public final Uni<ExecutionResult> execute(NodeContext context) {
        var span = startTrace(context);
        var startTime = System.nanoTime();
        
        return Uni.createFrom().deferred(() -> {
            // Pre-execution guardrails
            return guardrails.preCheck(context, descriptor)
                .onItem().transformToUni(guardResult -> {
                    if (!guardResult.isAllowed()) {
                        return Uni.createFrom().item(
                            ExecutionResult.blocked(guardResult.getReason())
                        );
                    }
                    
                    // Validate inputs against schema
                    return validateInputs(context)
                        .onItem().transformToUni(valid -> {
                            if (!valid) {
                                return Uni.createFrom().item(
                                    ExecutionResult.failed("Input validation failed")
                                );
                            }
                            
                            // Execute actual node logic
                            return doExecute(context);
                        });
                })
                .onItem().transformToUni(result -> {
                    // Post-execution guardrails
                    return guardrails.postCheck(result, descriptor)
                        .map(guardResult -> {
                            if (!guardResult.isAllowed()) {
                                return ExecutionResult.blocked(guardResult.getReason());
                            }
                            return result;
                        });
                })
                .onItem().invoke(result -> {
                    // Record metrics and provenance
                    var duration = System.nanoTime() - startTime;
                    metrics.recordExecution(duration, result.getStatus());
                    provenance.log(context, result);
                })
                .onFailure().recoverWithItem(throwable -> {
                    // Wrap exceptions into structured error result
                    metrics.recordFailure(throwable);
                    return ExecutionResult.error(
                        ErrorPayload.from(throwable, descriptor.getId(), context)
                    );
                })
                .eventually(() -> endTrace(span));
        });
    }
    
    /**
     * Subclasses implement actual execution logic here
     */
    protected abstract Uni<ExecutionResult> doExecute(NodeContext context);
    
    /**
     * Optional: Custom initialization logic
     */
    protected void doOnLoad(NodeDescriptor descriptor, NodeConfig config) {
        // Default: no-op
    }
    
    /**
     * Validate inputs against declared schema
     */
    private Uni<Boolean> validateInputs(NodeContext context) {
        return Uni.createFrom().item(() -> {
            for (var inputPort : descriptor.getInputs()) {
                var value = context.getInput(inputPort.getName());
                if (inputPort.isRequired() && value == null) {
                    return false;
                }
                if (value != null && !validateAgainstSchema(value, inputPort.getSchema())) {
                    return false;
                }
            }
            return true;
        });
    }
    
    private boolean validateAgainstSchema(Object value, JsonSchema schema) {
        // Use JSON Schema validator
        return SchemaValidator.validate(value, schema);
    }
    
    private Span startTrace(NodeContext context) {
        return Tracer.startSpan("node.execute")
            .withTag("node.id", descriptor.getId())
            .withTag("node.type", descriptor.getType())
            .withTag("run.id", context.getRunId())
            .withTag("tenant.id", context.getTenantId());
    }
    
    private void endTrace(Span span) {
        span.finish();
    }
    
    @Override
    public void onUnload() {
        // Cleanup resources
        if (metrics != null) {
            metrics.close();
        }
    }
}

/**
 * Node execution context - carries all runtime state
 */
public interface NodeContext {
    
    // Execution metadata
    String getRunId();
    String getNodeId();
    String getTenantId();
    String getTraceId();
    
    // Input/output handling
    <T> T getInput(String portName);
    Map<String, Object> getAllInputs();
    void setOutput(String portName, Object value);
    
    // Variable access (workflow-level)
    <T> T getVariable(String name);
    void setVariable(String name, Object value);
    
    // Metadata and execution info
    ExecutionMetadata getMetadata();
    Optional<CheckpointState> getPreviousCheckpoint();
    
    // Resource access
    ToolGatewayClient getToolGateway();
    ModelRouterClient getModelRouter();
    RAGClient getRAGClient();
    MemoryClient getMemoryClient();
    
    // Observability
    void emitEvent(String eventType, Map<String, Object> payload);
    Logger getLogger();
}

/**
 * Execution result with success/error outputs
 */
public class ExecutionResult {
    
    private final Status status;
    private final Map<String, Object> outputs;
    private final List<String> logs;
    private final Optional<ErrorPayload> error;
    private final Map<String, Object> metadata;
    
    public enum Status {
        SUCCESS,
        FAILED,
        BLOCKED,
        TIMEOUT,
        RETRY
    }
    
    public static ExecutionResult success(Map<String, Object> outputs) {
        return new ExecutionResult(Status.SUCCESS, outputs, List.of(), Optional.empty(), Map.of());
    }
    
    public static ExecutionResult failed(String reason) {
        var error = ErrorPayload.builder()
            .type(ErrorType.ValidationError)
            .message(reason)
            .retryable(false)
            .build();
        return new ExecutionResult(Status.FAILED, Map.of(), List.of(), Optional.of(error), Map.of());
    }
    
    public static ExecutionResult error(ErrorPayload error) {
        return new ExecutionResult(Status.FAILED, Map.of(), List.of(), Optional.of(error), Map.of());
    }
    
    public static ExecutionResult blocked(String reason) {
        return new ExecutionResult(Status.BLOCKED, Map.of(), List.of(reason), Optional.empty(), Map.of());
    }
    
    // Getters
    public Status getStatus() { return status; }
    public Map<String, Object> getOutputs() { return outputs; }
    public Optional<ErrorPayload> getError() { return error; }
    public boolean isSuccess() { return status == Status.SUCCESS; }
}

/**
 * Structured error payload for error-as-input pattern
 */
public class ErrorPayload {
    private ErrorType type;
    private String message;
    private Map<String, Object> details;
    private boolean retryable;
    private String originNode;
    private String originRunId;
    private int attempt;
    private int maxAttempts;
    private Instant timestamp;
    private String suggestedAction;
    private String provenanceRef;
    
    public enum ErrorType {
        ToolError,
        LLMError,
        NetworkError,
        ValidationError,
        Timeout,
        UnknownError
    }
    
    public static ErrorPayload from(Throwable throwable, String nodeId, NodeContext context) {
        return builder()
            .type(mapExceptionType(throwable))
            .message(throwable.getMessage())
            .retryable(isRetryable(throwable))
            .originNode(nodeId)
            .originRunId(context.getRunId())
            .timestamp(Instant.now())
            .suggestedAction(determineSuggestedAction(throwable))
            .build();
    }
    
    private static ErrorType mapExceptionType(Throwable t) {
        if (t instanceof TimeoutException) return ErrorType.Timeout;
        if (t instanceof ValidationException) return ErrorType.ValidationError;
        if (t instanceof ToolException) return ErrorType.ToolError;
        if (t instanceof LLMException) return ErrorType.LLMError;
        if (t instanceof IOException) return ErrorType.NetworkError;
        return ErrorType.UnknownError;
    }
    
    private static boolean isRetryable(Throwable t) {
        return t instanceof TimeoutException 
            || t instanceof IOException
            || (t instanceof LLMException && ((LLMException) t).isRetryable());
    }
    
    private static String determineSuggestedAction(Throwable t) {
        if (isRetryable(t)) return "retry";
        if (t instanceof ValidationException) return "auto_fix";
        return "escalate";
    }
    
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private final ErrorPayload error = new ErrorPayload();
        
        public Builder type(ErrorType type) {
            error.type = type;
            return this;
        }
        
        public Builder message(String message) {
            error.message = message;
            return this;
        }
        
        public Builder retryable(boolean retryable) {
            error.retryable = retryable;
            return this;
        }
        
        public Builder originNode(String nodeId) {
            error.originNode = nodeId;
            return this;
        }
        
        public Builder originRunId(String runId) {
            error.originRunId = runId;
            return this;
        }
        
        public Builder timestamp(Instant timestamp) {
            error.timestamp = timestamp;
            return this;
        }
        
        public Builder suggestedAction(String action) {
            error.suggestedAction = action;
            return this;
        }
        
        public ErrorPayload build() {
            return error;
        }
    }
}

package tech.kayys.wayang.core.node.factory;

import io.quarkus.runtime.Startup;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Instance;
import jakarta.inject.Inject;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Central registry for all node types (built-in and plugins)
 * Provides discovery, validation, and instantiation services
 */
@ApplicationScoped
@Startup
public class NodeRegistry {
    
    private final Map<String, NodeDescriptor> descriptors = new ConcurrentHashMap<>();
    private final Map<String, NodeFactory> factories = new ConcurrentHashMap<>();
    
    @Inject
    Instance<Node> builtinNodes;
    
    @Inject
    PluginLoader pluginLoader;
    
    @Inject
    SchemaValidator schemaValidator;
    
    public void initialize() {
        // Register built-in nodes
        registerBuiltinNodes();
        
        // Load plugin nodes
        loadPluginNodes();
    }
    
    /**
     * Register all built-in nodes using CDI discovery
     */
    private void registerBuiltinNodes() {
        builtinNodes.forEach(node -> {
            var annotation = node.getClass().getAnnotation(NodeType.class);
            if (annotation != null) {
                var nodeType = annotation.value();
                var descriptor = loadDescriptor(nodeType);
                var factory = new ReflectiveNodeFactory(node.getClass());
                
                register(nodeType, descriptor, factory);
            }
        });
    }
    
    /**
     * Load plugin nodes from plugin manager
     */
    private void loadPluginNodes() {
        var plugins = pluginLoader.loadAllPlugins();
        
        for (var plugin : plugins) {
            var descriptor = plugin.getDescriptor();
            var factory = plugin.getFactory();
            
            // Validate plugin descriptor
            var errors = schemaValidator.validate(descriptor);
            if (!errors.isEmpty()) {
                throw new PluginValidationException(
                    "Plugin descriptor validation failed: " + errors
                );
            }
            
            register(descriptor.getId(), descriptor, factory);
        }
    }
    
    /**
     * Register a node type with its descriptor and factory
     */
    public void register(String nodeType, NodeDescriptor descriptor, NodeFactory factory) {
        // Validate descriptor against schema
        validateDescriptor(descriptor);
        
        descriptors.put(nodeType, descriptor);
        factories.put(nodeType, factory);
        
        logger.info("Registered node type: {}", nodeType);
    }
    
    /**
     * Get node descriptor by type
     */
    public NodeDescriptor getDescriptor(String nodeType) {
        var descriptor = descriptors.get(nodeType);
        if (descriptor == null) {
            throw new NodeNotFoundException("Node type not found: " + nodeType);
        }
        return descriptor;
    }
    
    /**
     * Create node instance
     */
    public Node createNode(String nodeType) {
        var factory = factories.get(nodeType);
        if (factory == null) {
            throw new NodeNotFoundException("Node type not found: " + nodeType);
        }
        
        var descriptor = descriptors.get(nodeType);
        return factory.create(descriptor);
    }
    
    /**
     * List all available node types
     */
    public List<NodeDescriptor> listAll() {
        return new ArrayList<>(descriptors.values());
    }
    
    /**
     * List nodes by category
     */
    public List<NodeDescriptor> listByCategory(String category) {
        return descriptors.values().stream()
            .filter(d -> d.getType().startsWith(category))
            .collect(Collectors.toList());
    }
    
    /**
     * Validate descriptor against base schema
     */
    private void validateDescriptor(NodeDescriptor descriptor) {
        var errors = schemaValidator.validate(
            descriptor,
            "https://kayys.tech/schema/v1/node-base.schema.json"
        );
        
        if (!errors.isEmpty()) {
            throw new DescriptorValidationException(
                "Descriptor validation failed: " + errors
            );
        }
    }
    
    /**
     * Load descriptor from resources
     */
    private NodeDescriptor loadDescriptor(String nodeType) {
        var resourcePath = "/nodes/descriptors/" + nodeType + ".json";
        try {
            var json = Resources.readString(resourcePath);
            return JsonUtils.fromJson(json, NodeDescriptor.class);
        } catch (IOException e) {
            throw new DescriptorLoadException(
                "Failed to load descriptor for: " + nodeType,
                e
            );
        }
    }
}

/**
 * Factory interface for creating node instances
 */
public interface NodeFactory {
    
    /**
     * Create a new node instance
     */
    Node create(NodeDescriptor descriptor);
    
    /**
     * Validate if this factory can create the node
     */
    void validate(NodeDescriptor descriptor);
}

/**
 * Reflective factory for built-in nodes
 * Uses reflection to instantiate CDI-managed beans
 */
public class ReflectiveNodeFactory implements NodeFactory {
    
    private final Class<? extends Node> nodeClass;
    
    public ReflectiveNodeFactory(Class<? extends Node> nodeClass) {
        this.nodeClass = nodeClass;
    }
    
    @Override
    public Node create(NodeDescriptor descriptor) {
        try {
            // For built-in nodes, use CDI to get instance
            return CDI.current().select(nodeClass).get();
        } catch (Exception e) {
            throw new NodeInstantiationException(
                "Failed to instantiate node: " + nodeClass.getName(),
                e
            );
        }
    }
    
    @Override
    public void validate(NodeDescriptor descriptor) {
        // Validate that class implements Node interface
        if (!Node.class.isAssignableFrom(nodeClass)) {
            throw new ValidationException(
                "Class does not implement Node interface: " + nodeClass.getName()
            );
        }
    }
}

/**
 * Plugin factory for dynamically loaded nodes
 * Supports multiple loading strategies (classloader, WASM, container)
 */
public class PluginNodeFactory implements NodeFactory {
    
    private final PluginDescriptor pluginDescriptor;
    private final PluginLoader loader;
    
    public PluginNodeFactory(PluginDescriptor pluginDescriptor, PluginLoader loader) {
        this.pluginDescriptor = pluginDescriptor;
        this.loader = loader;
    }
    
    @Override
    public Node create(NodeDescriptor descriptor) {
        var implementation = pluginDescriptor.getImplementation();
        
        return switch (implementation.getType()) {
            case "maven", "jar" -> createJavaNode(implementation);
            case "wasm" -> createWasmNode(implementation);
            case "container" -> createContainerNode(implementation);
            case "python" -> createPythonNode(implementation);
            default -> throw new UnsupportedPluginTypeException(
                "Unsupported plugin type: " + implementation.getType()
            );
        };
    }
    
    private Node createJavaNode(PluginImplementation impl) {
        // Load class using isolated classloader
        var classLoader = loader.createIsolatedClassLoader(impl);
        try {
            var nodeClass = classLoader.loadClass(impl.getEntrypoint());
            return (Node) nodeClass.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new NodeInstantiationException("Failed to load Java plugin", e);
        }
    }
    
    private Node createWasmNode(PluginImplementation impl) {
        // Create WASM adapter node
        return new WasmNodeAdapter(impl, loader);
    }
    
    private Node createContainerNode(PluginImplementation impl) {
        // Create container sidecar adapter
        return new ContainerNodeAdapter(impl, loader);
    }
    
    private Node createPythonNode(PluginImplementation impl) {
        // Create Python subprocess adapter
        return new PythonNodeAdapter(impl, loader);
    }
    
    @Override
    public void validate(NodeDescriptor descriptor) {
        // Validate plugin implementation details
        var impl = pluginDescriptor.getImplementation();
        
        // Verify signature
        if (!loader.verifySignature(impl)) {
            throw new SecurityException("Plugin signature verification failed");
        }
        
        // Verify capabilities
        validateCapabilities(descriptor.getCapabilities());
    }
    
    private void validateCapabilities(List<String> capabilities) {
        // Check if required capabilities are allowed
        for (var capability : capabilities) {
            if (!isCapabilityAllowed(capability)) {
                throw new SecurityException(
                    "Capability not allowed: " + capability
                );
            }
        }
    }
    
    private boolean isCapabilityAllowed(String capability) {
        // Check against policy engine
        return PolicyEngine.instance().isCapabilityAllowed(capability);
    }
}

/**
 * Node descriptor model class
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class NodeDescriptor {
    
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("type")
    private String type;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("author")
    private Author author;
    
    @JsonProperty("inputs")
    private List<PortDescriptor> inputs;
    
    @JsonProperty("outputs")
    private OutputDescriptor outputs;
    
    @JsonProperty("properties")
    private List<PropertyDescriptor> properties;
    
    @JsonProperty("errorHandling")
    private ErrorHandlingConfig errorHandling;
    
    @JsonProperty("observability")
    private ObservabilityConfig observability;
    
    @JsonProperty("audit")
    private AuditConfig audit;
    
    @JsonProperty("resourceProfile")
    private ResourceProfile resourceProfile;
    
    @JsonProperty("capabilities")
    private List<String> capabilities;
    
    // Getters and setters...
    
    public String getId() { return id; }
    public String getType() { return type; }
    public List<PortDescriptor> getInputs() { return inputs; }
    public OutputDescriptor getOutputs() { return outputs; }
    public List<PropertyDescriptor> getProperties() { return properties; }
    public ErrorHandlingConfig getErrorHandling() { return errorHandling; }
    public List<String> getCapabilities() { return capabilities; }
}

/**
 * Port descriptor for node inputs/outputs
 */
public class PortDescriptor {
    
    private String name;
    private String displayName;
    private String description;
    private DataDescriptor data;
    
    public static class DataDescriptor {
        private String type;
        private String format;
        private Object schema;
        private String multiplicity;
        private String source;
        private boolean required;
        private Object defaultValue;
        private boolean sensitive;
        
        // Getters and setters...
    }
    
    // Getters and setters...
    public String getName() { return name; }
    public boolean isRequired() { return data != null && data.required; }
    public Object getSchema() { return data != null ? data.schema : null; }
}

/**
 * Node annotation for marking built-in node types
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface NodeType {
    String value();
}

/**
 * Node configuration passed to nodes at load time
 */
public class NodeConfig {
    
    private final Map<String, Object> properties;
    
    public NodeConfig(Map<String, Object> properties) {
        this.properties = properties != null ? properties : Map.of();
    }
    
    public String getString(String key) {
        return (String) properties.get(key);
    }
    
    public String getString(String key, String defaultValue) {
        return (String) properties.getOrDefault(key, defaultValue);
    }
    
    public int getInt(String key, int defaultValue) {
        var value = properties.get(key);
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        return defaultValue;
    }
    
    public boolean getBoolean(String key, boolean defaultValue) {
        var value = properties.get(key);
        if (value instanceof Boolean) {
            return (Boolean) value;
        }
        return defaultValue;
    }
    
    public double getDouble(String key, double defaultValue) {
        var value = properties.get(key);
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        return defaultValue;
    }
    
    @SuppressWarnings("unchecked")
    public <T> T getObject(String key, Class<T> type) {
        return (T) properties.get(key);
    }
    
    @SuppressWarnings("unchecked")
    public <T> List<T> getList(String key, Class<T> elementType) {
        var value = properties.get(key);
        if (value instanceof List) {
            return (List<T>) value;
        }
        return List.of();
    }
}

/**
 * Modular runtime support for standalone agents
 * Provides minimal footprint by only including required dependencies
 */
@ApplicationScoped
public class ModularRuntimeSupport {
    
    /**
     * Analyze workflow to determine required modules
     */
    public Set<String> analyzeRequiredModules(WorkflowDefinition workflow) {
        var modules = new HashSet<String>();
        
        // Always include core
        modules.add("wayang-core");
        
        // Analyze nodes to determine dependencies
        for (var node : workflow.getNodes()) {
            modules.addAll(getNodeModules(node));
        }
        
        return modules;
    }
    
    /**
     * Get required modules for a specific node type
     */
    private Set<String> getNodeModules(NodeInstance node) {
        var modules = new HashSet<String>();
        
        var descriptor = nodeRegistry.getDescriptor(node.getType());
        
        // Check capabilities to determine required modules
        if (descriptor.getCapabilities().contains("llm_access")) {
            modules.add("wayang-llm-runtime");
        }
        
        if (descriptor.getCapabilities().contains("rag_access")) {
            modules.add("wayang-rag-lite");
            modules.add("wayang-vector-db");
        }
        
        if (descriptor.getCapabilities().contains("memory_access")) {
            modules.add("wayang-memory-lite");
        }
        
        if (descriptor.getCapabilities().contains("tool_execution")) {
            modules.add("wayang-mcp-client");
        }
        
        if (descriptor.getCapabilities().contains("database")) {
            modules.add("wayang-jdbc-adapter");
        }
        
        // Check if HITL nodes present
        if (node.getType().contains("hitl")) {
            modules.add("wayang-hitl-client");
        }
        
        return modules;
    }
    
    /**
     * Generate minimal pom.xml for standalone runtime
     */
    public String generatePomXml(Set<String> modules, WorkflowDefinition workflow) {
        var pom = new StringBuilder();
        pom.append("<?xml version=\"1.0\"?>\n");
        pom.append("<project>\n");
        pom.append("  <modelVersion>4.0.0</modelVersion>\n");
        pom.append("  <groupId>tech.kayys.wayang.generated</groupId>\n");
        pom.append("  <artifactId>").append(workflow.getId()).append("</artifactId>\n");
        pom.append("  <version>").append(workflow.getVersion()).append("</version>\n");
        pom.append("  <dependencies>\n");
        
        // Add minimal Quarkus dependencies
        pom.append("    <dependency>\n");
        pom.append("      <groupId>io.quarkus</groupId>\n");
        pom.append("      <artifactId>quarkus-core</artifactId>\n");
        pom.append("    </dependency>\n");
        
        // Add required Wayang modules
        for (var module : modules) {
            pom.append("    <dependency>\n");
            pom.append("      <groupId>tech.kayys.wayang</groupId>\n");
            pom.append("      <artifactId>").append(module).append("</artifactId>\n");
            pom.append("      <version>${wayang.version}</version>\n");
            pom.append("    </dependency>\n");
        }
        
        pom.append("  </dependencies>\n");
        pom.append("</project>\n");
        
        return pom.toString();
    }
}


package tech.kayys.wayang.core.node.factory;

import io.quarkus.runtime.Startup;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Instance;
import jakarta.inject.Inject;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Central registry for all node types (built-in and plugins)
 * Provides discovery, validation, and instantiation services
 */
@ApplicationScoped
@Startup
public class NodeRegistry {
    
    private final Map<String, NodeDescriptor> descriptors = new ConcurrentHashMap<>();
    private final Map<String, NodeFactory> factories = new ConcurrentHashMap<>();
    
    @Inject
    Instance<Node> builtinNodes;
    
    @Inject
    PluginLoader pluginLoader;
    
    @Inject
    SchemaValidator schemaValidator;
    
    public void initialize() {
        // Register built-in nodes
        registerBuiltinNodes();
        
        // Load plugin nodes
        loadPluginNodes();
    }
    
    /**
     * Register all built-in nodes using CDI discovery
     */
    private void registerBuiltinNodes() {
        builtinNodes.forEach(node -> {
            var annotation = node.getClass().getAnnotation(NodeType.class);
            if (annotation != null) {
                var nodeType = annotation.value();
                var descriptor = loadDescriptor(nodeType);
                var factory = new ReflectiveNodeFactory(node.getClass());
                
                register(nodeType, descriptor, factory);
            }
        });
    }
    
    /**
     * Load plugin nodes from plugin manager
     */
    private void loadPluginNodes() {
        var plugins = pluginLoader.loadAllPlugins();
        
        for (var plugin : plugins) {
            var descriptor = plugin.getDescriptor();
            var factory = plugin.getFactory();
            
            // Validate plugin descriptor
            var errors = schemaValidator.validate(descriptor);
            if (!errors.isEmpty()) {
                throw new PluginValidationException(
                    "Plugin descriptor validation failed: " + errors
                );
            }
            
            register(descriptor.getId(), descriptor, factory);
        }
    }
    
    /**
     * Register a node type with its descriptor and factory
     */
    public void register(String nodeType, NodeDescriptor descriptor, NodeFactory factory) {
        // Validate descriptor against schema
        validateDescriptor(descriptor);
        
        descriptors.put(nodeType, descriptor);
        factories.put(nodeType, factory);
        
        logger.info("Registered node type: {}", nodeType);
    }
    
    /**
     * Get node descriptor by type
     */
    public NodeDescriptor getDescriptor(String nodeType) {
        var descriptor = descriptors.get(nodeType);
        if (descriptor == null) {
            throw new NodeNotFoundException("Node type not found: " + nodeType);
        }
        return descriptor;
    }
    
    /**
     * Create node instance
     */
    public Node createNode(String nodeType) {
        var factory = factories.get(nodeType);
        if (factory == null) {
            throw new NodeNotFoundException("Node type not found: " + nodeType);
        }
        
        var descriptor = descriptors.get(nodeType);
        return factory.create(descriptor);
    }
    
    /**
     * List all available node types
     */
    public List<NodeDescriptor> listAll() {
        return new ArrayList<>(descriptors.values());
    }
    
    /**
     * List nodes by category
     */
    public List<NodeDescriptor> listByCategory(String category) {
        return descriptors.values().stream()
            .filter(d -> d.getType().startsWith(category))
            .collect(Collectors.toList());
    }
    
    /**
     * Validate descriptor against base schema
     */
    private void validateDescriptor(NodeDescriptor descriptor) {
        var errors = schemaValidator.validate(
            descriptor,
            "https://kayys.tech/schema/v1/node-base.schema.json"
        );
        
        if (!errors.isEmpty()) {
            throw new DescriptorValidationException(
                "Descriptor validation failed: " + errors
            );
        }
    }
    
    /**
     * Load descriptor from resources
     */
    private NodeDescriptor loadDescriptor(String nodeType) {
        var resourcePath = "/nodes/descriptors/" + nodeType + ".json";
        try {
            var json = Resources.readString(resourcePath);
            return JsonUtils.fromJson(json, NodeDescriptor.class);
        } catch (IOException e) {
            throw new DescriptorLoadException(
                "Failed to load descriptor for: " + nodeType,
                e
            );
        }
    }
}

/**
 * Factory interface for creating node instances
 */
public interface NodeFactory {
    
    /**
     * Create a new node instance
     */
    Node create(NodeDescriptor descriptor);
    
    /**
     * Validate if this factory can create the node
     */
    void validate(NodeDescriptor descriptor);
}

/**
 * Reflective factory for built-in nodes
 * Uses reflection to instantiate CDI-managed beans
 */
public class ReflectiveNodeFactory implements NodeFactory {
    
    private final Class<? extends Node> nodeClass;
    
    public ReflectiveNodeFactory(Class<? extends Node> nodeClass) {
        this.nodeClass = nodeClass;
    }
    
    @Override
    public Node create(NodeDescriptor descriptor) {
        try {
            // For built-in nodes, use CDI to get instance
            return CDI.current().select(nodeClass).get();
        } catch (Exception e) {
            throw new NodeInstantiationException(
                "Failed to instantiate node: " + nodeClass.getName(),
                e
            );
        }
    }
    
    @Override
    public void validate(NodeDescriptor descriptor) {
        // Validate that class implements Node interface
        if (!Node.class.isAssignableFrom(nodeClass)) {
            throw new ValidationException(
                "Class does not implement Node interface: " + nodeClass.getName()
            );
        }
    }
}

/**
 * Plugin factory for dynamically loaded nodes
 * Supports multiple loading strategies (classloader, WASM, container)
 */
public class PluginNodeFactory implements NodeFactory {
    
    private final PluginDescriptor pluginDescriptor;
    private final PluginLoader loader;
    
    public PluginNodeFactory(PluginDescriptor pluginDescriptor, PluginLoader loader) {
        this.pluginDescriptor = pluginDescriptor;
        this.loader = loader;
    }
    
    @Override
    public Node create(NodeDescriptor descriptor) {
        var implementation = pluginDescriptor.getImplementation();
        
        return switch (implementation.getType()) {
            case "maven", "jar" -> createJavaNode(implementation);
            case "wasm" -> createWasmNode(implementation);
            case "container" -> createContainerNode(implementation);
            case "python" -> createPythonNode(implementation);
            default -> throw new UnsupportedPluginTypeException(
                "Unsupported plugin type: " + implementation.getType()
            );
        };
    }
    
    private Node createJavaNode(PluginImplementation impl) {
        // Load class using isolated classloader
        var classLoader = loader.createIsolatedClassLoader(impl);
        try {
            var nodeClass = classLoader.loadClass(impl.getEntrypoint());
            return (Node) nodeClass.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new NodeInstantiationException("Failed to load Java plugin", e);
        }
    }
    
    private Node createWasmNode(PluginImplementation impl) {
        // Create WASM adapter node
        return new WasmNodeAdapter(impl, loader);
    }
    
    private Node createContainerNode(PluginImplementation impl) {
        // Create container sidecar adapter
        return new ContainerNodeAdapter(impl, loader);
    }
    
    private Node createPythonNode(PluginImplementation impl) {
        // Create Python subprocess adapter
        return new PythonNodeAdapter(impl, loader);
    }
    
    @Override
    public void validate(NodeDescriptor descriptor) {
        // Validate plugin implementation details
        var impl = pluginDescriptor.getImplementation();
        
        // Verify signature
        if (!loader.verifySignature(impl)) {
            throw new SecurityException("Plugin signature verification failed");
        }
        
        // Verify capabilities
        validateCapabilities(descriptor.getCapabilities());
    }
    
    private void validateCapabilities(List<String> capabilities) {
        // Check if required capabilities are allowed
        for (var capability : capabilities) {
            if (!isCapabilityAllowed(capability)) {
                throw new SecurityException(
                    "Capability not allowed: " + capability
                );
            }
        }
    }
    
    private boolean isCapabilityAllowed(String capability) {
        // Check against policy engine
        return PolicyEngine.instance().isCapabilityAllowed(capability);
    }
}

/**
 * Node descriptor model class
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class NodeDescriptor {
    
    @JsonProperty("id")
    private String id;
    
    @JsonProperty("type")
    private String type;
    
    @JsonProperty("description")
    private String description;
    
    @JsonProperty("author")
    private Author author;
    
    @JsonProperty("inputs")
    private List<PortDescriptor> inputs;
    
    @JsonProperty("outputs")
    private OutputDescriptor outputs;
    
    @JsonProperty("properties")
    private List<PropertyDescriptor> properties;
    
    @JsonProperty("errorHandling")
    private ErrorHandlingConfig errorHandling;
    
    @JsonProperty("observability")
    private ObservabilityConfig observability;
    
    @JsonProperty("audit")
    private AuditConfig audit;
    
    @JsonProperty("resourceProfile")
    private ResourceProfile resourceProfile;
    
    @JsonProperty("capabilities")
    private List<String> capabilities;
    
    // Getters and setters...
    
    public String getId() { return id; }
    public String getType() { return type; }
    public List<PortDescriptor> getInputs() { return inputs; }
    public OutputDescriptor getOutputs() { return outputs; }
    public List<PropertyDescriptor> getProperties() { return properties; }
    public ErrorHandlingConfig getErrorHandling() { return errorHandling; }
    public List<String> getCapabilities() { return capabilities; }
}

/**
 * Port descriptor for node inputs/outputs
 */
public class PortDescriptor {
    
    private String name;
    private String displayName;
    private String description;
    private DataDescriptor data;
    
    public static class DataDescriptor {
        private String type;
        private String format;
        private Object schema;
        private String multiplicity;
        private String source;
        private boolean required;
        private Object defaultValue;
        private boolean sensitive;
        
        // Getters and setters...
    }
    
    // Getters and setters...
    public String getName() { return name; }
    public boolean isRequired() { return data != null && data.required; }
    public Object getSchema() { return data != null ? data.schema : null; }
}

/**
 * Node annotation for marking built-in node types
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface NodeType {
    String value();
}

/**
 * Node configuration passed to nodes at load time
 */
public class NodeConfig {
    
    private final Map<String, Object> properties;
    
    public NodeConfig(Map<String, Object> properties) {
        this.properties = properties != null ? properties : Map.of();
    }
    
    public String getString(String key) {
        return (String) properties.get(key);
    }
    
    public String getString(String key, String defaultValue) {
        return (String) properties.getOrDefault(key, defaultValue);
    }
    
    public int getInt(String key, int defaultValue) {
        var value = properties.get(key);
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        return defaultValue;
    }
    
    public boolean getBoolean(String key, boolean defaultValue) {
        var value = properties.get(key);
        if (value instanceof Boolean) {
            return (Boolean) value;
        }
        return defaultValue;
    }
    
    public double getDouble(String key, double defaultValue) {
        var value = properties.get(key);
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        return defaultValue;
    }
    
    @SuppressWarnings("unchecked")
    public <T> T getObject(String key, Class<T> type) {
        return (T) properties.get(key);
    }
    
    @SuppressWarnings("unchecked")
    public <T> List<T> getList(String key, Class<T> elementType) {
        var value = properties.get(key);
        if (value instanceof List) {
            return (List<T>) value;
        }
        return List.of();
    }
}

/**
 * Modular runtime support for standalone agents
 * Provides minimal footprint by only including required dependencies
 */
@ApplicationScoped
public class ModularRuntimeSupport {
    
    /**
     * Analyze workflow to determine required modules
     */
    public Set<String> analyzeRequiredModules(WorkflowDefinition workflow) {
        var modules = new HashSet<String>();
        
        // Always include core
        modules.add("wayang-core");
        
        // Analyze nodes to determine dependencies
        for (var node : workflow.getNodes()) {
            modules.addAll(getNodeModules(node));
        }
        
        return modules;
    }
    
    /**
     * Get required modules for a specific node type
     */
    private Set<String> getNodeModules(NodeInstance node) {
        var modules = new HashSet<String>();
        
        var descriptor = nodeRegistry.getDescriptor(node.getType());
        
        // Check capabilities to determine required modules
        if (descriptor.getCapabilities().contains("llm_access")) {
            modules.add("wayang-llm-runtime");
        }
        
        if (descriptor.getCapabilities().contains("rag_access")) {
            modules.add("wayang-rag-lite");
            modules.add("wayang-vector-db");
        }
        
        if (descriptor.getCapabilities().contains("memory_access")) {
            modules.add("wayang-memory-lite");
        }
        
        if (descriptor.getCapabilities().contains("tool_execution")) {
            modules.add("wayang-mcp-client");
        }
        
        if (descriptor.getCapabilities().contains("database")) {
            modules.add("wayang-jdbc-adapter");
        }
        
        // Check if HITL nodes present
        if (node.getType().contains("hitl")) {
            modules.add("wayang-hitl-client");
        }
        
        return modules;
    }
    
    /**
     * Generate minimal pom.xml for standalone runtime
     */
    public String generatePomXml(Set<String> modules, WorkflowDefinition workflow) {
        var pom = new StringBuilder();
        pom.append("<?xml version=\"1.0\"?>\n");
        pom.append("<project>\n");
        pom.append("  <modelVersion>4.0.0</modelVersion>\n");
        pom.append("  <groupId>tech.kayys.wayang.generated</groupId>\n");
        pom.append("  <artifactId>").append(workflow.getId()).append("</artifactId>\n");
        pom.append("  <version>").append(workflow.getVersion()).append("</version>\n");
        pom.append("  <dependencies>\n");
        
        // Add minimal Quarkus dependencies
        pom.append("    <dependency>\n");
        pom.append("      <groupId>io.quarkus</groupId>\n");
        pom.append("      <artifactId>quarkus-core</artifactId>\n");
        pom.append("    </dependency>\n");
        
        // Add required Wayang modules
        for (var module : modules) {
            pom.append("    <dependency>\n");
            pom.append("      <groupId>tech.kayys.wayang</groupId>\n");
            pom.append("      <artifactId>").append(module).append("</artifactId>\n");
            pom.append("      <version>${wayang.version}</version>\n");
            pom.append("    </dependency>\n");
        }
        
        pom.append("  </dependencies>\n");
        pom.append("</project>\n");
        
        return pom.toString();
    }
}

package tech.kayys.wayang.nodes.clients;

import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import io.smallrye.mutiny.Uni;

/**
 * ==============================================
 * REST CLIENT INTERFACES
 * ==============================================
 */

@Path("/api/v1/model")
@RegisterRestClient(configKey = "model-router")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public interface ModelRouterService {
    
    @POST
    @Path("/complete")
    Uni<ModelApiResponse> complete(ModelApiRequest request);
    
    @POST
    @Path("/embed")
    Uni<EmbedApiResponse> embed(EmbedApiRequest request);
    
    @GET
    @Path("/models/{modelId}")
    Uni<ModelInfo> getModel(@PathParam("modelId") String modelId);
}

@Path("/api/v1/rag")
@RegisterRestClient(configKey = "rag-service")
public interface RAGService {
    
    @POST
    @Path("/vector-search")
    Uni<VectorSearchResponse> vectorSearch(VectorSearchRequest request);
    
    @POST
    @Path("/keyword-search")
    Uni<KeywordSearchResponse> keywordSearch(KeywordSearchRequest request);
}

@Path("/api/v1/memory")
@RegisterRestClient(configKey = "memory-service")
public interface MemoryService {
    
    @POST
    @Path("/write")
    Uni<MemoryWriteResponse> writeMemory(MemoryWriteRequest request);
    
    @POST
    @Path("/query")
    Uni<MemoryQueryResponse> queryMemory(MemoryQueryRequest request);
    
    @POST
    @Path("/consolidate/{tenantId}")
    Uni<Void> consolidateMemories(@PathParam("tenantId") String tenantId);
}

@Path("/api/v1/tools")
@RegisterRestClient(configKey = "tool-gateway")
public interface ToolGatewayService {
    
    @GET
    @Path("/{toolName}/definition")
    Uni<ToolDefinition> getToolDefinition(@PathParam("toolName") String toolName);
    
    @POST
    @Path("/execute")
    Uni<ToolExecutionResponse> executeTool(ToolExecutionRequest request);
}

@Path("/api/v1/hitl")
@RegisterRestClient(configKey = "hitl-service")
public interface HITLServiceClient {
    
    @POST
    @Path("/tasks")
    Uni<HITLTaskResponse> createTask(HITLTaskRequest request);
    
    @GET
    @Path("/tasks/{taskId}/status")
    Uni<HITLTaskStatus> getTaskStatus(@PathParam("taskId") String taskId);
    
    @GET
    @Path("/tasks/{taskId}/decision")
    Uni<HITLDecision> getTaskDecision(@PathParam("taskId") String taskId);
}

@Path("/api/v1/audit")
@RegisterRestClient(configKey = "audit-service")
public interface AuditServiceClient {
    
    @POST
    @Path("/log")
    Uni<AuditLogResponse> logEntry(AuditLogRequest request);
    
    @POST
    @Path("/query")
    Uni<AuditQueryResponse> queryLogs(AuditQuery query);
}

@Path("/api/v1/http")
@RegisterRestClient(configKey = "http-client")
public interface HttpClientService {
    
    @POST
    @Path("/execute")
    Uni<HttpResponse> execute(HttpRequest request);
}

/**
 * ==============================================
 * UTILITY CLASSES
 * ==============================================
 */

/**
 * JSON utilities using Jackson
 */
@ApplicationScoped
public class JsonUtils {
    
    private static final ObjectMapper MAPPER = new ObjectMapper()
        .registerModule(new JavaTimeModule())
        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
        .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    
    public static String toJson(Object obj) {
        try {
            return MAPPER.writeValueAsString(obj);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to serialize to JSON", e);
        }
    }
    
    public static <T> T fromJson(String json, Class<T> clazz) {
        try {
            return MAPPER.readValue(json, clazz);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to deserialize from JSON", e);
        }
    }
    
    public static <T> T fromJson(String json, TypeReference<T> typeRef) {
        try {
            return MAPPER.readValue(json, typeRef);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to deserialize from JSON", e);
        }
    }
    
    public static JsonNode toJsonNode(Object obj) {
        return MAPPER.valueToTree(obj);
    }
    
    public static Object jsonToObject(String json) {
        try {
            return MAPPER.readValue(json, Object.class);
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Failed to parse JSON", e);
        }
    }
}

/**
 * Token counter for LLM context management
 */
@ApplicationScoped
public class TokenCounter {
    
    private final Encoding encoding;
    
    public TokenCounter() {
        // Use cl100k_base encoding (GPT-4, GPT-3.5-turbo)
        this.encoding = Encodings.newDefaultEncodingRegistry().getEncoding(EncodingType.CL100K_BASE);
    }
    
    public int count(Object obj) {
        if (obj == null) return 0;
        
        if (obj instanceof String) {
            return countText((String) obj);
        }
        
        if (obj instanceof Prompt) {
            return countPrompt((Prompt) obj);
        }
        
        // Convert to JSON and count
        var json = JsonUtils.toJson(obj);
        return countText(json);
    }
    
    public int countText(String text) {
        if (text == null || text.isEmpty()) return 0;
        return encoding.countTokens(text);
    }
    
    public int countPrompt(Prompt prompt) {
        int total = 0;
        
        if (prompt.getSystem() != null) {
            total += countText(prompt.getSystem());
        }
        
        if (prompt.getUser() != null) {
            total += countText(prompt.getUser());
        }
        
        if (prompt.getContext() != null) {
            total += count(prompt.getContext());
        }
        
        return total;
    }
    
    public List<Integer> encode(String text) {
        return encoding.encode(text);
    }
    
    public String decode(List<Integer> tokens) {
        return encoding.decode(tokens);
    }
}

/**
 * Hash generator for integrity checking
 */
@ApplicationScoped
public class HashGenerator {
    
    public String hash(Object obj) {
        try {
            var json = JsonUtils.toJson(obj);
            var digest = MessageDigest.getInstance("SHA-256");
            var hashBytes = digest.digest(json.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hashBytes);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 not available", e);
        }
    }
    
    private String bytesToHex(byte[] bytes) {
        var hexString = new StringBuilder(2 * bytes.length);
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }
}

/**
 * Cost calculator for LLM usage
 */
@ApplicationScoped
public class CostCalculator {
    
    private final Map<String, ModelPricing> pricing = new ConcurrentHashMap<>();
    
    @PostConstruct
    void init() {
        // Load pricing data
        pricing.put("gpt-4", new ModelPricing(0.03, 0.06));
        pricing.put("gpt-3.5-turbo", new ModelPricing(0.0015, 0.002));
        pricing.put("claude-3-opus", new ModelPricing(0.015, 0.075));
        pricing.put("claude-3-sonnet", new ModelPricing(0.003, 0.015));
        // Add more models...
    }
    
    public double calculate(String modelId, int tokensIn, int tokensOut) {
        var modelPricing = pricing.getOrDefault(modelId, new ModelPricing(0.001, 0.002));
        
        var inputCost = (tokensIn / 1000.0) * modelPricing.inputPer1k;
        var outputCost = (tokensOut / 1000.0) * modelPricing.outputPer1k;
        
        return inputCost + outputCost;
    }
    
    private static class ModelPricing {
        final double inputPer1k;
        final double outputPer1k;
        
        ModelPricing(double inputPer1k, double outputPer1k) {
            this.inputPer1k = inputPer1k;
            this.outputPer1k = outputPer1k;
        }
    }
}

/**
 * Secret manager for credential access
 */
@ApplicationScoped
public class SecretManager {
    
    @ConfigProperty(name = "wayang.secrets.backend", defaultValue = "env")
    String backend;
    
    public Uni<String> getSecret(String key) {
        return switch (backend) {
            case "env" -> getFromEnvironment(key);
            case "vault" -> getFromVault(key);
            default -> Uni.createFrom().failure(
                new UnsupportedOperationException("Unsupported secret backend: " + backend)
            );
        };
    }
    
    private Uni<String> getFromEnvironment(String key) {
        var value = System.getenv(key.replace("/", "_").toUpperCase());
        if (value == null) {
            return Uni.createFrom().failure(
                new SecretNotFoundException("Secret not found: " + key)
            );
        }
        return Uni.createFrom().item(value);
    }
    
    private Uni<String> getFromVault(String key) {
        // TODO: Implement Vault integration
        return Uni.createFrom().failure(
            new UnsupportedOperationException("Vault integration not yet implemented")
        );
    }
}

/**
 * Model capability registry
 */
@ApplicationScoped
public class ModelCapabilityRegistry {
    
    private final Map<String, ModelInfo> models = new ConcurrentHashMap<>();
    
    @PostConstruct
    void init() {
        // Register default models
        registerModel(ModelInfo.builder()
            .id("gpt-4")
            .maxTokens(8192)
            .supportsFunction(true)
            .available(true)
            .build());
        
        registerModel(ModelInfo.builder()
            .id("claude-3-sonnet")
            .maxTokens(200000)
            .supportsFunction(false)
            .available(true)
            .build());
    }
    
    public void registerModel(ModelInfo model) {
        models.put(model.getId(), model);
    }
    
    public ModelInfo getModel(String modelId) {
        return models.get(modelId);
    }
    
    public ModelInfo getDefaultModel() {
        return models.values().stream()
            .filter(ModelInfo::isAvailable)
            .findFirst()
            .orElseThrow(() -> new RuntimeException("No available models"));
    }
    
    public ModelInfo getDefaultEmbeddingModel() {
        return ModelInfo.builder()
            .id("text-embedding-3-small")
            .maxTokens(8191)
            .available(true)
            .build();
    }
    
    public ModelInfo findBestModel(List<String> capabilities) {
        return models.values().stream()
            .filter(ModelInfo::isAvailable)
            .filter(m -> hasCapabilities(m, capabilities))
            .findFirst()
            .orElse(getDefaultModel());
    }
    
    private boolean hasCapabilities(ModelInfo model, List<String> capabilities) {
        for (var cap : capabilities) {
            if ("function_calling".equals(cap) && !model.supportsFunction()) {
                return false;
            }
        }
        return true;
    }
}

/**
 * Model info
 */
public class ModelInfo {
    private String id;
    private int maxTokens;
    private boolean supportsFunction;
    private boolean available;
    
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private ModelInfo model = new ModelInfo();
        
        public Builder id(String id) {
            model.id = id;
            return this;
        }
        
        public Builder maxTokens(int maxTokens) {
            model.maxTokens = maxTokens;
            return this;
        }
        
        public Builder supportsFunction(boolean supportsFunction) {
            model.supportsFunction = supportsFunction;
            return this;
        }
        
        public Builder available(boolean available) {
            model.available = available;
            return this;
        }
        
        public ModelInfo build() {
            return model;
        }
    }
    
    // Getters
    public String getId() { return id; }
    public int getMaxTokens() { return maxTokens; }
    public boolean supportsFunction() { return supportsFunction; }
    public boolean isAvailable() { return available; }
}

/**
 * Policy engine for access control
 */
@ApplicationScoped
public class PolicyEngine {
    
    private static PolicyEngine INSTANCE;
    
    @PostConstruct
    void init() {
        INSTANCE = this;
    }
    
    public static PolicyEngine instance() {
        return INSTANCE;
    }
    
    public List<Policy> getPolicies(String tenantId) {
        // TODO: Load from database or cache
        return List.of();
    }
    
    public boolean isCapabilityAllowed(String capability, String tenantId) {
        // TODO: Check against tenant policies
        return true; // Default allow for now
    }
    
    public boolean isCapabilityAllowed(String capability) {
        return true;
    }
    
    public PIIAction getPIIAction(String tenantId) {
        // TODO: Load from tenant config
        return PIIAction.REDACT;
    }
}

public class Policy {
    private String name;
    private String expression;
    
    public String getName() { return name; }
    public String getExpression() { return expression; }
}

public enum PIIAction {
    BLOCK,
    REDACT,
    ALLOW
}

/**
 * Event bus for workflow events
 */
@ApplicationScoped
public class EventBus {
    
    @Inject
    @Channel("workflow-events")
    Emitter<String> eventEmitter;
    
    public void publish(String eventType, Map<String, Object> payload) {
        var event = Map.of(
            "type", eventType,
            "payload", payload,
            "timestamp", Instant.now()
        );
        
        eventEmitter.send(JsonUtils.toJson(event));
    }
}

/**
 * Metrics collector
 */
@ApplicationScoped
public class MetricsCollector {
    
    @Inject
    MeterRegistry registry;
    
    private final String nodeId;
    private final Counter executionCounter;
    private final Timer executionTimer;
    private final Counter failureCounter;
    
    private MetricsCollector(String nodeId, MeterRegistry registry) {
        this.nodeId = nodeId;
        this.executionCounter = registry.counter("node.executions", "node", nodeId);
        this.executionTimer = registry.timer("node.duration", "node", nodeId);
        this.failureCounter = registry.counter("node.failures", "node", nodeId);
    }
    
    public static MetricsCollector forNode(String nodeId) {
        var registry = CDI.current().select(MeterRegistry.class).get();
        return new MetricsCollector(nodeId, registry);
    }
    
    public void recordExecution(long durationNanos, ExecutionResult.Status status) {
        executionCounter.increment();
        executionTimer.record(durationNanos, TimeUnit.NANOSECONDS);
        
        if (status == ExecutionResult.Status.FAILED) {
            failureCounter.increment();
        }
    }
    
    public void recordFailure(Throwable throwable) {
        failureCounter.increment();
    }
    
    public void close() {
        // Cleanup if needed
    }
}

/**
 * Provenance logger
 */
@ApplicationScoped  
public class ProvenanceLogger {
    
    @Inject
    @Channel("provenance-events")
    Emitter<String> provenanceEmitter;
    
    private final String nodeId;
    
    private ProvenanceLogger(String nodeId) {
        this.nodeId = nodeId;
    }
    
    public static ProvenanceLogger forNode(String nodeId) {
        var instance = new ProvenanceLogger(nodeId);
        var emitter = CDI.current().select(
            new TypeLiteral<Emitter<String>>() {},
            Channel.Literal.of("provenance-events")
        ).get();
        instance.provenanceEmitter = emitter;
        return instance;
    }
    
    public void log(NodeContext context, ExecutionResult result) {
        var entry = Map.of(
            "nodeId", nodeId,
            "runId", context.getRunId(),
            "tenantId", context.getTenantId(),
            "status", result.getStatus().name(),
            "timestamp", Instant.now(),
            "outputs", result.getOutputs()
        );
        
        provenanceEmitter.send(JsonUtils.toJson(entry));
    }
}

/**
 * Custom exceptions
 */
public class NodeException extends Exception {
    public NodeException(String message) {
        super(message);
    }
    
    public NodeException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class NodeExecutionException extends RuntimeException {
    public NodeExecutionException(String message) {
        super(message);
    }
    
    public NodeExecutionException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class ValidationException extends RuntimeException {
    public ValidationException(String message) {
        super(message);
    }
    
    public ValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class CelEvaluationException extends RuntimeException {
    public CelEvaluationException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class SecretNotFoundException extends RuntimeException {
    public SecretNotFoundException(String message) {
        super(message);
    }
}





package tech.kayys.wayang.nodes.services;

import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import org.eclipse.microprofile.rest.client.inject.RestClient;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.opentelemetry.api.trace.Tracer;

/**
 * ==============================================
 * MODEL ROUTER CLIENT - LLM Inference
 * Unified interface for calling any LLM provider
 * ==============================================
 */
@ApplicationScoped
public class ModelRouterClient {
    
    @Inject
    @RestClient
    ModelRouterService modelService;
    
    @Inject
    ModelCapabilityRegistry capabilityRegistry;
    
    @Inject
    PromptShaper promptShaper;
    
    @Inject
    CostCalculator costCalculator;
    
    @Inject
    Tracer tracer;
    
    /**
     * Execute LLM call with automatic model selection
     */
    public Uni<LLMResponse> call(LLMRequest request) {
        var span = tracer.spanBuilder("llm.call").startSpan();
        
        return Uni.createFrom().item(() -> {
            // Select best model based on hints
            var model = selectModel(request.getModelHints());
            span.setAttribute("model.id", model.getId());
            
            // Shape prompt with context
            var shapedPrompt = promptShaper.shape(
                request.getPrompt(),
                model.getMaxTokens(),
                request.getMetadata()
            );
            
            return new SelectedModel(model, shapedPrompt);
        })
        .flatMap(selected -> {
            // Call model service
            var apiRequest = buildApiRequest(selected, request);
            return modelService.complete(apiRequest);
        })
        .map(apiResponse -> {
            // Parse and enrich response
            var response = parseResponse(apiResponse);
            response.setCost(costCalculator.calculate(
                response.getModelId(),
                response.getTokensIn(),
                response.getTokensOut()
            ));
            
            span.setAttribute("tokens.in", response.getTokensIn());
            span.setAttribute("tokens.out", response.getTokensOut());
            span.setAttribute("cost", response.getCost());
            
            return response;
        })
        .eventually(() -> span.end());
    }
    
    /**
     * Generate embeddings
     */
    public Uni<EmbedResponse> embed(EmbedRequest request) {
        return Uni.createFrom().item(() -> {
            var model = request.getModel() != null 
                ? capabilityRegistry.getModel(request.getModel())
                : capabilityRegistry.getDefaultEmbeddingModel();
            
            return model;
        })
        .flatMap(model -> {
            var apiRequest = new EmbedApiRequest();
            apiRequest.setModel(model.getId());
            apiRequest.setTexts(request.getTexts());
            apiRequest.setNormalize(request.isNormalize());
            
            return modelService.embed(apiRequest);
        })
        .map(apiResponse -> {
            var response = new EmbedResponse();
            response.setEmbeddings(apiResponse.getEmbeddings());
            response.setDimensions(apiResponse.getDimensions());
            response.setModel(apiResponse.getModel());
            return response;
        });
    }
    
    /**
     * Select best model based on hints and availability
     */
    private ModelInfo selectModel(Map<String, Object> hints) {
        if (hints == null || hints.isEmpty()) {
            return capabilityRegistry.getDefaultModel();
        }
        
        // Check for preferred models
        var preferred = (List<String>) hints.get("preferred");
        if (preferred != null) {
            for (var modelId : preferred) {
                var model = capabilityRegistry.getModel(modelId);
                if (model != null && model.isAvailable()) {
                    return model;
                }
            }
        }
        
        // Check for required capabilities
        var capabilities = (List<String>) hints.get("capabilities");
        if (capabilities != null) {
            return capabilityRegistry.findBestModel(capabilities);
        }
        
        return capabilityRegistry.getDefaultModel();
    }
    
    private ModelApiRequest buildApiRequest(SelectedModel selected, LLMRequest request) {
        var apiRequest = new ModelApiRequest();
        apiRequest.setModel(selected.getModel().getId());
        apiRequest.setMessages(selected.getPrompt().toMessages());
        apiRequest.setMaxTokens(request.getMaxTokens());
        apiRequest.setTemperature(request.getTemperature());
        apiRequest.setStream(request.isStream());
        
        // Add functions if supported
        if (request.getFunctions() != null && !request.getFunctions().isEmpty()) {
            if (selected.getModel().supportsFunction()) {
                apiRequest.setFunctions(request.getFunctions());
            }
        }
        
        return apiRequest;
    }
    
    private LLMResponse parseResponse(ModelApiResponse apiResponse) {
        var response = new LLMResponse();
        response.setModelId(apiResponse.getModel());
        response.setOutput(apiResponse.getContent());
        response.setTokensIn(apiResponse.getUsage().getPromptTokens());
        response.setTokensOut(apiResponse.getUsage().getCompletionTokens());
        response.setFunctionCalls(apiResponse.getFunctionCalls());
        return response;
    }
    
    private static class SelectedModel {
        private final ModelInfo model;
        private final Prompt prompt;
        
        public SelectedModel(ModelInfo model, Prompt prompt) {
            this.model = model;
            this.prompt = prompt;
        }
        
        public ModelInfo getModel() { return model; }
        public Prompt getPrompt() { return prompt; }
    }
}

/**
 * ==============================================
 * RAG CLIENT - Retrieval Augmented Generation
 * ==============================================
 */
@ApplicationScoped
public class RAGClient {
    
    @Inject
    @RestClient
    RAGService ragService;
    
    @Inject
    ModelRouterClient modelRouter;
    
    @Inject
    ReRanker reRanker;
    
    /**
     * Retrieve relevant documents
     */
    public Uni<RAGResponse> retrieve(RAGRequest request) {
        return Uni.createFrom().item(() -> {
            // Generate query embedding
            return modelRouter.embed(EmbedRequest.builder()
                .texts(List.of(request.getQuery()))
                .build());
        })
        .flatMap(embedResponse -> {
            var queryEmbedding = embedResponse.getEmbeddings().get(0);
            
            // Perform hybrid search if enabled
            if (request.isHybrid()) {
                return performHybridSearch(request, queryEmbedding);
            } else {
                return performVectorSearch(request, queryEmbedding);
            }
        })
        .flatMap(results -> {
            // Re-rank if enabled
            if (request.isRerank() && results.size() > request.getTopK()) {
                return reRanker.rerank(request.getQuery(), results)
                    .map(reranked -> reranked.subList(0, Math.min(request.getTopK(), reranked.size())));
            }
            return Uni.createFrom().item(results);
        })
        .map(finalResults -> {
            // Build response with citations
            var response = new RAGResponse();
            response.setDocuments(finalResults);
            response.setScores(finalResults.stream()
                .map(Document::getScore)
                .collect(Collectors.toList()));
            response.setContext(assembleContext(finalResults));
            response.setCitations(buildCitations(finalResults));
            return response;
        });
    }
    
    private Uni<List<Document>> performHybridSearch(RAGRequest request, List<Float> embedding) {
        // Combine vector and keyword search
        return Uni.combine().all().unis(
            performVectorSearch(request, embedding),
            performKeywordSearch(request)
        ).asTuple()
        .map(tuple -> {
            var vectorResults = tuple.getItem1();
            var keywordResults = tuple.getItem2();
            
            // Merge and deduplicate
            return mergeResults(vectorResults, keywordResults, request.getTopK());
        });
    }
    
    private Uni<List<Document>> performVectorSearch(RAGRequest request, List<Float> embedding) {
        var searchRequest = new VectorSearchRequest();
        searchRequest.setIndex(request.getIndex());
        searchRequest.setEmbedding(embedding);
        searchRequest.setTopK(request.getTopK() * 2); // Over-fetch for re-ranking
        searchRequest.setFilters(request.getFilters());
        
        return ragService.vectorSearch(searchRequest)
            .map(response -> response.getDocuments());
    }
    
    private Uni<List<Document>> performKeywordSearch(RAGRequest request) {
        var searchRequest = new KeywordSearchRequest();
        searchRequest.setIndex(request.getIndex());
        searchRequest.setQuery(request.getQuery());
        searchRequest.setTopK(request.getTopK());
        searchRequest.setFilters(request.getFilters());
        
        return ragService.keywordSearch(searchRequest)
            .map(response -> response.getDocuments());
    }
    
    private List<Document> mergeResults(List<Document> vector, List<Document> keyword, int topK) {
        // Reciprocal Rank Fusion (RRF)
        var scoreMap = new HashMap<String, Double>();
        
        for (int i = 0; i < vector.size(); i++) {
            var doc = vector.get(i);
            scoreMap.put(doc.getId(), scoreMap.getOrDefault(doc.getId(), 0.0) + 1.0 / (i + 60));
        }
        
        for (int i = 0; i < keyword.size(); i++) {
            var doc = keyword.get(i);
            scoreMap.put(doc.getId(), scoreMap.getOrDefault(doc.getId(), 0.0) + 1.0 / (i + 60));
        }
        
        // Merge unique documents
        var allDocs = new HashMap<String, Document>();
        vector.forEach(doc -> allDocs.put(doc.getId(), doc));
        keyword.forEach(doc -> allDocs.put(doc.getId(), doc));
        
        // Sort by RRF score
        return allDocs.values().stream()
            .sorted((a, b) -> Double.compare(
                scoreMap.getOrDefault(b.getId(), 0.0),
                scoreMap.getOrDefault(a.getId(), 0.0)
            ))
            .limit(topK)
            .collect(Collectors.toList());
    }
    
    private String assembleContext(List<Document> documents) {
        var context = new StringBuilder();
        for (int i = 0; i < documents.size(); i++) {
            var doc = documents.get(i);
            context.append(String.format("[%d] %s\n\n", i + 1, doc.getContent()));
        }
        return context.toString();
    }
    
    private List<Citation> buildCitations(List<Document> documents) {
        return documents.stream()
            .map(doc -> new Citation(
                doc.getId(),
                doc.getSource(),
                doc.getMetadata().get("title"),
                doc.getScore()
            ))
            .collect(Collectors.toList());
    }
}

/**
 * ==============================================
 * MEMORY CLIENT - Agent Memory Management
 * ==============================================
 */
@ApplicationScoped
public class MemoryClient {
    
    @Inject
    @RestClient
    MemoryService memoryService;
    
    @Inject
    ModelRouterClient modelRouter;
    
    /**
     * Write memory entry
     */
    public Uni<String> write(Memory memory) {
        return Uni.createFrom().item(() -> {
            // Generate embedding for semantic memory
            if (memory.getType() == MemoryType.SEMANTIC) {
                var content = extractTextContent(memory.getContent());
                return modelRouter.embed(EmbedRequest.builder()
                    .texts(List.of(content))
                    .build());
            }
            return null;
        })
        .flatMap(embedResponse -> {
            var request = new MemoryWriteRequest();
            request.setType(memory.getType().name().toLowerCase());
            request.setContent(memory.getContent());
            request.setTtl(memory.getTtl().toString());
            request.setRunId(memory.getRunId());
            request.setTenantId(memory.getTenantId());
            request.setMetadata(memory.getMetadata());
            
            if (embedResponse != null) {
                request.setEmbedding(embedResponse.getEmbeddings().get(0));
            }
            
            return memoryService.writeMemory(request);
        })
        .map(response -> response.getMemoryId());
    }
    
    /**
     * Query memories
     */
    public Uni<List<Memory>> query(MemoryQuery query) {
        return modelRouter.embed(EmbedRequest.builder()
            .texts(List.of(query.getQuery()))
            .build())
        .flatMap(embedResponse -> {
            var request = new MemoryQueryRequest();
            request.setEmbedding(embedResponse.getEmbeddings().get(0));
            request.setTopK(query.getTopK());
            request.setTenantId(query.getTenantId());
            
            if (query.getTypes() != null) {
                request.setTypes(query.getTypes().stream()
                    .map(t -> t.name().toLowerCase())
                    .collect(Collectors.toList()));
            }
            
            return memoryService.queryMemory(request);
        })
        .map(response -> response.getMemories().stream()
            .map(this::toMemory)
            .collect(Collectors.toList()));
    }
    
    /**
     * Consolidate memories (periodic cleanup)
     */
    public Uni<Void> consolidate(String tenantId) {
        return memoryService.consolidateMemories(tenantId)
            .replaceWithVoid();
    }
    
    private String extractTextContent(Object content) {
        if (content instanceof String) {
            return (String) content;
        }
        if (content instanceof Map) {
            // Extract text from structured content
            var map = (Map<String, Object>) content;
            return map.getOrDefault("text", content.toString()).toString();
        }
        return content.toString();
    }
    
    private Memory toMemory(MemoryDto dto) {
        return Memory.builder()
            .id(dto.getId())
            .type(MemoryType.valueOf(dto.getType().toUpperCase()))
            .content(dto.getContent())
            .runId(dto.getRunId())
            .tenantId(dto.getTenantId())
            .metadata(dto.getMetadata())
            .createdAt(dto.getCreatedAt())
            .build();
    }
}

/**
 * ==============================================
 * TOOL GATEWAY CLIENT - MCP Tool Execution
 * ==============================================
 */
@ApplicationScoped
public class ToolGatewayClient {
    
    @Inject
    @RestClient
    ToolGatewayService toolService;
    
    @Inject
    SecretManager secretManager;
    
    @Inject
    SchemaValidator schemaValidator;
    
    @Inject
    CircuitBreakerManager circuitBreaker;
    
    /**
     * Execute tool with validation and security
     */
    public Uni<ToolResponse> execute(ToolRequest request) {
        return Uni.createFrom().item(() -> {
            // Get tool definition
            return toolService.getToolDefinition(request.getTool());
        })
        .flatMap(toolDef -> {
            // Validate parameters against schema
            var errors = schemaValidator.validate(
                request.getParameters(),
                toolDef.getParameterSchema()
            );
            
            if (!errors.isEmpty()) {
                return Uni.createFrom().item(
                    ToolResponse.error("Parameter validation failed: " + errors)
                );
            }
            
            // Get ephemeral credentials if needed
            return getCredentials(toolDef)
                .flatMap(credentials -> {
                    // Execute with circuit breaker
                    return circuitBreaker.execute(
                        "tool." + request.getTool(),
                        () -> executeWithTimeout(request, toolDef, credentials)
                    );
                });
        })
        .onFailure().recoverWithItem(throwable -> {
            // Convert failure to structured response
            var isRetryable = throwable instanceof TimeoutException ||
                             throwable instanceof IOException;
            
            return ToolResponse.builder()
                .error(throwable.getMessage())
                .retryable(isRetryable)
                .build();
        });
    }
    
    private Uni<Map<String, String>> getCredentials(ToolDefinition toolDef) {
        if (toolDef.getRequiredSecrets() == null || toolDef.getRequiredSecrets().isEmpty()) {
            return Uni.createFrom().item(Map.of());
        }
        
        var credentialUnis = toolDef.getRequiredSecrets().stream()
            .map(secretKey -> secretManager.getSecret(secretKey)
                .map(secret -> Map.entry(secretKey, secret)))
            .collect(Collectors.toList());
        
        return Uni.join().all(credentialUnis).andFailFast()
            .map(entries -> entries.stream()
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));
    }
    
    private Uni<ToolResponse> executeWithTimeout(
        ToolRequest request,
        ToolDefinition toolDef,
        Map<String, String> credentials
    ) {
        var executionRequest = new ToolExecutionRequest();
        executionRequest.setTool(request.getTool());
        executionRequest.setParameters(request.getParameters());
        executionRequest.setCredentials(credentials);
        executionRequest.setRunId(request.getRunId());
        executionRequest.setTenantId(request.getTenantId());
        
        return toolService.executeTool(executionRequest)
            .ifNoItem().after(Duration.ofMillis(request.getTimeout()))
            .fail()
            .map(apiResponse -> {
                var response = new ToolResponse();
                response.setResult(apiResponse.getResult());
                response.setDuration(apiResponse.getDuration());
                response.setError(apiResponse.getError());
                response.setRetryable(apiResponse.isRetryable());
                return response;
            });
    }
}

/**
 * ==============================================
 * GUARDRAILS ENGINE - Policy Enforcement
 * ==============================================
 */
@ApplicationScoped
public class GuardrailsEngine {
    
    @Inject
    CelEngine celEngine;
    
    @Inject
    PolicyEngine policyEngine;
    
    @Inject
    PIIDetector piiDetector;
    
    @Inject
    ContentModerator contentModerator;
    
    private static GuardrailsEngine INSTANCE;
    
    public static GuardrailsEngine instance() {
        return INSTANCE;
    }
    
    @PostConstruct
    void init() {
        INSTANCE = this;
    }
    
    /**
     * Pre-execution checks
     */
    public Uni<GuardrailResult> preCheck(NodeContext context, NodeDescriptor descriptor) {
        return Uni.createFrom().item(() -> {
            // Check tenant policies
            var tenantPolicies = policyEngine.getPolicies(context.getTenantId());
            for (var policy : tenantPolicies) {
                if (!evaluatePolicy(policy, context)) {
                    return GuardrailResult.deny("Policy violation: " + policy.getName());
                }
            }
            
            // Check node capabilities
            var capabilities = descriptor.getCapabilities();
            if (capabilities != null) {
                for (var capability : capabilities) {
                    if (!policyEngine.isCapabilityAllowed(capability, context.getTenantId())) {
                        return GuardrailResult.deny("Capability not allowed: " + capability);
                    }
                }
            }
            
            // PII detection in inputs
            var inputs = context.getAllInputs();
            var piiFindings = piiDetector.scan(inputs);
            if (!piiFindings.isEmpty()) {
                // Redact PII based on policy
                var action = policyEngine.getPIIAction(context.getTenantId());
                if (action == PIIAction.BLOCK) {
                    return GuardrailResult.deny("PII detected in inputs");
                } else if (action == PIIAction.REDACT) {
                    redactPII(inputs, piiFindings);
                }
            }
            
            return GuardrailResult.allow();
        });
    }
    
    /**
     * Post-execution checks
     */
    public Uni<GuardrailResult> postCheck(ExecutionResult result, NodeDescriptor descriptor) {
        if (!result.isSuccess()) {
            return Uni.createFrom().item(GuardrailResult.allow());
        }
        
        return Uni.createFrom().item(() -> {
            var outputs = result.getOutputs();
            
            // Content moderation
            var moderationResult = contentModerator.moderate(outputs);
            if (moderationResult.isFlagged()) {
                return GuardrailResult.deny("Content policy violation: " + 
                    moderationResult.getCategories());
            }
            
            // PII detection in outputs
            var piiFindings = piiDetector.scan(outputs);
            if (!piiFindings.isEmpty()) {
                redactPII(outputs, piiFindings);
            }
            
            return GuardrailResult.allow();
        });
    }
    
    private boolean evaluatePolicy(Policy policy, NodeContext context) {
        try {
            var result = celEngine.evaluate(
                policy.getExpression(),
                buildPolicyContext(context)
            );
            return Boolean.TRUE.equals(result);
        } catch (Exception e) {
            // Policy evaluation failure - deny by default
            return false;
        }
    }
    
    private Map<String, Object> buildPolicyContext(NodeContext context) {
        var ctx = new HashMap<String, Object>();
        ctx.put("tenantId", context.getTenantId());
        ctx.put("userId", context.getMetadata().getUserId());
        ctx.put("runId", context.getRunId());
        ctx.put("inputs", context.getAllInputs());
        return ctx;
    }
    
    private void redactPII(Map<String, Object> data, List<PIIFinding> findings) {
        for (var finding : findings) {
            var path = finding.getPath();
            var redacted = "[REDACTED:" + finding.getType() + "]";
            setValueAtPath(data, path, redacted);
        }
    }
    
    private void setValueAtPath(Map<String, Object> data, String path, Object value) {
        var parts = path.split("\\.");
        Map<String, Object> current = data;
        
        for (int i = 0; i < parts.length - 1; i++) {
            current = (Map<String, Object>) current.get(parts[i]);
            if (current == null) return;
        }
        
        current.put(parts[parts.length - 1], value);
    }
}

/**
 * Guardrail result
 */
public class GuardrailResult {
    private final boolean allowed;
    private final String reason;
    
    private GuardrailResult(boolean allowed, String reason) {
        this.allowed = allowed;
        this.reason = reason;
    }
    
    public static GuardrailResult allow() {
        return new GuardrailResult(true, null);
    }
    
    public static GuardrailResult deny(String reason) {
        return new GuardrailResult(false, reason);
    }
    
    public boolean isAllowed() { return allowed; }
    public String getReason() { return reason; }
}



package tech.kayys.wayang.nodes.builtin;

import io.smallrye.mutiny.Uni;
import tech.kayys.wayang.core.node.*;
import jakarta.enterprise.context.ApplicationScoped;

/**
 * ==============================================
 * CONTROL FLOW NODES
 * ==============================================
 */

/**
 * Start Node - Entry point for workflow execution
 * Validates initial inputs and sets up execution context
 */
@ApplicationScoped
@NodeType("builtin.start")
public class StartNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        return Uni.createFrom().item(() -> {
            // Validate workflow-level inputs
            var inputs = context.getAllInputs();
            
            // Emit workflow start event
            context.emitEvent("workflow.started", Map.of(
                "runId", context.getRunId(),
                "inputs", inputs,
                "timestamp", Instant.now()
            ));
            
            // Pass through inputs to next nodes
            return ExecutionResult.success(inputs);
        });
    }
}

/**
 * End Node - Terminal node for workflow completion
 * Collects final outputs and triggers cleanup
 */
@ApplicationScoped
@NodeType("builtin.end")
public class EndNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        return Uni.createFrom().item(() -> {
            var finalOutputs = context.getAllInputs();
            
            // Emit workflow completion event
            context.emitEvent("workflow.completed", Map.of(
                "runId", context.getRunId(),
                "outputs", finalOutputs,
                "timestamp", Instant.now()
            ));
            
            return ExecutionResult.success(finalOutputs);
        });
    }
}

/**
 * Decision Node - Conditional branching using CEL expressions
 * Routes execution based on evaluated conditions
 */
@ApplicationScoped
@NodeType("builtin.decision")
public class DecisionNode extends AbstractNode {
    
    private CelEngine celEngine;
    
    @Override
    protected void doOnLoad(NodeDescriptor descriptor, NodeConfig config) {
        this.celEngine = CelEngine.create();
    }
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        return Uni.createFrom().item(() -> {
            var condition = config.getString("condition");
            var celContext = buildCelContext(context);
            
            try {
                var result = celEngine.evaluate(condition, celContext);
                var branch = Boolean.TRUE.equals(result) ? "true" : "false";
                
                return ExecutionResult.success(Map.of(
                    "branch", branch,
                    "condition", condition,
                    "result", result
                ));
            } catch (Exception e) {
                throw new ValidationException("CEL evaluation failed: " + e.getMessage(), e);
            }
        });
    }
    
    private Map<String, Object> buildCelContext(NodeContext context) {
        var celCtx = new HashMap<String, Object>();
        celCtx.putAll(context.getAllInputs());
        celCtx.put("metadata", context.getMetadata());
        return celCtx;
    }
}

/**
 * Loop Node - Iterative execution over collections
 * Supports for-each pattern with configurable parallelism
 */
@ApplicationScoped
@NodeType("builtin.loop")
public class LoopNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var collection = (Collection<?>) context.getInput("collection");
        var maxParallel = config.getInt("maxParallel", 1);
        
        if (collection == null || collection.isEmpty()) {
            return Uni.createFrom().item(ExecutionResult.success(Map.of("items", List.of())));
        }
        
        // Execute iterations with controlled parallelism
        return Uni.join().all(
            collection.stream()
                .map(item -> executeIteration(context, item))
                .collect(Collectors.toList())
        ).andCollectFailures()
        .map(results -> ExecutionResult.success(Map.of(
            "items", results,
            "count", results.size()
        )));
    }
    
    private Uni<Object> executeIteration(NodeContext context, Object item) {
        // Create iteration-scoped context
        var iterationCtx = context.createChild();
        iterationCtx.setVariable("item", item);
        
        // Execute iteration logic (delegated to sub-workflow)
        return Uni.createFrom().item(item);
    }
}

/**
 * Merge Node - Combines multiple input branches
 * Supports various merge strategies (all, any, first)
 */
@ApplicationScoped
@NodeType("builtin.merge")
public class MergeNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        return Uni.createFrom().item(() -> {
            var strategy = config.getString("strategy", "all");
            var inputs = context.getAllInputs();
            
            var merged = switch (strategy) {
                case "all" -> mergeAll(inputs);
                case "first" -> mergeFirst(inputs);
                case "any" -> mergeAny(inputs);
                default -> throw new ValidationException("Unknown merge strategy: " + strategy);
            };
            
            return ExecutionResult.success(Map.of("merged", merged));
        });
    }
    
    private Map<String, Object> mergeAll(Map<String, Object> inputs) {
        // Wait for all branches, merge outputs
        var merged = new HashMap<String, Object>();
        inputs.forEach((key, value) -> {
            if (value instanceof Map) {
                merged.putAll((Map<String, Object>) value);
            }
        });
        return merged;
    }
    
    private Map<String, Object> mergeFirst(Map<String, Object> inputs) {
        // Return first non-null input
        return inputs.values().stream()
            .filter(v -> v != null)
            .findFirst()
            .map(v -> v instanceof Map ? (Map<String, Object>) v : Map.of("value", v))
            .orElse(Map.of());
    }
    
    private Map<String, Object> mergeAny(Map<String, Object> inputs) {
        // Return any non-null input
        return mergeFirst(inputs);
    }
}

/**
 * ==============================================
 * AI & LLM NODES
 * ==============================================
 */

/**
 * Agent Node - LLM-powered reasoning with chain-of-thought
 * Supports function calling, streaming, and persona injection
 */
@ApplicationScoped
@NodeType("builtin.agent")
public class AgentNode extends AbstractNode {
    
    @Inject
    ModelRouterClient modelRouter;
    
    @Inject
    PersonaService personaService;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        // Emit agent preparation event
        emitNodeEvent(context, "agent.preparing", Map.of(
            "stage", "preparing",
            "message", "Building prompt and selecting model"
        ));
        
        var prompt = buildPrompt(context);
        var modelHints = config.getObject("modelHints", Map.class);
        var functions = config.getList("functions", Map.class);
        
        var request = LLMRequest.builder()
            .prompt(prompt)
            .modelHints(modelHints)
            .functions(functions)
            .maxTokens(config.getInt("maxTokens", 1024))
            .temperature(config.getDouble("temperature", 0.7))
            .stream(config.getBoolean("stream", false))
            .metadata(Map.of(
                "runId", context.getRunId(),
                "nodeId", context.getNodeId(),
                "tenantId", context.getTenantId()
            ))
            .build();
        
        // Emit model calling event
        emitNodeEvent(context, "agent.calling.model", Map.of(
            "stage", "inference",
            "message", "Calling LLM for inference"
        ));
        
        return modelRouter.call(request)
            .onItem().invoke(response -> {
                // Emit response received event
                emitNodeEvent(context, "agent.response.received", Map.of(
                    "stage", "complete",
                    "message", "Response received from LLM",
                    "model", response.getModelId(),
                    "tokensUsed", response.getTokensUsed(),
                    "cost", response.getCost()
                ));
            })
            .map(response -> ExecutionResult.success(Map.of(
                "response", response.getOutput(),
                "model", response.getModelId(),
                "tokensUsed", response.getTokensUsed(),
                "cost", response.getCost(),
                "functionCalls", response.getFunctionCalls()
            )));
    }
    
    private Prompt buildPrompt(NodeContext context) {
        var personaId = config.getString("persona");
        var persona = personaId != null 
            ? personaService.getPersona(personaId) 
            : Persona.defaultPersona();
        
        var systemPrompt = persona.getSystemPrompt();
        var userMessage = context.getInput("message");
        
        return Prompt.builder()
            .system(systemPrompt)
            .user(userMessage)
            .context(buildContext(context))
            .build();
    }
    
    private Map<String, Object> buildContext(NodeContext context) {
        var ctx = new HashMap<String, Object>();
        
        // Add RAG context if available
        var ragContext = context.getInput("ragContext");
        if (ragContext != null) {
            ctx.put("knowledge", ragContext);
        }
        
        // Add memory context
        var memoryContext = context.getInput("memory");
        if (memoryContext != null) {
            ctx.put("memory", memoryContext);
        }
        
        return ctx;
    }
}

/**
 * RAG Node - Retrieval Augmented Generation
 * Performs hybrid search (vector + keyword) with re-ranking
 */
@ApplicationScoped
@NodeType("builtin.rag")
public class RAGNode extends AbstractNode {
    
    @Inject
    RAGClient ragClient;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var query = (String) context.getInput("query");
        var topK = config.getInt("topK", 5);
        var indexName = config.getString("index", "default");
        var useHybrid = config.getBoolean("hybrid", true);
        var rerank = config.getBoolean("rerank", true);
        
        var request = RAGRequest.builder()
            .query(query)
            .topK(topK)
            .index(indexName)
            .hybrid(useHybrid)
            .rerank(rerank)
            .filters(buildFilters(context))
            .build();
        
        return ragClient.retrieve(request)
            .map(response -> ExecutionResult.success(Map.of(
                "documents", response.getDocuments(),
                "scores", response.getScores(),
                "context", response.assembleContext(),
                "citations", response.getCitations()
            )));
    }
    
    private Map<String, Object> buildFilters(NodeContext context) {
        var filters = new HashMap<String, Object>();
        filters.put("tenantId", context.getTenantId());
        
        // Add custom filters from config
        var customFilters = config.getObject("filters", Map.class);
        if (customFilters != null) {
            filters.putAll(customFilters);
        }
        
        return filters;
    }
}

/**
 * Embedder Node - Generate embeddings for text
 * Supports batch processing and multiple embedding models
 */
@ApplicationScoped
@NodeType("builtin.embedder")
public class EmbedderNode extends AbstractNode {
    
    @Inject
    ModelRouterClient modelRouter;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var texts = (Collection<String>) context.getInput("texts");
        var model = config.getString("model", "default");
        
        if (texts == null || texts.isEmpty()) {
            return Uni.createFrom().item(ExecutionResult.success(Map.of("embeddings", List.of())));
        }
        
        var request = EmbedRequest.builder()
            .texts(new ArrayList<>(texts))
            .model(model)
            .normalize(config.getBoolean("normalize", true))
            .build();
        
        return modelRouter.embed(request)
            .map(response -> ExecutionResult.success(Map.of(
                "embeddings", response.getEmbeddings(),
                "dimensions", response.getDimensions(),
                "model", response.getModel()
            )));
    }
}

/**
 * ==============================================
 * MEMORY & STATE NODES
 * ==============================================
 */

/**
 * Memory Write Node - Store information in agent memory
 * Supports episodic, semantic, and procedural memory types
 */
@ApplicationScoped
@NodeType("builtin.memory.write")
public class MemoryWriteNode extends AbstractNode {
    
    @Inject
    MemoryClient memoryClient;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var content = context.getInput("content");
        var type = config.getString("type", "episodic");
        var ttl = config.getString("ttl", "P30D");
        
        var memory = Memory.builder()
            .type(MemoryType.valueOf(type.toUpperCase()))
            .content(content)
            .ttl(Duration.parse(ttl))
            .runId(context.getRunId())
            .tenantId(context.getTenantId())
            .metadata(context.getMetadata().toMap())
            .build();
        
        return memoryClient.write(memory)
            .map(memoryId -> ExecutionResult.success(Map.of(
                "memoryId", memoryId,
                "type", type
            )));
    }
}

/**
 * Memory Read Node - Retrieve relevant memories
 * Uses semantic search over stored memories
 */
@ApplicationScoped
@NodeType("builtin.memory.read")
public class MemoryReadNode extends AbstractNode {
    
    @Inject
    MemoryClient memoryClient;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var query = (String) context.getInput("query");
        var topK = config.getInt("topK", 5);
        var types = config.getList("types", String.class);
        
        var request = MemoryQuery.builder()
            .query(query)
            .topK(topK)
            .types(types != null ? types.stream().map(MemoryType::valueOf).collect(Collectors.toList()) : null)
            .tenantId(context.getTenantId())
            .build();
        
        return memoryClient.query(request)
            .map(memories -> ExecutionResult.success(Map.of(
                "memories", memories,
                "count", memories.size()
            )));
    }
}

/**
 * ==============================================
 * TOOL & INTEGRATION NODES
 * ==============================================
 */

/**
 * Tool Call Node - Execute external tools via MCP
 * Supports schema validation and retry logic
 */
@ApplicationScoped
@NodeType("builtin.tool")
public class ToolCallNode extends AbstractNode {
    
    @Inject
    ToolGatewayClient toolGateway;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var toolName = config.getString("tool");
        var parameters = context.getInput("parameters");
        
        var request = ToolRequest.builder()
            .tool(toolName)
            .parameters(parameters)
            .timeout(config.getInt("timeout", 30000))
            .runId(context.getRunId())
            .tenantId(context.getTenantId())
            .build();
        
        return toolGateway.execute(request)
            .map(response -> {
                if (response.isError()) {
                    return ExecutionResult.error(
                        ErrorPayload.builder()
                            .type(ErrorType.ToolError)
                            .message(response.getError())
                            .retryable(response.isRetryable())
                            .build()
                    );
                }
                
                return ExecutionResult.success(Map.of(
                    "result", response.getResult(),
                    "tool", toolName,
                    "duration", response.getDuration()
                ));
            });
    }
}

/**
 * HTTP Node - Make HTTP requests with full configurability
 * Supports all methods, headers, auth, and retries
 */
@ApplicationScoped
@NodeType("builtin.http")
public class HttpNode extends AbstractNode {
    
    @Inject
    @RestClient
    HttpClientService httpClient;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var url = config.getString("url");
        var method = config.getString("method", "GET");
        var headers = config.getObject("headers", Map.class);
        var body = context.getInput("body");
        
        var request = HttpRequest.builder()
            .url(url)
            .method(HttpMethod.valueOf(method))
            .headers(headers)
            .body(body)
            .timeout(config.getInt("timeout", 30000))
            .build();
        
        return httpClient.execute(request)
            .map(response -> ExecutionResult.success(Map.of(
                "status", response.getStatus(),
                "headers", response.getHeaders(),
                "body", response.getBody()
            )));
    }
}

/**
 * ==============================================
 * DATA TRANSFORMATION NODES
 * ==============================================
 */

/**
 * Transformer Node - Transform data using templates or scripts
 * Supports JSONPath, JOLT, and JavaScript transformations
 */
@ApplicationScoped
@NodeType("builtin.transform")
public class TransformerNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var input = context.getInput("data");
        var type = config.getString("type", "jsonpath");
        var template = config.getString("template");
        
        return Uni.createFrom().item(() -> {
            var transformed = switch (type) {
                case "jsonpath" -> applyJsonPath(input, template);
                case "jolt" -> applyJolt(input, template);
                case "javascript" -> applyJavaScript(input, template);
                default -> throw new ValidationException("Unknown transform type: " + type);
            };
            
            return ExecutionResult.success(Map.of("result", transformed));
        });
    }
    
    private Object applyJsonPath(Object input, String path) {
        return JsonPath.read(input, path);
    }
    
    private Object applyJolt(Object input, String spec) {
        var chainr = Chainr.fromSpec(JsonUtils.jsonToObject(spec));
        return chainr.transform(input);
    }
    
    private Object applyJavaScript(Object input, String script) {
        var engine = new ScriptEngineManager().getEngineByName("nashorn");
        engine.put("input", input);
        try {
            return engine.eval(script);
        } catch (ScriptException e) {
            throw new ValidationException("JavaScript execution failed", e);
        }
    }
}

/**
 * Validator Node - Validate data against schemas
 * Supports JSON Schema, CEL, and custom validators
 */
@ApplicationScoped
@NodeType("builtin.validator")
public class ValidatorNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var data = context.getInput("data");
        var schema = config.getObject("schema", Map.class);
        var celRules = config.getList("celRules", String.class);
        
        return Uni.createFrom().item(() -> {
            var errors = new ArrayList<String>();
            
            // JSON Schema validation
            if (schema != null) {
                var schemaErrors = SchemaValidator.validate(data, schema);
                errors.addAll(schemaErrors);
            }
            
            // CEL rules validation
            if (celRules != null) {
                var celErrors = validateCelRules(data, celRules);
                errors.addAll(celErrors);
            }
            
            var isValid = errors.isEmpty();
            
            return ExecutionResult.success(Map.of(
                "valid", isValid,
                "errors", errors,
                "data", data
            ));
        });
    }
    
    private List<String> validateCelRules(Object data, List<String> rules) {
        var errors = new ArrayList<String>();
        var celEngine = CelEngine.create();
        
        for (var rule : rules) {
            try {
                var result = celEngine.evaluate(rule, Map.of("data", data));
                if (!Boolean.TRUE.equals(result)) {
                    errors.add("Rule failed: " + rule);
                }
            } catch (Exception e) {
                errors.add("Rule error: " + e.getMessage());
            }
        }
        
        return errors;
    }
}

/**
 * ==============================================
 * ERROR HANDLING & OBSERVABILITY NODES
 * ==============================================
 */

/**
 * Error Handler Node - Process and route errors
 * Implements retry, fallback, auto-fix, and escalation logic
 */
@ApplicationScoped
@NodeType("builtin.error.handler")
public class ErrorHandlerNode extends AbstractNode {
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var error = (ErrorPayload) context.getInput("error");
        var rules = config.getList("rules", Map.class);
        
        return Uni.createFrom().item(() -> {
            // Evaluate rules to determine action
            for (var rule : rules) {
                var condition = (String) rule.get("when");
                var action = (String) rule.get("action");
                
                if (evaluateErrorCondition(error, condition)) {
                    return ExecutionResult.success(Map.of(
                        "action", action,
                        "error", error,
                        "rule", rule.get("name")
                    ));
                }
            }
            
            // Default action
            return ExecutionResult.success(Map.of(
                "action", "abort",
                "error", error
            ));
        });
    }
    
    private boolean evaluateErrorCondition(ErrorPayload error, String condition) {
        var celEngine = CelEngine.create();
        var context = Map.of("error", error);
        
        try {
            var result = celEngine.evaluate(condition, context);
            return Boolean.TRUE.equals(result);
        } catch (Exception e) {
            context.getLogger().warn("Error condition evaluation failed", e);
            return false;
        }
    }
}

/**
 * Audit Node - Log events for compliance and tracing
 * Provides tamper-proof execution logs with optional signing
 */
@ApplicationScoped
@NodeType("builtin.audit")
public class AuditNode extends AbstractNode {
    
    @Inject
    AuditService auditService;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var event = context.getInput("event");
        var level = config.getString("level", "INFO");
        var tags = config.getList("tags", String.class);
        
        var auditEntry = AuditEntry.builder()
            .event(event)
            .level(AuditLevel.valueOf(level))
            .tags(tags)
            .runId(context.getRunId())
            .nodeId(context.getNodeId())
            .tenantId(context.getTenantId())
            .timestamp(Instant.now())
            .metadata(context.getMetadata().toMap())
            .build();
        
        return auditService.log(auditEntry)
            .map(auditId -> ExecutionResult.success(Map.of(
                "auditId", auditId,
                "level", level
            )));
    }
}

/**
 * Human-in-the-Loop Node - Pause for human review
 * Creates approval tasks and waits for human decision
 */
@ApplicationScoped
@NodeType("builtin.hitl")
public class HumanReviewNode extends AbstractNode {
    
    @Inject
    HITLService hitlService;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var data = context.getAllInputs();
        var reviewType = config.getString("reviewType", "approval");
        var timeout = config.getInt("timeout", 3600000); // 1 hour default
        
        var task = HITLTask.builder()
            .type(reviewType)
            .data(data)
            .runId(context.getRunId())
            .nodeId(context.getNodeId())
            .tenantId(context.getTenantId())
            .timeout(timeout)
            .build();
        
        return hitlService.createTask(task)
            .flatMap(taskId -> hitlService.waitForCompletion(taskId))
            .map(decision -> ExecutionResult.success(Map.of(
                "decision", decision.getAction(),
                "reviewer", decision.getReviewer(),
                "notes", decision.getNotes(),
                "correctedData", decision.getCorrectedData()
            )));
    }
    
    @Override
    public Optional<CheckpointState> checkpoint(NodeContext context) {
        // Support resumability after human review
        return Optional.of(CheckpointState.of(
            "awaiting_human_review",
            context.getAllInputs()
        ));
    }
}

/**
 * Self-Healing Node - Auto-repair errors using LLM
 * Attempts to fix malformed inputs or outputs
 */
@ApplicationScoped
@NodeType("builtin.self.heal")
public class SelfHealingNode extends AbstractNode {
    
    @Inject
    ModelRouterClient modelRouter;
    
    @Override
    protected Uni<ExecutionResult> doExecute(NodeContext context) {
        var errorData = context.getInput("error");
        var schema = config.getObject("targetSchema", Map.class);
        var maxAttempts = config.getInt("maxAttempts", 2);
        
        var prompt = buildRepairPrompt(errorData, schema);
        
        var request = LLMRequest.builder()
            .prompt(prompt)
            .maxTokens(512)
            .temperature(0.1) // Low temperature for deterministic repair
            .build();
        
        return modelRouter.call(request)
            .map(response -> {
                var fixed = response.getOutput();
                
                // Validate fixed output against schema
                var errors = SchemaValidator.validate(fixed, schema);
                if (!errors.isEmpty()) {
                    return ExecutionResult.failed("Auto-fix failed validation");
                }
                
                return ExecutionResult.success(Map.of(
                    "fixed", fixed,
                    "original", errorData,
                    "tokensUsed", response.getTokensUsed()
                ));
            });
    }
    
    private Prompt buildRepairPrompt(Object errorData, Map<String, Object> schema) {
        return Prompt.builder()
            .system("You are a data repair assistant. Fix the provided data to match the schema.")
            .user(String.format(
                "Data: %s\n\nSchema: %s\n\nProvide corrected JSON only.",
                JsonUtils.toJson(errorData),
                JsonUtils.toJson(schema)
            ))
            .build();
    }
}